<!DOCTYPE html>
<html lang="en">
<head>
<base href="/">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>CloudApp Editor</title>
<script src="https://nkmplay.github.io/cgf/scripts/fabric.min.js"></script>
    <script src="https://nkmplay.github.io/cgf/scripts/html2canvas.min.js"></script>
    <script src="https://nkmplay.github.io/cgf/scripts/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://nkmplay.github.io/cgf/scripts/pdf.worker.min.js';</script>
    <link rel="stylesheet" href="https://nkmplay.github.io/cgf/scripts/cropper.min.css">
    <script src="https://nkmplay.github.io/cgf/scripts/cropper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.4.0/dist/pdf-lib.min.js"></script>
	<script src="https://cloudgraficaweb.github.io/CGVendas/scripts/potrace.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  body,html{margin:0;padding:0;height:100%;overflow:hidden;font-family:Arial,sans-serif}
  #left-menu{position:fixed;top:40px;left:0;width:60px;bottom:0;background-color:#0f3460;padding:10px;color:#fff}
  #canvas-container{position:fixed;top:40px;left:80px;right:200px;bottom:0;background-color:transparent;overflow:hidden}
  .tool-button {
    background-color:#0f3460;
    color:#fff;
    border:2px solid #4a90e2;
    padding:8px 8px;
    border-radius:4px;
    width:100%;
    cursor:pointer;
    font-size:10px;
    font-weight:700;
    height:60px;
    margin:5px 0;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:10px;
  }
  .tool-button i {
    font-size:12px;
  }
  .tool-button.selected {
    background-color: #4a90e2;
  }
  .separator {
    border-bottom: 1px solid #4a90e2;
    margin: 5px 0;
  }
  #fileInput{display:none}
  #top-menu{position:fixed;top:0;left:0;right:0;height:40px;background-color:#0f3460;display:flex;align-items:center;padding:0 5px;z-index:1000}
  .menu-item{position:relative;color:#fff;padding:0 12px;cursor:pointer;height:100%;display:flex;align-items:center}
  .menu-item:hover .dropdown{display:block}
  .dropdown{display:none;position:absolute;top:40px;left:0;background-color:#0f3460;min-width:250px;box-shadow:0 12px 24px rgba(0,0,0,0.4), 0 4px 8px rgba(0,0,0,0.3)}
  .dropdown a{color:#fff;padding:12px 16px;text-decoration:none;display:block;display:flex;justify-content:space-between;align-items:center}
  .dropdown a:hover{background-color:#16213e}
  .dropdown input{width:60px;padding:2px 4px;margin-left:10px;border-radius:3px;border:1px solid #ccc}

  .size-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-left: 20px;
    color: white;
  }
  .size-controls input {
    width: 60px;
    padding: 4px;
    border-radius: 4px;
    border: 1px solid #4a90e2;
    background: #16213e;
    color: white;
  }
  .size-controls button {
    background: none;
    border: none;
    color: white;
    cursor: pointer;
    padding: 4px 8px;
    font-size: 16px;
  }
  .thick-separator {
    border-left: 2px solid #4a90e2;
    height: 24px;
    margin: 0 10px;
  }
  .document-size-item {
    position: relative;
  }

  .document-size-controls {
    position: absolute;
    left: 100%;
    top: 0;
    background-color: #0f3460;
    padding: 12px;
    border-radius: 4px;
    display: none;
    gap: 8px;
    min-width: 200px;
  }

  .document-size-item:hover .document-size-controls {
    display: flex;
    flex-direction: column;
  }

  .size-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .document-size-controls input {
    width: 60px;
    padding: 4px;
    border-radius: 4px;
    border: 1px solid #4a90e2;
    background: #16213e;
    color: white;
  }

  .document-size-controls button {
    background: none;
    border: 1px solid #4a90e2;
    color: white;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
  }

  .document-size-controls #doc-size-ok {
    background: #4a90e2;
    width: 100%;
    margin-top: 8px;
  }

  .guides-item {
    position: relative;
  }

  .guides-controls {
    position: absolute;
    left: 100%;
    top: 0;
    background-color: #0f3460;
    padding: 12px;
    border-radius: 4px;
    display: none;
    gap: 8px;
    min-width: 200px;
  }

  .guides-item:hover .guides-controls {
    display: flex;
    flex-direction: column;
  }

  .guide-options {
    display: flex;
    gap: 4px;
  }

  .guide-btn {
    flex: 1;
    background: #16213e;
    border: 1px solid #4a90e2;
    color: white;
    padding: 6px;
    border-radius: 4px;
    cursor: pointer;
  }

  .guide-btn.selected {
    background: #4a90e2;
  }

  .guide-position {
    margin-top: 8px;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .guide-position input {
    width: 100%;
    padding: 4px;
    border-radius: 4px;
    border: 1px solid #4a90e2;
    background: #16213e;
    color: white;
  }

  #right-menu {
    position: fixed;
    top: 40px;
    right: 0;
    width: 200px;
    bottom: 0;
    background-color: #0f3460;
    color: #fff;
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  #layersList {
    list-style: none;
    padding: 0;
    margin: 0 0 10px 0;
    flex-grow: 1;
    overflow-y: auto;
  }

  #layersList li {
    padding: 8px 12px;
    cursor: pointer;
    background: #16213e;
    margin-bottom: 4px;
    border-radius: 4px;
    user-select: none;
    display: flex;
    align-items: center;
    color: #fff;
    transition: background-color 0.2s;
  }

  #layersList li.selected {
    background: #4a90e2;
    color: #ffeb3b;
  }

  #layersList li.dragging {
    opacity: 0.5;
  }

  #layersList li.over {
    border: 2px dashed #4a90e2;
  }

  .layers-buttons {
    position: sticky;
    bottom: 0;
    background: #0f3460;
    padding-top: 10px;
    display: flex;
    gap: 5px;
  }

  .layer-btn {
    flex: 1;
    background: #16213e;
    border: 1px solid #4a90e2;
    color: white;
    padding: 8px;
    border-radius: 4px;
    cursor: pointer;
  }

  .layer-btn:hover {
    background: #4a90e2;
  }
  .thick-separator {
    border-left: 2px solid #4a90e2;
    height: 24px;
    margin: 0 10px;
  }
  .opacity-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-left: 20px;
    color: white;
  }

  .opacity-controls input {
    width: 60px;
    padding: 4px;
    border-radius: 4px;
    border: 1px solid #4a90e2;
    background: #16213e;
    color: white;
  }

  .opacity-controls button {
    background: #16213e;
    border: 1px solid #4a90e2;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
  }

  .opacity-controls button:hover {
    background: #4a90e2;
  }

  #customAlertModal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }

  .alert-content {
    background: #0f3460;
    padding: 20px;
    border-radius: 8px;
    min-width: 300px;
    border: 2px solid #4a90e2;
  }

  #customAlertMessage {
    color: white;
    text-align: center;
  }

  #floating-text-menu {
    position: absolute;
    background: #0f3460;
    padding: 15px;
    border-radius: 8px;
    color: white;
    width: 200px;
    height: 210px;
    display: none;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    z-index: 1000;
    font-size: 12px;
  }

  .menu-group {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 15px;
  }

  .menu-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .menu-row label {
    min-width: 70px;
  }

  .menu-row select,
  .menu-row input {
    flex: 1;
    padding: 4px;
    border-radius: 4px;
    border: 1px solid #4a90e2;
    background: #16213e;
    color: white;
    font-size: 12px;
    width: calc(100% - 30px);
  }

  .outline-row {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin-bottom: 10px;
  }

  .outline-row span {
    color: white;
    font-size: 12px;
  }

  .outline-row input[type="number"] {
    width: 40px;
    padding: 4px;
    border-radius: 4px;
    border: 1px solid #4a90e2;
    background: #16213e;
    color: white;
  }

  .outline-row input[type="color"] {
    width: 30px;
    padding: 0;
    border: 1px solid #4a90e2;
    background: #16213e;
  }
  .menu-row input[type="checkbox"] {
	  margin-left: 10px;
	}

  .menu-row input[type="color"] {
	  margin-left: 10px;
	}

  /* Modal Styles */
  #docSizeModal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }

	.doc-size-content {
	  background: #0f3460;
	  padding: 20px;
	  border-radius: 8px;
	  width: 500px;
	  height: auto;
	  border: 2px solid #4a90e2;
	  display: flex;
	  flex-direction: column;
	  justify-content: space-between;
	}

	.doc-size-header {
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  margin-bottom: 20px;
	}

	.doc-size-header h2 {
	  color: white;
	  margin: 0;
	}

	.doc-size-header button {
	  background: none;
	  border: none;
	  color: white;
	  font-size: 20px;
	  cursor: pointer;
	}

	.doc-size-body {
	  display: flex;
	  flex-direction: column;
	  gap: 20px;
	}

	.size-row {
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  gap: 10px;
	}

	.size-row span {
	  font-size: 1.5rem;
	  color: white;
	}

	.size-row input {
	  width: 60px;
	  text-align: center;
	}

	.doc-size-buttons {
	  display: flex;
	  justify-content: space-between;
	  gap: 10px;
	}

	.doc-size-buttons button {
	  background: #4a90e2;
	  color: white;
	  border: none;
	  padding: 10px;
	  border-radius: 4px;
	  cursor: pointer;
	  flex: 1;
	}

	.doc-size-buttons button:hover {
	  background: #3a70b2;
	}

	.doc-size-buttons button:not(:last-child) {
	  margin-right: 10px;
	}
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
}

.modal-content {
    background: #0f3460;
    border-radius: 8px;
    width: 90%;
    height: 90%;
    display: flex;
    flex-direction: column;
    border: 2px solid #4a90e2;
}

.modal-body {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}

.modal-footer {
    padding: 10px;
    display: flex;
    justify-content: center;
    gap: 10px;
}

.crop-btn {
    background: #16213e;
    border: 1px solid #4a90e2;
    color: white;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

.crop-btn:hover {
    background: #4a90e2;
}	
.remove-color-btn {
    background-color: #0f3460;
    border: 2px solid #4a90e2;
    color: white;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.3s, color 0.3s;
    margin: 0 5px;
}
.remove-color-btn:hover {
    background-color: #4a90e2;
    color: white;
}

.remove-color-btn.active {
    background-color: #4a90e2;
    color: white;
    border-color: #4a90e2;
}
#sensitivityRange {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 8px;
    background: #16213e;
    outline: none;
    border: 2px solid #4a90e2;
    border-radius: 10px;
    margin: 10px 0;
    transition: opacity 0.2s;
}

#sensitivityRange:hover {
    opacity: 0.8;
}

#sensitivityRange::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: #4a90e2;
    border-radius: 50%;
    cursor: pointer;
    transition: background 0.3s;
}

#sensitivityRange::-webkit-slider-thumb:hover {
    background: #3a70b2;
}

#sensitivityRange::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: #4a90e2;
    border-radius: 50%;
    cursor: pointer;
    transition: background 0.3s;
}

#sensitivityRange::-moz-range-thumb:hover {
    background: #3a70b2;
}
#paintingCanvas {
    max-width: 100%;
    max-height: 100%;
    border: 1px solid #ccc;
}
/* Estilo dos botões do modal */
.modal-btn {
    background-color: #0f3460;
    color: #fff;
    border: 2px solid #4a90e2;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.3s, color 0.3s;
    margin: 0 5px;
}

.modal-btn:hover {
    background-color: #4a90e2;
    color: white;
}

.modal-btn.active {
    background-color: #4a90e2;
    color: white;
    border-color: #4a90e2;
}

/* Estilo do slider */
.modal-footer input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100px;
    height: 8px;
    background: #16213e;
    outline: none;
    border: 2px solid #4a90e2;
    border-radius: 10px;
    margin: 0 10px;
    transition: opacity 0.2s;
}

.modal-footer input[type="range"]:hover {
    opacity: 0.8;
}

.modal-footer input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: #4a90e2;
    border-radius: 50%;
    cursor: pointer;
    transition: background 0.3s;
}

.modal-footer input[type="range"]::-webkit-slider-thumb:hover {
    background: #3a70b2;
}

.modal-footer input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: #4a90e2;
    border-radius: 50%;
    cursor: pointer;
    transition: background 0.3s;
}

.modal-footer input[type="range"]::-moz-range-thumb:hover {
    background: #3a70b2;
}
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
}

.modal-content {
    background: #0f3460;
    border-radius: 8px;
    width: 90%;
    max-width: 800px;
    display: flex;
    flex-direction: column;
    border: 2px solid #4a90e2;
}

.modal-body {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow: hidden;
}

.slider-container {
    display: flex;
    align-items: center;
    gap: 10px;
    flex: 1;
}
.slider-container input[type="range"] {
    flex: 1;
}
.slider-container input[type="color"] {
    width: 30px;
    height: 30px;
    padding: 0;
}

.slider-value {
    min-width: 50px;
}
.export-item {
    position: relative;
}

resolution-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
    color: white;
}

.resolution-controls input {
    width: 80px;
    padding: 4px;
    border-radius: 4px;
    border: 1px solid #4a90e2;
    background: #16213e;
    color: white;
}

#layersList li.drop-above {
  border-top: 2px solid #4a90e2;
}

#layersList li.drop-below {
  border-bottom: 2px solid #4a90e2;
}

#layersList li.dragging {
  opacity: 0.5;
}
/* Estilo do Modal */
#dynamicModal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    flex-direction: column;
    z-index: 10000;
}

#dynamicModal .modal-header {
    height: 40px;
    background: #0f3460;
    display: flex;
    justify-content: flex-end;
    align-items: center;
    padding: 0 10px;
}

#dynamicModal .modal-btn {
    background: #4a90e2;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

#dynamicModal .modal-btn:hover {
    background: #357abd;
}

#dynamicIframe {
    flex: 1;
    background: white;
}
</style>
</head>
<body>
<div id="customAlertModal" style="display: none;">
  <div class="alert-content">
    <div id="customAlertMessage"></div>
  </div>
</div>
<div id="top-menu">
 <div class="menu-item">
    Arquivo
    <div class="dropdown">
        <a href="javascript:void(0)" id="openDocumentBtn">Abrir Documento</a>
        <a href="javascript:void(0)" id="saveDocumentBtn">Salvar Documento</a>
        <a href="javascript:void(0)" class="document-size-item" id="docSizeBtn">
            Tamanho do Documento
        </a>
        <div class="separator"></div>
		<div class="resolution-controls">
			<label for="resolutionInput">Resolução (DPI):</label>
			<input type="number" id="resolutionInput" value="150" min="72" max="600" step="1">
		</div>
        <a href="javascript:void(0)" id="exportPNGBtn">Exportar como PNG</a>
        <a href="javascript:void(0)" id="exportJPGBtn">Exportar como JPG</a>
        <a href="javascript:void(0)" id="exportPDFBtn">Exportar como PDF</a>
    </div>
</div>
  <div class="menu-item">
    Editar
    <div class="dropdown">
    <a href="javascript:void(0)" id="copyBtn">Copiar</a>
    <a href="javascript:void(0)" id="pasteBtn">Colar</a>
</div>
  </div>
  <div class="menu-item">
    Imagem
    <div class="dropdown">
    <a href="javascript:void(0)" id="rotateBtn">Girar<input type="number" id="rotateInput" value="90" min="0" max="360" step="90"></a>
    <a href="javascript:void(0)" id="duplicateBtn">Duplicar<input type="number" id="duplicateInput" value="1" min="1" step="1"></a>
    <a href="javascript:void(0)" id="organizeBtn">Organizar<input type="number" id="organizeInput" value="0.1" min="0.1" step="0.1"></a>
    <a href="javascript:void(0)" id="alignVerticalBtn">Alinhar Verticalmente</a>
    <a href="javascript:void(0)" id="alignHorizontalBtn">Alinhar Horizontalmente</a>
    <a href="javascript:void(0)" id="flipVerticalBtn">Espelhar Verticalmente</a>
    <a href="javascript:void(0)" id="flipHorizontalBtn">Espelhar Horizontalmente</a>
</div>
  </div>
  <div class="menu-item">
    Texto
    <div class="dropdown">
      <a href="javascript:void(0)">Adicionar Texto</a>
      <a href="javascript:void(0)">Rasterizar Texto</a>
      <a href="javascript:void(0)">Converter em Forma</a>
      <a href="javascript:void(0)">Adicionar Fonte</a>
    </div>
  </div>
  <div class="menu-item">
    Filtro
    <div class="dropdown">
      <a href="javascript:void(0)">Desfoque</a>
      <a href="javascript:void(0)">Nitidez</a>
    </div>
  </div>
  <div class="menu-item">
    Guias
    <div class="dropdown">
      <a href="javascript:void(0)">Adicionar Guias Padr&#xe3;o</a>
      <a href="javascript:void(0)" class="guides-item">
        Adicionar Guia
        <div class="guides-controls">
          <div class="guide-options">
            <button class="guide-btn selected">Horizontal</button>
            <button class="guide-btn">Vertical</button>
          </div>
          <div class="guide-options">
            <button class="guide-btn selected">Uma Guia</button>
            <button class="guide-btn">V&#xe1;rias Guias</button>
          </div>
          <div class="guide-position">
            <span>Posi&#xe7;&#xe3;o (cm)</span>
            <input type="number" value="1" step="0.1" min="0">
          </div>
        </div>
      </a>
      <a href="javascript:void(0)">Apagar Guias</a>
    </div>
  </div>
  <div class="menu-item">
    Ferramentas
    <div class="dropdown">
        <a href="javascript:void(0)" id="calendarBtn">Calendário</a>
    </div>
</div>
  
  <div class="thick-separator"></div>
  <div class="size-controls">
    <span>↔</span>
    <input type="number" id="width-input" step="0.1" min="0">
    <button id="swap-dims">⇅</button>
    <span>↕</span>
    <input type="number" id="height-input" step="0.1" min="0">
    <button id="lock-ratio">🔓</button>
  </div>
  <div class="thick-separator"></div>
  <div class="opacity-controls" id="opacity-controls" style="display: none;">
    <span>Opacidade:</span>
    <input type="number" id="opacity-input" min="0" max="100" value="100">
	<button id="addContorno">Adicionar Contorno</button>
    <button id="export-png-btn">Exportar em PNG</button>
  </div>
  <div class="menu-item" style="margin-left: auto;">
        <button id="infoButton" style="background-color: yellow; color: black; border: none; padding: 8px 16px; border-radius: 4px; cursor: default;">
            CloudPhoto - Alfa - 03/Jan/23
        </button>
    </div>
</div>

<div id="left-menu">
  <button class="tool-button" id="loadImageBtn">
    <i class="fa-regular fa-image"></i>
    Importar Imagem
  </button>
  <button class="tool-button selected" id="moveBtn">
    <i class="fa-solid fa-up-down-left-right"></i>
    Mover
  </button>
  <div class="separator"></div>
  <button class="tool-button" id="textoBtn">
    <i class="fa-solid fa-font"></i>
    Texto
  </button>
  <button id="btnPincel" class="tool-button">
    <i class="fa-solid fa-palette"></i>
    Pincel
  </button>
  <button id="btnBalde" class="tool-button">
    <i class="fa-solid fa-palette"></i>
   Balde
  </button>
  <button id="btnBorracha" class="tool-button">
    <i class="fa-solid fa-eraser"></i>
    Borracha
  </button>
  <button id="removeColorBtn"  class="tool-button">
    <i class="fa-solid fa-wand-magic-sparkles"></i>
    Remover
  </button>
  <button id="cropImageBtn"  class="tool-button">
    <i class="fa-solid fa-scissors"></i>
    Recortar
  </button>
  <button id="extractRegionsBtn" class="tool-button">
    <i class="fa-solid fa-icons"></i>
    Extrair
  </button>
  <button id="vectorizePBBtn" class="tool-button">
    <i class="fa-solid fa-bezier-curve"></i>
    Vetor PB
</button>

  <input type="file" id="fileInput" accept="image/*" multiple>
  <input type="file" id="loadDocInput" accept=".cloudapp" style="display: none;">
</div>
<div id="canvas-container">
  <canvas id="canvas"></canvas>
</div>
<div id="right-menu">
  <ul id="layersList"></ul>
  <div class="layers-buttons">
    <button class="layer-btn" id="newLayerBtn">
      <i class="fa-solid fa-plus"></i>
    </button>
    <button class="layer-btn" id="deleteLayerBtn">
      <i class="fa-solid fa-trash"></i>
    </button>
    <button class="layer-btn" id="centerLayerBtn">
      <i class="fa-solid fa-arrows-to-circle"></i>
    </button>
  </div>
</div>
<div id="floating-text-menu">
  <div class="menu-group">
    <div class="menu-row">
      <label>Fonte:</label>
      <select id="font-family">
        <option value="Arial" style="font-family: Arial;">Arial</option>
                      <option value="Arial Black" style="font-family: 'Arial Black';">Arial Black</option>
                      <option value="Brush Script MT" style="font-family: 'Brush Script MT';">Brush Script MT</option>
                      <option value="Bookman Old Style" style="font-family: 'Bookman Old Style';">Bookman Old Style</option>
                      <option value="Comic Sans MS" style="font-family: 'Comic Sans MS';">Comic Sans MS</option>
                      <option value="Courier" style="font-family: Courier;">Courier</option>
                      <option value="Dancing Script" style="font-family: 'Dancing Script';">Dancing Script</option>
                      <option value="Impact" style="font-family: Impact;">Impact</option>
                      <option value="Lucida Handwriting" style="font-family: 'Lucida Handwriting';">Lucida Handwriting</option>
                      <option value="Lucida Sans Unicode" style="font-family: 'Lucida Sans Unicode';">Lucida Sans Unicode</option>
                      <option value="Papyrus" style="font-family: Papyrus;">Papyrus</option>
                      <option value="Segoe Print" style="font-family: 'Segoe Print';">Segoe Print</option>
                      <option value="Segoe Script" style="font-family: 'Segoe Script';">Segoe Script</option>
                      <option value="Segoe UI" style="font-family: 'Segoe UI';">Segoe UI</option>
                      <option value="Times New Roman" style="font-family: 'Times New Roman';">Times New Roman</option>
                      <option value="Trebuchet MS" style="font-family: 'Trebuchet MS';">Trebuchet MS</option>
                      <option value="Verdana" style="font-family: Verdana;">Verdana</option>
                      <option value="Monotype Corsiva" style="font-family: 'Monotype Corsiva';">Monotype Corsiva</option>
                      <option value="Mistral" style="font-family: Mistral;">Mistral</option>
                      <option value="Freestyle Script" style="font-family: 'Freestyle Script';">Freestyle Script</option>
                      <option value="Bradley Hand ITC" style="font-family: 'Bradley Hand ITC';">Bradley Hand ITC</option>
                      <option value="Edwardian Script ITC" style="font-family: 'Edwardian Script ITC';">Edwardian Script ITC</option>
                      <option value="Vivaldi" style="font-family: Vivaldi;">Vivaldi</option>
                      <option value="Rage Italic" style="font-family: 'Rage Italic';">Rage Italic</option>
                    </select>
    </div>
    <div class="menu-row">
      <label>Tamanho:</label>
      <input type="number" id="font-size" min="1" value="20">
    </div>
    <div class="menu-row">
      <label>Cor:</label>
      <input type="color" id="font-color" value="#000000">
    </div>
	<div class="menu-row">
	  <label>Seg. Cor:</label>
	  <input type="checkbox" id="gradient-checkbox">
	  <input type="color" id="gradient-color" value="#000000">
	</div>
    <div class="menu-row">
      <label>Alinhamento:</label>
      <select id="text-align">
        <option value="left">Esquerda</option>
        <option value="center">Centro</option>
        <option value="right">Direita</option>
      </select>
    </div>
    <div class="outline-row">
	  <span>Contorno:</span>
	  <input type="checkbox" id="second-color-check" unchecked>
	  <input type="number" class="outline-size" value="0" min="0" max="20" step="0.1">
	  <input type="color" class="outline-color" value="#000000">
	</div>
  </div>
</div>
<div id="docSizeModal" style="display: none;">
  <div class="doc-size-content">
    <div class="doc-size-header">
      <h2>Tamanho do Documento</h2>
      <button id="closeDocSizeModal">&times;</button>
    </div>
    <div class="doc-size-body">
      <div class="doc-size-controls">
        <div class="size-row">
          <span>↔</span>
          <input type="number" id="doc-width-input" step="0.1" min="0" value="21">
          <button id="doc-swap-dims">⇅</button>
          <span>↕</span>
          <input type="number" id="doc-height-input" step="0.1" min="0" value="29.7">
          <button id="doc-lock-ratio">🔓</button>
        </div>
      </div>
      <div class="doc-size-buttons">
        <button id="setA4Vertical">A4 Vertical</button>
        <button id="setA4Horizontal">A4 Horizontal</button>
        <button id="closeDocSizeModalBtn">Fechar</button>
        <button id="doc-size-ok">Salvar</button>
      </div>
    </div>
  </div>
</div>
<div id="removeColorModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <div class="modal-body">
            <canvas id="removeColorCanvas"></canvas>
        </div>
       <div class="modal-footer">
			<button id="removeRegionBtn" class="remove-color-btn">Remover Região Clicada</button>
			<button id="removeTotalBtn" class="remove-color-btn">Remover Cor Total</button>
			<input type="range" id="sensitivityRange" min="0" max="100" value="30">
			<button id="undoRemoveColor" class="remove-color-btn">Voltar</button>
			<div style="flex: 1;"></div>
			<button id="closeRemoveColorModal" class="remove-color-btn">Fechar</button>
			<button id="saveRemoveColor" class="remove-color-btn">Salvar</button>
		</div>
    </div>
</div>
<div id="cropperModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-body">
                <div class="crop-container">
                    <img id="cropperImage" src="">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel-btn" id="cancelCropBtn">Cancelar</button>
                <button class="save-btn" id="saveCropBtn">Salvar</button>
            </div>
        </div>
    </div>
	<div id="cropModal" class="modal-overlay" style="display: none;">
		<div class="modal-content">
			<div class="modal-body">
				<img id="cropImage" src="" alt="Imagem para recorte" style="max-width: 100%; max-height: 100%;">
			</div>
			<div class="modal-footer">
				<button id="closeCropModal" class="crop-btn">Fechar</button>
				<button id="saveCrop" class="crop-btn">Salvar</button>
			</div>
		</div>
	</div>
	<div id="paintingModal" class="modal-overlay" style="display: none;">
		<div class="modal-content">
			<div class="modal-body">
				<canvas id="paintingCanvas"></canvas>
			</div>
			<div class="modal-footer">
				<button id="closePaintingModal" class="modal-btn">Fechar</button>
				<button id="savePaintingModal" class="modal-btn">Salvar</button>
				<button id="undoPaintingModal" class="modal-btn">Voltar</button>
			</div>
		</div>
	</div>
	
<div id="outlineModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <div class="modal-body">
            <div class="image-container">
                <div class="image-wrapper">
                    <img id="outlineImagePreview" class="image-preview">
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <div class="slider-container">
                <input type="range" id="outlineSlider1" min="0" max="20" value="0">
                <span class="slider-value" id="sliderValue1">0px</span>
                <input type="color" id="colorPicker1" value="#000000">
            </div>
            <div class="slider-container">
                <input type="range" id="outlineSlider2" min="0" max="20" value="0">
                <span class="slider-value" id="sliderValue2">0px</span>
                <input type="color" id="colorPicker2" value="#ff0000">
            </div>
            <button id="applyOutlineBtn" class="modal-btn">Aplicar Contorno</button>
            <button id="closeOutlineModal" class="modal-btn">Fechar</button>
        </div>
    </div>
</div>

<div id="dynamicModal" class="modal-overlay" style="display: none;">
    <div class="modal-header">
        <button id="closeDynamicModal" class="modal-btn">Fechar</button>
    </div>
    <iframe id="dynamicIframe" src="" style="width: 100%; height: calc(100% - 40px); border: none;"></iframe>
</div>
	
<script>
//--------------------------------- Seção Variáveis Globais ---------------------------------

const DPI = 96;
const CM_TO_PX = DPI / 2.54;
const container = document.getElementById('canvas-container');
const canvas = new fabric.Canvas('canvas', {
  preserveObjectStacking: true,
  selection: true
});
let canvasState = {
  undoStack: [],
  redoStack: [],
  maxStates: 20,
  isUndoOrRedoing: false,
  isInitialized: false,
  background: null,
  hasFirstObject: false
};
let isRatioLocked = false;
let aspectRatio = 1;
const widthInput = document.getElementById('width-input');
const heightInput = document.getElementById('height-input');
const lockRatioBtn = document.getElementById('lock-ratio');
const swapDimsBtn = document.getElementById('swap-dims');
const docSizeOkBtn = document.getElementById('doc-size-ok');
let docIsRatioLocked = false;
const docWidthInput = document.getElementById('doc-width-input');
const docHeightInput = document.getElementById('doc-height-input');
const docLockRatioBtn = document.getElementById('doc-lock-ratio');
const docSwapDimsBtn = document.getElementById('doc-swap-dims');
let docAspectRatio = 21 / 29.7;
let draggedItem = null;
let floatingMenu = document.getElementById('floating-text-menu');

//Remover cor parametros
let removeColorHistory = [];
let currentRemoveColorIndex = -1;
let currentRemoveMode = 'region';
let removeColorCtx = null;
let removeColorHistoryIndex = -1;

//--------------------------------- Seção Canva e Dimensoes Shape Folha ---------------------------------

function convertDimensions(value, fromUnit, toUnit) {
  if (fromUnit === 'px' && toUnit === 'cm') {
    return value / CM_TO_PX;
  } else if (fromUnit === 'cm' && toUnit === 'px') {
    return value * CM_TO_PX;
  }
  return value;
}

function calculateProperScale(object, desiredWidthCm, desiredHeightCm) {
  const desiredWidthPx = convertDimensions(desiredWidthCm, 'cm', 'px');
  const desiredHeightPx = convertDimensions(desiredHeightCm, 'cm', 'px');

  return {
    scaleX: desiredWidthPx / object.width,
    scaleY: desiredHeightPx / object.height
  };
}

function constrainToA4(object) {
  const a4Width = 21 * CM_TO_PX;
  const a4Height = 29.7 * CM_TO_PX;
  const a4Page = canvas.getObjects().find(obj => obj.id === 'CloudFolha');

  if (!a4Page) return;

  const objectWidth = object.width * object.scaleX;
  const objectHeight = object.height * object.scaleY;

  if (objectWidth > a4Width || objectHeight > a4Height) {
  }
}

function updatePageDimensions() {
  const width = 21 * CM_TO_PX;
  const height = 29.7 * CM_TO_PX;

  const existingFolha = canvas.getObjects().filter(obj => obj.id === 'CloudFolha');
  existingFolha.forEach(obj => canvas.remove(obj));

  const a4Page = new fabric.Rect({
    id: 'CloudFolha',
    left: (canvas.width - width) / 2,
    top: (canvas.height - height) / 2,
    width: width,
    height: height,
    fill: 'white',
    selectable: false,
    evented: false,
    excludeFromExport: true
  });

  canvas.add(a4Page);
  canvas.sendToBack(a4Page);
  canvas.renderAll();
}

function createCloudFolha() {
    const width = 21 * CM_TO_PX;
    const height = 29.7 * CM_TO_PX;

    const cloudFolha = new fabric.Rect({
        id: 'CloudFolha',
        left: (canvas.width - width) / 2,
        top: (canvas.height - height) / 2,
        width: width,
        height: height,
        fill: 'white',
        selectable: false,
        evented: false,
        excludeFromExport: true
    });

    canvas.add(cloudFolha);
    canvas.sendToBack(cloudFolha);
    canvas.renderAll();

    const widthCm = convertDimensions(width, 'px', 'cm');
    const heightCm = convertDimensions(height, 'px', 'cm');
    widthInput.value = widthCm.toFixed(1);
    heightInput.value = heightCm.toFixed(1);
}

window.addEventListener('load', function () {
    createCloudFolha();
    resizeCanvas();
});

function resizeCanvas() {
    const containerWidth = container.offsetWidth;
    const containerHeight = container.offsetHeight;

    canvas.setWidth(containerWidth);
    canvas.setHeight(containerHeight);

    const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
    if (!cloudFolha) return;

    const scaleX = (containerWidth * 0.8) / cloudFolha.width;
    const scaleY = (containerHeight * 0.8) / cloudFolha.height;
    const zoom = Math.min(scaleX, scaleY);

    const objectPositions = [];
    canvas.getObjects().forEach(obj => {
        if (obj.id !== 'CloudFolha') {
            objectPositions.push({
                object: obj,
                relativeLeft: (obj.left - cloudFolha.left) / cloudFolha.width,
                relativeTop: (obj.top - cloudFolha.top) / cloudFolha.height,
                originalScaleX: obj.scaleX,
                originalScaleY: obj.scaleY
            });
        }
    });

    canvas.setZoom(zoom);

    const centerX = (containerWidth / zoom - cloudFolha.width) / 2;
    const centerY = (containerHeight / zoom - cloudFolha.height) / 2;

    cloudFolha.set({
        left: centerX,
        top: centerY
    });

    objectPositions.forEach(pos => {
        const obj = pos.object;
        obj.set({
            left: centerX + (pos.relativeLeft * cloudFolha.width),
            top: centerY + (pos.relativeTop * cloudFolha.height),
            scaleX: pos.originalScaleX,
            scaleY: pos.originalScaleY
        });
    });

    canvas.renderAll();
}


window.addEventListener('resize', () => {
  resizeCanvas(); 
  updateTextPositions(); 
});

function updateTextPositions() {
  const objects = canvas.getObjects();
  const zoom = canvas.getZoom();
  const a4Page = canvas.getObjects().find(obj => obj.id === 'CloudFolha');

  if (a4Page) {
    objects.forEach(obj => {
      if (obj.type === 'i-text' && obj.id !== 'CloudFolha') {
        const relativeLeft = (obj.left - a4Page.left) / a4Page.width;
        const relativeTop = (obj.top - a4Page.top) / a4Page.height;

        obj.set({
          left: a4Page.left + (relativeLeft * a4Page.width),
          top: a4Page.top + (relativeTop * a4Page.height)
        });
      }
    });
  }

  canvas.renderAll();
}
//--------------------------------- Seção Eventos ---------------------------------

// Consolidated Event Handlers
canvas.on({
  'selection:created': function () {
    updateSizeInputs();
    updateOpacityControls();

    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type === 'i-text') {
      updateFloatingTextMenu();
    } else {
      document.getElementById('floating-text-menu').style.display = 'none';
    }
  },

  'selection:updated': function () {
    updateSizeInputs();
    updateOpacityControls();

    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type === 'i-text') {
      updateFloatingTextMenu();
    } else {
      document.getElementById('floating-text-menu').style.display = 'none';
    }
  },

  'selection:cleared': function () {
    updateOpacityControls();

    const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
    if (cloudFolha) {
      const widthCm = convertDimensions(cloudFolha.width, 'px', 'cm');
      const heightCm = convertDimensions(cloudFolha.height, 'px', 'cm');
      widthInput.value = widthCm.toFixed(1);
      heightInput.value = heightCm.toFixed(1);
    }

    document.getElementById('floating-text-menu').style.display = 'none';
  },

  'object:added': updateSizeInputs,
  'object:removed': updateSizeInputs,
  'object:modified': function () {
    updateSizeInputs();

    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type === 'i-text') {
      updateFloatingTextMenu();
    }
  },

  'object:moving': function () {
    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type === 'i-text') {
      updateFloatingTextMenu();
    }
  },

  'object:scaling': function () {
    updateSizeInputs();

    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type === 'i-text') {
      updateFloatingTextMenu();
    }
  }
});


canvas.on('mouse:wheel', function (opt) {
  const delta = opt.e.deltaY;
  let zoom = canvas.getZoom();
  zoom = delta > 0 ? zoom / 1.1 : zoom * 1.1;
  zoom = Math.min(Math.max(0.01, zoom), 20);
  canvas.zoomToPoint({
    x: opt.e.offsetX,
    y: opt.e.offsetY
  }, zoom);
  opt.e.preventDefault();
  opt.e.stopPropagation();
});

canvas.on('object:modified', function (e) {
  const obj = e.target;
  if (obj && (obj.type === 'i-text' || obj.type === 'text')) {
    if (obj.fill && typeof obj.fill === 'object') {
      try {
        if (obj.fill.type === 'linear' || obj.fill.type === 'radial') {
          const gradientObj = new fabric.Gradient(obj.fill);
          obj.set('fill', gradientObj);
        } else if (obj.fill.r !== undefined && obj.fill.g !== undefined && obj.fill.b !== undefined) {
          const hexColor = rgbToHex(obj.fill.r, obj.fill.g, obj.fill.b);
          obj.set('fill', hexColor);
        } else {
          obj.set('fill', '#000000');
        }
      } catch (error) {
        console.warn('Erro ao atualizar gradiente ou cor:', error);
        obj.set('fill', '#000000');
      }
    }
  }
  updateLayersList();
});

canvas.on('text:changed', updateLayersList);

canvas.on('object:added', updateLayersList);
canvas.on('object:removed', updateLayersList);

canvas.on('object:scaling', function(e) {
  const object = e.target;
  if (!object || object.id === 'CloudFolha') return;

  constrainToA4(object);

  if (object.type === 'i-text') {
    const scaledWidth = object.width * object.scaleX;
    const scaledHeight = object.height * object.scaleY;

    const widthCm = convertDimensions(scaledWidth, 'px', 'cm');
    const heightCm = convertDimensions(scaledHeight, 'px', 'cm');
    widthInput.value = widthCm.toFixed(1);
    heightInput.value = heightCm.toFixed(1);

    const originalFontSize = object.get('fontSize');
    const newFontSize = Math.round(originalFontSize * object.scaleX);

    const fontSizeInput = document.getElementById('font-size');
    if (fontSizeInput) {
      fontSizeInput.value = newFontSize;
    }

    object.set({
      fontSize: newFontSize,
      scaleX: 1,
      scaleY: 1
    });
  } else {
    updateSizeInputs();
  }

  canvas.renderAll();
});


//--------------------------------- Seção Alerta Personalizado ---------------------------------

function showCustomAlert(message) {
  const modal = document.getElementById('customAlertModal');
  const messageElement = document.getElementById('customAlertMessage');
  messageElement.textContent = message;
  modal.style.display = 'flex';
}

function closeCustomAlert() {
  const modal = document.getElementById('customAlertModal');
  modal.style.display = 'none';
}

document.getElementById('customAlertModal').addEventListener('click', function (e) {
  if (e.target === this) {
    closeCustomAlert();
  }
});

//--------------------------------- Seção dimensões da imagem ---------------------------------

function updateSizeInputs() {
  const activeObject = canvas.getActiveObject();
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');

  if (!activeObject && cloudFolha) {
    const widthCm = convertDimensions(cloudFolha.width, 'px', 'cm');
    const heightCm = convertDimensions(cloudFolha.height, 'px', 'cm');
    widthInput.value = widthCm.toFixed(1);
    heightInput.value = heightCm.toFixed(1);
  } else if (activeObject && activeObject.id !== 'CloudFolha') {
    if (activeObject.type === 'i-text') {
      const scaledWidth = activeObject.width * activeObject.scaleX;
      const scaledHeight = activeObject.height * activeObject.scaleY;
      const widthCm = convertDimensions(scaledWidth, 'px', 'cm');
      const heightCm = convertDimensions(scaledHeight, 'px', 'cm');

      widthInput.value = widthCm.toFixed(1);
      heightInput.value = heightCm.toFixed(1);

      const fontSizeInput = document.getElementById('font-size');
      if (fontSizeInput) {
        fontSizeInput.value = Math.round(activeObject.fontSize);
      }
    } else {
      const widthCm = convertDimensions(activeObject.width * activeObject.scaleX, 'px', 'cm');
      const heightCm = convertDimensions(activeObject.height * activeObject.scaleY, 'px', 'cm');
      widthInput.value = widthCm.toFixed(1);
      heightInput.value = heightCm.toFixed(1);
    }
  } else {
    widthInput.value = '';
    heightInput.value = '';
  }
}

widthInput.addEventListener('change', () => {
  const activeObject = canvas.getActiveObject();
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');

  if (!activeObject && cloudFolha) {
    const newWidthCm = parseFloat(widthInput.value);
    const newWidthPx = convertDimensions(newWidthCm, 'cm', 'px');
    cloudFolha.set('width', newWidthPx);
    canvas.renderAll();
  } else if (activeObject && activeObject.id !== 'CloudFolha') {
    updateObjectSize(widthInput, 'width');
  }
});

heightInput.addEventListener('change', () => {
  const activeObject = canvas.getActiveObject();
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');

  if (!activeObject && cloudFolha) {
    const newHeightCm = parseFloat(heightInput.value);
    const newHeightPx = convertDimensions(newHeightCm, 'cm', 'px');
    cloudFolha.set('height', newHeightPx);
    canvas.renderAll();
  } else if (activeObject && activeObject.id !== 'CloudFolha') {
    updateObjectSize(heightInput, 'height');
  }
});

function updateObjectSize(input, dimension) {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.id === 'CloudFolha') return;

  const newValueCm = parseFloat(input.value);
  const newValuePx = convertDimensions(newValueCm, 'cm', 'px');

  if (activeObject.type === 'i-text') {
    const currentWidth = activeObject.width * activeObject.scaleX;
    const currentHeight = activeObject.height * activeObject.scaleY;

    if (dimension === 'width') {
      const scale = newValuePx / currentWidth;
      const newFontSize = Math.round(activeObject.fontSize * scale);

      activeObject.set({
        fontSize: newFontSize,
        scaleX: 1,
        scaleY: 1
      });

      if (isRatioLocked) {
        const heightScale = scale;
        const newHeightFontSize = Math.round(activeObject.fontSize * heightScale);
        activeObject.set({
          fontSize: newHeightFontSize,
          scaleY: 1
        });
        const newHeight = convertDimensions(activeObject.height, 'px', 'cm');
        heightInput.value = newHeight.toFixed(1);
      }

      document.getElementById('font-size').value = newFontSize;
    } else {
      const scale = newValuePx / currentHeight;
      const newFontSize = Math.round(activeObject.fontSize * scale);

      activeObject.set({
        fontSize: newFontSize,
        scaleX: 1,
        scaleY: 1
      });

      if (isRatioLocked) {
        const widthScale = scale;
        const newWidthFontSize = Math.round(activeObject.fontSize * widthScale);
        activeObject.set({
          fontSize: newWidthFontSize,
          scaleX: 1
        });
        const newWidth = convertDimensions(activeObject.width, 'px', 'cm');
        widthInput.value = newWidth.toFixed(1);
      }

      document.getElementById('font-size').value = newFontSize;
    }
  } else {
    let scale;
    if (dimension === 'width') {
      scale = newValuePx / activeObject.width;
      activeObject.set('scaleX', scale);

      if (isRatioLocked) {
        activeObject.set('scaleY', scale);
        const newHeight = convertDimensions(activeObject.height * scale, 'px', 'cm');
        heightInput.value = newHeight.toFixed(1);
      }
    } else {
      scale = newValuePx / activeObject.height;
      activeObject.set('scaleY', scale);

      if (isRatioLocked) {
        activeObject.set('scaleX', scale);
        const newWidth = convertDimensions(activeObject.width * scale, 'px', 'cm');
        widthInput.value = newWidth.toFixed(1);
      }
    }
  }

  constrainToA4(activeObject);
  canvas.renderAll();
}



swapDimsBtn.addEventListener('click', () => {
  const activeObject = canvas.getActiveObject();
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');

  if (activeObject && activeObject.id !== 'CloudFolha') {
    const currentWidth = activeObject.width * activeObject.scaleX;
    const currentHeight = activeObject.height * activeObject.scaleY;
    activeObject.set({
      scaleX: currentHeight / activeObject.width,
      scaleY: currentWidth / activeObject.height
    });
  } else if (cloudFolha) {
    const currentWidth = cloudFolha.width;
    const currentHeight = cloudFolha.height;
    cloudFolha.set({
      width: currentHeight,
      height: currentWidth
    });
  }

  canvas.renderAll();
  updateSizeInputs();
});
widthInput.addEventListener('change', () => updateObjectSize(widthInput, 'width'));
heightInput.addEventListener('change', () => updateObjectSize(heightInput, 'height'));

widthInput.addEventListener('input', () => {
  const activeObject = canvas.getActiveObject();
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');

  if (isRatioLocked) {
    const newWidthCm = parseFloat(widthInput.value);
    const newWidthPx = convertDimensions(newWidthCm, 'cm', 'px');
    const newHeightPx = newWidthPx / aspectRatio;
    const newHeightCm = convertDimensions(newHeightPx, 'px', 'cm');

    if (activeObject && activeObject.id !== 'CloudFolha') {
      activeObject.set('scaleX', newWidthPx / activeObject.width);
      activeObject.set('scaleY', newHeightPx / activeObject.height);
    } else if (cloudFolha) {
      cloudFolha.set('width', newWidthPx);
      cloudFolha.set('height', newHeightPx);
    }

    heightInput.value = newHeightCm.toFixed(1);
  } else {
    if (activeObject && activeObject.id !== 'CloudFolha') {
      updateObjectSize(widthInput, 'width');
    } else if (cloudFolha) {
      const newWidthCm = parseFloat(widthInput.value);
      const newWidthPx = convertDimensions(newWidthCm, 'cm', 'px');
      cloudFolha.set('width', newWidthPx);
    }
  }

  canvas.renderAll();
});

heightInput.addEventListener('input', () => {
  const activeObject = canvas.getActiveObject();
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');

  if (isRatioLocked) {
    const newHeightCm = parseFloat(heightInput.value);
    const newHeightPx = convertDimensions(newHeightCm, 'cm', 'px');
    const newWidthPx = newHeightPx * aspectRatio;
    const newWidthCm = convertDimensions(newWidthPx, 'px', 'cm');

    if (activeObject && activeObject.id !== 'CloudFolha') {
      activeObject.set('scaleY', newHeightPx / activeObject.height);
      activeObject.set('scaleX', newWidthPx / activeObject.width);
    } else if (cloudFolha) {
      cloudFolha.set('height', newHeightPx);
      cloudFolha.set('width', newWidthPx);
    }

    widthInput.value = newWidthCm.toFixed(1);
  } else {
    if (activeObject && activeObject.id !== 'CloudFolha') {
      updateObjectSize(heightInput, 'height');
    } else if (cloudFolha) {
      const newHeightCm = parseFloat(heightInput.value);
      const newHeightPx = convertDimensions(newHeightCm, 'cm', 'px');
      cloudFolha.set('height', newHeightPx);
    }
  }

  canvas.renderAll();
});

function getObjectSizeInCm(object) {
  return {
    width: (object.width * object.scaleX) / CM_TO_PX,
    height: (object.height * object.scaleY) / CM_TO_PX
  };
}

//--------------------------------- Seção Histórico ---------------------------------

function initializeHistory() {
  if (canvasState.isInitialized) return;
  const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
  if (objects.length > 0) {
    const currentState = canvas.toJSON(['id']);
    canvasState.undoStack = [JSON.stringify(currentState)];
    canvasState.isInitialized = true;
    canvasState.hasFirstObject = true;
  }
}

function saveState() {
  if (canvasState.isUndoOrRedoing || !canvasState.hasFirstObject) return;
  if (!canvasState.background) {
    canvasState.background = canvas.backgroundImage;
  }
  const currentState = canvas.toJSON(['id']);
  const state = JSON.stringify(currentState);
  if (canvasState.undoStack.length === 0 || state !== canvasState.undoStack[canvasState.undoStack.length - 1]) {
    canvasState.undoStack.push(state);
    if (canvasState.undoStack.length > canvasState.maxStates) {
      canvasState.undoStack.shift();
    }
    canvasState.redoStack = [];
  }
}

function undo() {
  if (canvasState.undoStack.length > 1) {
    canvasState.isUndoOrRedoing = true;
    const currentState = JSON.stringify(canvas.toJSON(['id']));
    canvasState.redoStack.push(currentState);
    canvasState.undoStack.pop();
    const prevState = JSON.parse(canvasState.undoStack[canvasState.undoStack.length - 1]);
    const pattern = canvas.backgroundImage || canvas.backgroundColor;
    canvas.clear();
    canvas.loadFromJSON(prevState, () => {
      canvas.setBackgroundColor(pattern, canvas.renderAll.bind(canvas));
      canvas.renderAll();
      updateSelectionState();
      let cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
      if (!cloudFolha) {
        const width = 21 * CM_TO_PX;
        const height = 29.7 * CM_TO_PX;
        cloudFolha = new fabric.Rect({
          id: 'CloudFolha',
          left: (canvas.width - width) / 2,
          top: (canvas.height - height) / 2,
          width: width,
          height: height,
          fill: 'white',
          selectable: false,
          evented: false,
          excludeFromExport: true
        });
        canvas.add(cloudFolha);
      }
      cloudFolha.set({
        selectable: false,
        evented: false,
        excludeFromExport: true
      });
      canvas.sendToBack(cloudFolha);
      canvasState.isUndoOrRedoing = false;
    });
  }
}

function redo() {
  if (canvasState.redoStack.length > 0) {
    canvasState.isUndoOrRedoing = true;
    const currentState = JSON.stringify(canvas.toJSON(['id']));
    canvasState.undoStack.push(currentState);
    const nextState = JSON.parse(canvasState.redoStack.pop());
    const pattern = canvas.backgroundImage || canvas.backgroundColor;
    canvas.clear();
    canvas.loadFromJSON(nextState, () => {
      canvas.setBackgroundColor(pattern, canvas.renderAll.bind(canvas));
      canvas.renderAll();
      updateSelectionState();
      let cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
      if (!cloudFolha) {
        const width = 21 * CM_TO_PX;
        const height = 29.7 * CM_TO_PX;
        cloudFolha = new fabric.Rect({
          id: 'CloudFolha',
          left: (canvas.width - width) / 2,
          top: (canvas.height - height) / 2,
          width: width,
          height: height,
          fill: 'white',
          selectable: false,
          evented: false,
          excludeFromExport: true
        });
        canvas.add(cloudFolha);
      }
      cloudFolha.set({
        selectable: false,
        evented: false,
        excludeFromExport: true
      });
      canvas.sendToBack(cloudFolha);
      canvasState.isUndoOrRedoing = false;
    });
  }
}

//--------------------------------- Seção Inicio Tamanho do Documento ---------------------------------

document.getElementById('docSizeBtn').addEventListener('click', () => {
  const modal = document.getElementById('docSizeModal');
  modal.style.display = 'flex';
});

document.getElementById('closeDocSizeModal').addEventListener('click', () => {
  const modal = document.getElementById('docSizeModal');
  modal.style.display = 'none';
});

document.getElementById('closeDocSizeModalBtn').addEventListener('click', () => {
  const modal = document.getElementById('docSizeModal');
  modal.style.display = 'none';
});

document.getElementById('setA4Vertical').addEventListener('click', () => {
  docWidthInput.value = 21;
  docHeightInput.value = 29.7;
});

document.getElementById('setA4Horizontal').addEventListener('click', () => {
  docWidthInput.value = 29.7;
  docHeightInput.value = 21;
});

//--------------------------------- Seção Final Tamanho do Documento ---------------------------------

//--------------------------------- Seção Atalhos ---------------------------------

document.addEventListener('keydown', function (e) {
  if (e.key === 'Delete') {
    const activeObjects = canvas.getActiveObjects();
    if (activeObjects && activeObjects.length) {
      activeObjects.forEach(obj => {
        if (obj.id !== 'CloudFolha') {
          canvas.remove(obj);
        }
      });
      canvas.discardActiveObject();
      canvas.requestRenderAll();
    }
  }
  if (e.ctrlKey && e.key === 'z') {
    e.preventDefault();
    undo();
  }
  if (e.ctrlKey && e.shiftKey && e.key === 'Z' || e.ctrlKey && e.key === 'y') {
    e.preventDefault();
    redo();
  }
  if (e.ctrlKey && e.key === 'v') {
    e.preventDefault();
    navigator.clipboard.read().then(data => {
      data.forEach(item => {
        if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
          item.getType('image/png').then(blob => {
            const reader = new FileReader();
            reader.onload = function (e) {
              fabric.Image.fromURL(e.target.result, function (img) {
                const pageWidth = 21 * CM_TO_PX;
                const pageHeight = 29.7 * CM_TO_PX;
                const scale = Math.min(pageWidth * 0.8 / img.width, pageHeight * 0.8 / img.height);
                img.scale(scale);
                const a4Page = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
                if (a4Page) {
                  img.set({
                    left: a4Page.left + (a4Page.width - img.width * scale) / 2,
                    top: a4Page.top + (a4Page.height - img.height * scale) / 2
                  });
                }
                canvas.add(img);
                canvas.setActiveObject(img);
                canvas.renderAll();
              });
            };
            reader.readAsDataURL(blob);
          });
        }
        if (item.types.includes('text/plain')) {
          item.getType('text/plain').then(blob => {
            blob.text().then(text => {
              const itext = new fabric.IText(text, {
                left: 100,
                top: 100,
                fontFamily: 'Arial',
                fontSize: 20,
                fill: 'black'
              });
              canvas.add(itext);
              canvas.setActiveObject(itext);
              canvas.renderAll();
            });
          });
        }
      });
    });
  }
  if (e.ctrlKey && e.key === 'd') {
    e.preventDefault();
    const activeObjects = canvas.getActiveObjects();
    if (activeObjects && activeObjects.length) {
      const clones = [];
      activeObjects.forEach(obj => {
        if (obj.id !== 'CloudFolha') {
          const clone = fabric.util.object.clone(obj);
          clone.set({
            left: obj.left + 20,
            top: obj.top + 20
          });
          canvas.add(clone);
          clones.push(clone);
        }
      });
      canvas.discardActiveObject();
      if (clones.length > 1) {
        const selection = new fabric.ActiveSelection(clones, {
          canvas
        });
        canvas.setActiveObject(selection);
      } else if (clones.length === 1) {
        canvas.setActiveObject(clones[0]);
      }
      canvas.requestRenderAll();
    }
  }
document.addEventListener('keydown', function (e) {
  if (e.ctrlKey && e.key === 'p') {
    e.preventDefault();

    const a4Page = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
    if (!a4Page) return;

    const tempCanvas = document.createElement('canvas');
    const ctx = tempCanvas.getContext('2d');
    tempCanvas.width = a4Page.width;
    tempCanvas.height = a4Page.height;

    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

    ctx.save(); 
    ctx.beginPath();
    ctx.rect(0, 0, a4Page.width, a4Page.height);
    ctx.clip(); 
    const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
    objects.forEach(obj => {
      const clone = fabric.util.object.clone(obj);

      const objLeft = clone.left - a4Page.left;
      const objTop = clone.top - a4Page.top;

      if (
        objLeft + clone.width * clone.scaleX > 0 &&
        objTop + clone.height * clone.scaleY > 0 &&
        objLeft < a4Page.width &&
        objTop < a4Page.height
      ) {
        clone.set({
          left: objLeft,
          top: objTop
        });

        clone.render(ctx);
      }
    });

    ctx.restore(); 

    const printWindow = window.open('');
    printWindow.document.write(`
      <html>
        <head>
          <title>Imprimir</title>
          <style>
            @media print {
              img { max-width: 100%; height: auto; }
            }
          </style>
        </head>
        <body>
          <img src="${tempCanvas.toDataURL()}" onload="window.print();window.close()">
        </body>
      </html>
    `);
    printWindow.document.close();
  }
});

  if (e.ctrlKey && e.key === 'c') {
    e.preventDefault();
    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type === 'image') {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = activeObject.width * activeObject.scaleX;
      tempCanvas.height = activeObject.height * activeObject.scaleY;
      const tempFabricCanvas = new fabric.Canvas(tempCanvas);
      const clone = fabric.util.object.clone(activeObject);
      clone.left = 0;
      clone.top = 0;
      tempFabricCanvas.add(clone);
      tempFabricCanvas.renderAll();
      tempCanvas.toBlob(blob => {
        const item = new ClipboardItem({
          'image/png': blob
        });
        navigator.clipboard.write([item]).then(() => {
          showCustomAlert('Imagem copiada para área de transferência!');
        });
      });
    }
  }
  if (e.ctrlKey && e.key === 'a') {
    e.preventDefault();
    const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
    if (objects.length > 0) {
      const selection = new fabric.ActiveSelection(objects, {
        canvas
      });
      canvas.setActiveObject(selection);
      canvas.requestRenderAll();
    }
  }
});

// ----------------------------------------- Seção Inicio Texto ---------------------------------

function getLayerName(obj, index) {
    if (obj.type === 'i-text') {
        return obj.text.substring(0, 10) || `Texto ${index + 1}`;
    } else if (obj.type === 'image') {
        return obj.name || obj._element?.currentSrc?.split('/').pop() || `Imagem ${index + 1}`;
    } else {
        return `${obj.type} ${index + 1}`;
    }
}

canvas.on('mouse:down', function (e) {
    if (e.target) {
        canvas.setActiveObject(e.target);
        updateLayersList();
    }
});

document.getElementById('layersList').addEventListener('click', function (e) {
    const target = e.target;
    if (target.tagName === 'LI') {
        const index = parseInt(target.getAttribute('data-index'));
        const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
        const selectedObject = objects[objects.length - 1 - index]; // Inverte a ordem para corresponder à lista

        // Seleciona o objeto no canvas
        canvas.setActiveObject(selectedObject);
        canvas.renderAll();

        // Atualiza o estilo do item selecionado no menu de camadas
        updateLayersList();
    }
});

function updateLayersList() {
    const layersList = document.getElementById('layersList');
    layersList.innerHTML = '';

    const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
    const reversedObjects = objects.reverse();

    reversedObjects.forEach((obj, index) => {
        const layer = document.createElement('li');
        layer.setAttribute('data-index', index);
        layer.textContent = getLayerName(obj, index);

        // Adiciona a classe 'selected' se o objeto estiver selecionado
        if (obj === canvas.getActiveObject()) {
            layer.classList.add('selected');
        }

        layer.draggable = true;

        layer.addEventListener('dragstart', (e) => {
            draggedItem = layer;
            originalIndex = index;
            e.dataTransfer.effectAllowed = 'move';
            layer.classList.add('dragging');
        });

        layer.addEventListener('dragenter', (e) => {
            e.preventDefault();
            if (layer !== draggedItem) {
                const rect = layer.getBoundingClientRect();
                const mouseY = e.clientY;
                const threshold = rect.top + rect.height / 2;

                layer.classList.remove('drop-above', 'drop-below');

                if (mouseY < threshold) {
                    layer.classList.add('drop-above');
                } else {
                    layer.classList.add('drop-below');
                }
            }
        });

        layer.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        });

        layer.addEventListener('dragleave', () => {
            layer.classList.remove('drop-above', 'drop-below');
        });

        layer.addEventListener('drop', handleDropLayer);

        layer.addEventListener('dragend', () => {
            document.querySelectorAll('#layersList li').forEach(item => {
                item.classList.remove('drop-above', 'drop-below', 'dragging');
            });
            draggedItem = null;
            originalIndex = null;
        });

        layersList.appendChild(layer);
    });
}



function handleDropLayer(e) {
    e.preventDefault();
    e.stopPropagation();

    if (!draggedItem) return;

    // Determina a posição do drop
    const rect = e.currentTarget.getBoundingClientRect();
    const mouseY = e.clientY;
    const threshold = rect.top + rect.height / 2;
    const dropAbove = mouseY < threshold;

    const fromIndex = originalIndex; // Índice original do item arrastado
    const toIndex = parseInt(e.currentTarget.getAttribute('data-index')); // Índice do item de destino

    // Filtra o CloudFolha
    const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
    const reversedObjects = objects.reverse(); // Inverte a ordem para corresponder à lista

    const movedObject = reversedObjects[fromIndex];

    // Calcula o índice final baseado na posição do drop
    let finalIndex = dropAbove ? toIndex : toIndex + 1;
    if (fromIndex < toIndex) finalIndex--;

    // Reordena os objetos no canvas
    canvas.remove(movedObject);
    canvas.insertAt(movedObject, objects.length - finalIndex - 1); // Ajusta para a ordem correta

    // Garante que o CloudFolha permaneça no fundo
    const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
    if (cloudFolha) {
        canvas.sendToBack(cloudFolha);
    }

    // Limpa classes e atualiza a lista
    document.querySelectorAll('#layersList li').forEach(item => {
        item.classList.remove('drop-above', 'drop-below');
    });

    updateLayersList();
    saveState();
    draggedItem = null;
    originalIndex = null; // Limpa o índice original
}


// ----------------------------------------- Seção Final Texto ---------------------------------

//--------------------------------- Seção Documento Abrir e Salvar ---------------------------------

document.getElementById('openDocumentBtn').addEventListener('click', function () {
    document.getElementById('loadDocInput').click();
});

document.getElementById('loadDocInput').addEventListener('change', function (e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (event) {
        const canvasState = JSON.parse(event.target.result);
        const cloudFolhaState = canvasState.cloudFolha;

        canvas.clear();

        canvas.loadFromJSON(canvasState, function () {
            let cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');

            if (!cloudFolha) {
                createCloudFolha();
                cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
            }

            if (cloudFolha && cloudFolhaState) {
                cloudFolha.set({
                    width: Number(cloudFolhaState.width) || 21 * CM_TO_PX, 
                    height: Number(cloudFolhaState.height) || 29.7 * CM_TO_PX,
                    left: Number(cloudFolhaState.left) || (canvas.width - cloudFolha.width) / 2,
                    top: Number(cloudFolhaState.top) || (canvas.height - cloudFolha.height) / 2,
                    selectable: false,
                    evented: false
                });
                canvas.sendToBack(cloudFolha);
            }

            if (cloudFolha) {
                const widthCm = convertDimensions(cloudFolha.width, 'px', 'cm');
                const heightCm = convertDimensions(cloudFolha.height, 'px', 'cm');
                widthInput.value = widthCm.toFixed(1);
                heightInput.value = heightCm.toFixed(1);
            }

            canvas.renderAll();
            updateLayersList();
            saveState();
        });
    };
    reader.readAsText(file);
});

document.getElementById('saveDocumentBtn').addEventListener('click', function () {
    const canvasState = canvas.toJSON([
        'id', 'excludeFromExport', 'selectable', 'evented',
        'left', 'top', 'width', 'height', 'scaleX', 'scaleY', 'angle',
        'fill', 'stroke', 'strokeWidth'
    ]);

    const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
    if (cloudFolha) {
        canvasState.cloudFolha = {
            width: cloudFolha.width,
            height: cloudFolha.height,
            left: cloudFolha.left,
            top: cloudFolha.top
        };
    }

    const blob = new Blob([JSON.stringify(canvasState)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'documento.cloudapp';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
});



function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
}

//--------------------------------- Seção Inicio Texto ---------------------------------

const toolButtons = document.querySelectorAll('.tool-button:not(#loadImageBtn)');
let currentTool = 'move';
toolButtons.forEach(button => {
  button.addEventListener('click', function () {
    toolButtons.forEach(btn => btn.classList.remove('selected'));
    this.classList.add('selected');
    currentTool = this.id.replace('Btn', '').toLowerCase();
    if (currentTool === 'move') {
      canvas.selection = true;
      canvas.defaultCursor = 'default';
      canvas.hoverCursor = 'move';
      canvas.getObjects().forEach(obj => {
        if (obj.id !== 'CloudFolha') {
          obj.selectable = true;
          obj.evented = true;
        }
      });
    } else if (currentTool === 'select') {
      canvas.selection = true;
      canvas.defaultCursor = 'crosshair';
      canvas.hoverCursor = 'crosshair';
    } else if (currentTool === 'texto') {
      addText();
    }
  });
});

canvas.selection = true;
canvas.defaultCursor = 'default';
canvas.hoverCursor = 'move';

const patternCanvas = document.createElement('canvas');
patternCanvas.width = 20;
patternCanvas.height = 20;
const ctx = patternCanvas.getContext('2d');
ctx.fillStyle = '#16213e';
ctx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);
ctx.fillStyle = '#1f2b4c';
ctx.beginPath();
ctx.arc(10, 10, 3, 0, Math.PI * 2);
ctx.fill();
const pattern = new fabric.Pattern({
  source: patternCanvas,
  repeat: 'repeat'
});

canvas.setBackgroundColor(pattern, canvas.renderAll.bind(canvas));



document.getElementById('loadImageBtn').addEventListener('click', () => {
  document.getElementById('fileInput').click();
});

document.getElementById('fileInput').addEventListener('change', function (e) {
  const files = Array.from(e.target.files);
  if (files.length > 0) {
    let loadedImages = 0;
    const totalImages = files.length;
    const spacing = 50;
    files.forEach((file, index) => {
      const reader = new FileReader();
      reader.onload = function (f) {
        const data = f.target.result;
        fabric.Image.fromURL(data, function (img) {
          const pageWidth = 21 * CM_TO_PX;
          const pageHeight = 29.7 * CM_TO_PX;
          const scale = Math.min(pageWidth * 0.8 / img.width, pageHeight * 0.8 / img.height);
          img.scale(scale);
          const a4Page = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
          if (a4Page) {
            img.set({
              left: a4Page.left + (a4Page.width - img.width * scale) / 2 + index * spacing,
              top: a4Page.top + (a4Page.height - img.height * scale) / 2 + index * spacing
            });
          }
          canvas.add(img);
          canvas.setActiveObject(img);
          updateSizeInputs();
          loadedImages++;
          if (loadedImages === totalImages) {
            canvas.renderAll();
          }
        });
      };
      reader.readAsDataURL(file);
    });
  }
});

function updateOpacityControls() {
  const activeObjects = canvas.getActiveObjects();
  const opacityControls = document.getElementById('opacity-controls');
  const opacityInput = document.getElementById('opacity-input');

  if (activeObjects.length > 0 && activeObjects.every(obj => obj.type === 'image')) {
    opacityControls.style.display = 'flex';
    opacityInput.value = Math.round(activeObjects[0].opacity * 100);
    activeObjects.forEach(obj => obj.set('opacity', 1.0)); // Inicializa a opacidade para 100%
  } else {
    opacityControls.style.display = 'none';
  }
}

function exportSelectedAsPNG() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject) return;
  const tempCanvas = document.createElement('canvas');
  const ctx = tempCanvas.getContext('2d');
  if (activeObject.type === 'activeSelection') {
    const group = activeObject;
    const groupBounds = group.getBoundingRect();
    tempCanvas.width = groupBounds.width;
    tempCanvas.height = groupBounds.height;
    const tempFabricCanvas = new fabric.Canvas(tempCanvas);
    const objects = group.getObjects();
    objects.forEach(obj => {
      const clone = fabric.util.object.clone(obj);
      clone.left -= groupBounds.left;
      clone.top -= groupBounds.top;
      tempFabricCanvas.add(clone);
    });
    tempFabricCanvas.renderAll();
    const dataURL = tempFabricCanvas.toDataURL({
      format: 'png',
      quality: 1
    });
    downloadImage(dataURL, 'merged_selection.png');
    tempFabricCanvas.dispose();
  } else {
    tempCanvas.width = activeObject.width * activeObject.scaleX;
    tempCanvas.height = activeObject.height * activeObject.scaleY;
    const tempFabricCanvas = new fabric.Canvas(tempCanvas);
    const clone = fabric.util.object.clone(activeObject);
    clone.left = 0;
    clone.top = 0;
    tempFabricCanvas.add(clone);
    tempFabricCanvas.renderAll();
    const dataURL = tempFabricCanvas.toDataURL({
      format: 'png',
      quality: 1
    });
    downloadImage(dataURL, 'selection.png');
    tempFabricCanvas.dispose();
  }
}

function downloadImage(dataURL, filename) {
  const link = document.createElement('a');
  link.download = filename;
  link.href = dataURL;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

document.getElementById('opacity-input').addEventListener('input', function (e) {
  const activeObjects = canvas.getActiveObjects();
  if (activeObjects.length > 0 && activeObjects.every(obj => obj.type === 'image')) {
    const opacity = parseInt(e.target.value) / 100;
    activeObjects.forEach(obj => obj.set('opacity', opacity));
    canvas.renderAll();
  }
});

document.getElementById('export-png-btn').addEventListener('click', exportSelectedAsPNG);



lockRatioBtn.addEventListener('click', () => {
  isRatioLocked = !isRatioLocked;
  lockRatioBtn.textContent = isRatioLocked ? '🔒' : '🔓';

  const activeObject = canvas.getActiveObject();
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');

  if (isRatioLocked) {
    if (activeObject && activeObject.id !== 'CloudFolha') {
      if (activeObject.type === 'i-text') {
        const scaledWidth = activeObject.width * activeObject.scaleX;
        const scaledHeight = activeObject.height * activeObject.scaleY;
        aspectRatio = scaledWidth / scaledHeight;
      } else {
        aspectRatio = (activeObject.width * activeObject.scaleX) / (activeObject.height * activeObject.scaleY);
      }
    } else if (cloudFolha) {
      aspectRatio = cloudFolha.width / cloudFolha.height;
    }
  }
});

docSwapDimsBtn.addEventListener('click', () => {
  const currentWidth = docWidthInput.value;
  const currentHeight = docHeightInput.value;
  docWidthInput.value = currentHeight;
  docHeightInput.value = currentWidth;
});

function updateDocDimension(input, dimension) {
  if (!docIsRatioLocked) return;
  const value = parseFloat(input.value);
  if (dimension === 'width') {
    const newHeight = value / docAspectRatio;
    docHeightInput.value = newHeight.toFixed(1);
  } else {
    const newWidth = value * docAspectRatio;
    docWidthInput.value = newWidth.toFixed(1);
  }
}

docWidthInput.addEventListener('input', () => updateDocDimension(docWidthInput, 'width'));
docHeightInput.addEventListener('input', () => updateDocDimension(docHeightInput, 'height'));

docSizeOkBtn.addEventListener('click', () => {
  const width = parseFloat(docWidthInput.value) * CM_TO_PX;
  const height = parseFloat(docHeightInput.value) * CM_TO_PX;
  const existingFolha = canvas.getObjects().filter(obj => obj.id === 'CloudFolha');
  existingFolha.forEach(obj => canvas.remove(obj));
  const a4Page = new fabric.Rect({
    id: 'CloudFolha',
    left: (canvas.width - width) / 2,
    top: (canvas.height - height) / 2,
    width: width,
    height: height,
    fill: 'white',
    selectable: false,
    evented: false
  });
  canvas.add(a4Page);
  canvas.sendToBack(a4Page);
  canvas.renderAll();
});

function updateSelectionState() {
  const activeObject = canvas.getActiveObject();
  if (activeObject) {
    activeObject.setCoords();
  }
}


function updateFloatingTextMenu() {
  const activeObject = canvas.getActiveObject();
  const menu = document.getElementById('floating-text-menu');

  if (activeObject && activeObject.type === 'i-text') {
    const zoom = canvas.getZoom();
    const objRect = activeObject.getBoundingRect();
    const canvasRect = canvas.getElement().getBoundingClientRect();

    let left = canvasRect.left + objRect.left + objRect.width + 10;
    let top = canvasRect.top + objRect.top;

    const menuWidth = 200;
    const menuHeight = 210;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    if (left + menuWidth > windowWidth) {
      left = canvasRect.left + objRect.left - menuWidth - 10;
    }
    if (top + menuHeight > windowHeight) {
      top = windowHeight - menuHeight - 10;
    }

    menu.style.left = `${left}px`;
    menu.style.top = `${top}px`;
    menu.style.display = 'block';

    const fontSizeInput = menu.querySelector('#font-size');
    const outlineSize = menu.querySelector('.outline-size');
    const outlineColor = menu.querySelector('.outline-color');
    const gradientCheckbox = menu.querySelector('#gradient-checkbox');
    const gradientColor = menu.querySelector('#gradient-color');

    if (fontSizeInput) {
      const currentFontSize = Math.round(activeObject.fontSize);
      fontSizeInput.value = currentFontSize;
    }

    outlineSize.value = activeObject.strokeWidth ? (activeObject.strokeWidth / 2).toFixed(1) : '0';
    outlineColor.value = activeObject.stroke || '#000000';

 gradientCheckbox.checked = activeObject.fill === 'transparent' ? false : true;
    gradientColor.value = activeObject.fill === 'transparent' ? '#ffffff' : activeObject.fill;
  } else {
    menu.style.display = 'none';
  }
}

document.querySelectorAll('.outline-row input').forEach(input => {
  input.addEventListener('input', function () {
    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type === 'i-text') {
      applyOutlineToText(activeObject);
    }
  });
  input.addEventListener('change', function () {
    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type === 'i-text') {
      applyOutlineToText(activeObject);
    }
  });
});

function applyOutlineToText(textObject) {
  const outlineRow = document.querySelector('.outline-row');
  const size = parseFloat(outlineRow.querySelector('.outline-size').value);
  const color = outlineRow.querySelector('.outline-color').value;
  textObject.set({
    paintFirst: 'stroke',
    stroke: color,
    strokeWidth: size * 2,
    strokeUniform: true,
    strokeLineJoin: 'round'
  });
  canvas.requestRenderAll();
}


document.addEventListener('click', function (e) {
  const menu = document.getElementById('floating-text-menu');
  const activeObject = canvas.getActiveObject();
  if (!menu.contains(e.target) && (!activeObject || activeObject.type !== 'i-text')) {
    menu.style.display = 'none';
  }
});

document.getElementById('font-family').addEventListener('change', function (e) {
  const activeObject = canvas.getActiveObject();
  if (activeObject && activeObject.type === 'i-text') {
    activeObject.set('fontFamily', e.target.value);
    canvas.renderAll();
  }
});

document.getElementById('font-size').addEventListener('input', function (e) {
  const activeObject = canvas.getActiveObject();
  if (activeObject && activeObject.type === 'i-text') {
    const newFontSize = parseInt(e.target.value);

    activeObject.set({
      fontSize: newFontSize,
      scaleX: 1,
      scaleY: 1
    });

    const widthCm = convertDimensions(activeObject.width, 'px', 'cm');
    const heightCm = convertDimensions(activeObject.height, 'px', 'cm');
    widthInput.value = widthCm.toFixed(1);
    heightInput.value = heightCm.toFixed(1);

    canvas.renderAll();
  }
});

document.getElementById('font-color').addEventListener('input', function (e) {
  const activeObject = canvas.getActiveObject();
  if (activeObject && activeObject.type === 'i-text') {
    activeObject.set('fill', e.target.value);
    canvas.renderAll();
  }
});

document.getElementById('text-align').addEventListener('change', function (e) {
  const activeObject = canvas.getActiveObject();
  if (activeObject && activeObject.type === 'i-text') {
    activeObject.set('textAlign', e.target.value);
    canvas.renderAll();
  }
});

document.getElementById('floating-text-menu').addEventListener('click', function (e) {
  e.stopPropagation();
});

function addText() {
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (!cloudFolha) return;

  const text = new fabric.IText('Digite seu texto', {
    left: cloudFolha.left + cloudFolha.width / 2,
    top: cloudFolha.top + cloudFolha.height / 2,
    fontFamily: 'Arial',
    fontSize: 20,
    fill: '#000000',
    originX: 'center',
    originY: 'center',
    textAlign: 'center',
    stroke: null,
    strokeWidth: 0
  });

  canvas.add(text);
  canvas.setActiveObject(text);
  canvas.renderAll();
}

document.getElementById('gradient-checkbox').addEventListener('change', function (e) {
  const activeObject = canvas.getActiveObject();
  if (activeObject && activeObject.type === 'i-text') {
    const gradientColor = document.getElementById('gradient-color').value;
    const primaryColor = document.getElementById('font-color').value;

    if (e.target.checked) {
      activeObject.set('fill', new fabric.Gradient({
        type: 'linear',
        coords: { x1: 0, y1: 0, x2: activeObject.width, y2: 0 },
        colorStops: [
          { offset: 0, color: primaryColor },
          { offset: 0.5, color: gradientColor }
        ]
      }));
    } else {
      activeObject.set('fill', primaryColor);
    }
    canvas.renderAll();
  }
});

document.getElementById('gradient-color').addEventListener('input', function (e) {
  const activeObject = canvas.getActiveObject();
  const checkbox = document.getElementById('gradient-checkbox');
  if (activeObject && activeObject.type === 'i-text' && checkbox.checked) {
    const primaryColor = document.getElementById('font-color').value;
    activeObject.set('fill', new fabric.Gradient({
      type: 'linear',
      coords: { x1: 0, y1: 0, x2: activeObject.width, y2: 0 },
      colorStops: [
        { offset: 0, color: primaryColor },
        { offset: 0.5, color: e.target.value }
      ]
    }));
    canvas.renderAll();
  }
});

//--------------------------------- Seção Final Texto ---------------------------------

// ----------------------------------------- Seção Inicio Recorte ----------------------------------------------------
let cropper;

document.getElementById('cropImageBtn').addEventListener('click', function () {
    const activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') {
        showCustomAlert('Selecione uma imagem para recortar.');
        return;
    }

    const boundingRect = activeObject.getBoundingRect();

    const originalState = {
        left: activeObject.left,
        top: activeObject.top,
        angle: activeObject.angle,
        flipX: activeObject.flipX,
        flipY: activeObject.flipY,
        skewX: activeObject.skewX,
        skewY: activeObject.skewY,
        originX: activeObject.originX,
        originY: activeObject.originY,
        width: activeObject.width,
        height: activeObject.height,
        scaleX: activeObject.scaleX,
        scaleY: activeObject.scaleY,
        boundingWidth: boundingRect.width,
        boundingHeight: boundingRect.height
    };

    const imgElement = activeObject.getElement();
    const cropModal = document.getElementById('cropModal');
    const cropImage = document.getElementById('cropImage');

    cropModal.dataset.originalState = JSON.stringify(originalState);

    cropImage.src = imgElement.src;
    cropModal.style.display = 'flex';

    if (cropper) {
        cropper.destroy();
    }

    cropper = new Cropper(cropImage, {
        aspectRatio: NaN,
        viewMode: 1,
        autoCropArea: 0.9,
        zoomable: true,
        scalable: true,
        initialAspectRatio: NaN,
        ready() {
            const containerData = this.cropper.getContainerData();
            const imageData = this.cropper.getImageData();
            const scale = Math.min(
                containerData.width / imageData.naturalWidth,
                containerData.height / imageData.naturalHeight
            );
            this.cropper.zoomTo(scale);
        }
    });
});

document.getElementById('saveCrop').addEventListener('click', function () {
    if (!cropper) return;

    const canvasCropped = cropper.getCroppedCanvas({
        imageSmoothingEnabled: true,
        imageSmoothingQuality: 'high'
    });

    const activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') return;

    const croppedImageData = canvasCropped.toDataURL();

    fabric.Image.fromURL(croppedImageData, function(newImage) {
        // Use a posição original da imagem
        newImage.set({
            left: activeObject.left, // Mantém a posição original
            top: activeObject.top,   // Mantém a posição original
            scaleX: activeObject.scaleX,
            scaleY: activeObject.scaleY,
            angle: activeObject.angle
        });

        canvas.remove(activeObject);
        canvas.add(newImage);
        canvas.setActiveObject(newImage);
        canvas.renderAll();
        saveState();

        // Fechar o modal
        document.getElementById('cropModal').style.display = 'none';
        cropper.destroy();
    });
});

document.getElementById('closeCropModal').addEventListener('click', function () {
    const cropModal = document.getElementById('cropModal');
    cropModal.style.display = 'none';
    if (cropper) {
        cropper.destroy();
    }
});

// ----------------------------------------- Seção Final Recorte ----------------------------------------------------


// ----------------------------------------- Seção Inicio Vetorizar PB ----------------------------------------------------

document.getElementById('vectorizePBBtn').addEventListener('click', function () {
    const activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') {
        showCustomAlert('Selecione uma imagem para vetorizar.');
        return;
    }

    const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
    if (!cloudFolha) {
        showCustomAlert('Folha "CloudFolha" não encontrada.');
        return;
    }

    const centerX = cloudFolha.left + (cloudFolha.width * cloudFolha.scaleX) / 2;
    const centerY = cloudFolha.top + (cloudFolha.height * cloudFolha.scaleY) / 2;

    const imgElement = activeObject.getElement();

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = imgElement.width;
    tempCanvas.height = imgElement.height;
    const ctx = tempCanvas.getContext('2d');

    ctx.drawImage(imgElement, 0, 0);

    const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const data = imageData.data;

    for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const brightness = (r + g + b) / 3;
        const threshold = 128;

        data[i] = data[i + 1] = data[i + 2] = brightness > threshold ? 255 : 0;
    }

    ctx.putImageData(imageData, 0, 0);

    tempCanvas.toBlob(function (blob) {
        Potrace.loadImageFromFile(new File([blob], "image.png", { type: "image/png" }));
        Potrace.process(function () {
            const svgContent = Potrace.getSVG(1, {
                turdsize: 2,
                alphamax: 1,
                optcurve: true,
                detail: 5
            });

            fabric.loadSVGFromString(svgContent, function (objects, options) {
                const svgGroup = fabric.util.groupSVGElements(objects, options);

                svgGroup.set({
                    left: centerX - (svgGroup.width * svgGroup.scaleX) / 2,
                    top: centerY - (svgGroup.height * svgGroup.scaleY) / 2,
                    selectable: true,
                    evented: true
                });

                canvas.add(svgGroup);
                canvas.renderAll();
                saveState();
            });
        });
    }, 'image/png');
});
// ----------------------------------------- Seção Final Vetorizar PB ----------------------------------------------------

// ----------------------------------------- Seção Inicio Extrair Regiões da imagem ----------------------------------------------------

document.getElementById('extractRegionsBtn').addEventListener('click', function() {
    const activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') {
        showCustomAlert('Selecione uma imagem para extrair as regiões');
        return;
    }

    const imgElement = activeObject.getElement();
    const canvasTemp = document.createElement('canvas');
    const ctxTemp = canvasTemp.getContext('2d');
    canvasTemp.width = imgElement.width;
    canvasTemp.height = imgElement.height;
    ctxTemp.drawImage(imgElement, 0, 0);

    const imageData = ctxTemp.getImageData(0, 0, canvasTemp.width, canvasTemp.height);
    const visited = new Set();
    const regions = [];

    const minRegionSize = 10; // Tamanho mínimo da região (pode ser ajustado)

    for (let y = 0; y < canvasTemp.height; y++) {
        for (let x = 0; x < canvasTemp.width; x++) {
            const pos = (y * canvasTemp.width + x) * 4;
            const alpha = imageData.data[pos + 3];
            
            if (alpha > 0 && !visited.has(`${x},${y}`)) {
                const region = findRegion(imageData, x, y, canvasTemp.width, canvasTemp.height, visited);
                if (region.pixels.length > 0) {
                    const width = region.bounds.maxX - region.bounds.minX + 1;
                    const height = region.bounds.maxY - region.bounds.minY + 1;
                    if (width >= minRegionSize && height >= minRegionSize) {
                        regions.push(region);
                        addRegionToCanvas(region, imgElement);
                    }
                }
            }
        }
    }

    showCustomAlert(`Extraídas ${regions.length} regiões da imagem.`);
});

function findRegion(imageData, startX, startY, width, height, visited) {
    const pixels = [];
    const queue = [[startX, startY]];
    let minX = startX, minY = startY, maxX = startX, maxY = startY;

    while (queue.length > 0) {
        const [x, y] = queue.shift();
        const key = `${x},${y}`;
        
        if (visited.has(key)) continue;
        visited.add(key);

        const pos = (y * width + x) * 4;
        if (imageData.data[pos + 3] > 0) {
            pixels.push([x, y]);
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);

            const neighbors = [
                [x+1, y], [x-1, y],
                [x, y+1], [x, y-1]
            ];

            for (const [nx, ny] of neighbors) {
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const npos = (ny * width + nx) * 4;
                    if (imageData.data[npos + 3] > 0) {
                        queue.push([nx, ny]);
                    }
                }
            }
        }
    }

    return {
        pixels,
        bounds: {minX, minY, maxX, maxY}
    };
}

function addRegionToCanvas(region, imgElement) {
    const canvasTemp = document.createElement('canvas');
    const ctxTemp = canvasTemp.getContext('2d');
    const width = region.bounds.maxX - region.bounds.minX + 1;
    const height = region.bounds.maxY - region.bounds.minY + 1;
    
    canvasTemp.width = width;
    canvasTemp.height = height;

    ctxTemp.drawImage(imgElement, 
        region.bounds.minX, region.bounds.minY, width, height,
        0, 0, width, height);

    const imageData = ctxTemp.getImageData(0, 0, width, height);
    const pixels = new Set(region.pixels.map(([x, y]) => `${x-region.bounds.minX},${y-region.bounds.minY}`));

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (!pixels.has(`${x},${y}`)) {
                const pos = (y * width + x) * 4;
                imageData.data[pos + 3] = 0;
            }
        }
    }

    ctxTemp.putImageData(imageData, 0, 0);

    fabric.Image.fromURL(canvasTemp.toDataURL(), function(img) {
        img.set({
            left: region.bounds.minX,
            top: region.bounds.minY,
            originX: 'left',
            originY: 'top',
            selectable: true,
            evented: true
        });
        canvas.add(img);
        canvas.renderAll();
    });
}

// ----------------------------------------- Seção Final Extrair Regiões da imagem ----------------------------------------------------

// ----------------------------------------- Seção Inicio Remover Cor ----------------------------------------------------

document.getElementById('removeColorBtn').addEventListener('click', function() {
    const activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') {
        showCustomAlert('Selecione uma imagem para remover a cor');
        return;
    }

    originalImagePosition = {
        left: activeObject.left,
        top: activeObject.top
    };

    const removeColorModal = document.getElementById('removeColorModal');
    const removeColorCanvas = document.getElementById('removeColorCanvas');

    const originalImage = activeObject._element;
    removeColorCanvas.width = originalImage.width;
    removeColorCanvas.height = originalImage.height;

    const ctx = removeColorCanvas.getContext('2d');
    ctx.drawImage(originalImage, 0, 0, originalImage.width, originalImage.height);

    removeColorHistory = [];
    currentRemoveColorIndex = -1;
    saveRemoveColorHistory(ctx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height));

    removeColorModal.style.display = 'flex';
});

function saveRemoveColorHistory(imageData) {
    removeColorHistory = removeColorHistory.slice(0, currentRemoveColorIndex + 1);

    removeColorHistory.push(imageData);
    currentRemoveColorIndex++;

    if (removeColorHistory.length > 10) {
        removeColorHistory.shift();
        currentRemoveColorIndex--;
    }
}

document.getElementById('closeRemoveColorModal').addEventListener('click', function() {
    document.getElementById('removeColorModal').style.display = 'none';
});

document.getElementById('undoRemoveColor').addEventListener('click', function() {
    if (currentRemoveColorIndex > 0) {
        currentRemoveColorIndex--;
        const previousState = removeColorHistory[currentRemoveColorIndex];
        const ctx = removeColorCanvas.getContext('2d');
        ctx.putImageData(previousState, 0, 0);
    }
});

const saveRemoveColor = document.getElementById('saveRemoveColor');
const oldSaveElement = saveRemoveColor.cloneNode(true);
saveRemoveColor.parentNode.replaceChild(oldSaveElement, saveRemoveColor);

document.getElementById('saveRemoveColor').addEventListener('click', function () {
    const removeColorCanvas = document.getElementById('removeColorCanvas');
    const activeObject = canvas.getActiveObject();
    const removeColorModal = document.getElementById('removeColorModal');

    if (!activeObject || activeObject.type !== 'image') {
        removeColorModal.style.display = 'none';
        return;
    }

    const dataURL = removeColorCanvas.toDataURL('image/png', 1.0);

    const originalProps = {
        left: originalImagePosition.left,
        top: originalImagePosition.top,
        scaleX: activeObject.scaleX,
        scaleY: activeObject.scaleY,
        angle: activeObject.angle,
        flipX: activeObject.flipX,
        flipY: activeObject.flipY,
        width: activeObject.width,
        height: activeObject.height,
        originX: activeObject.originX,
        originY: activeObject.originY,
        centeredScaling: activeObject.centeredScaling,
        centeredRotation: activeObject.centeredRotation
    };

    canvas.remove(activeObject);

    fabric.Image.fromURL(dataURL, function (newImage) {
        newImage.set(originalProps);
        
        newImage.setCoords();
        
        canvas.add(newImage);
        canvas.setActiveObject(newImage);
        canvas.renderAll();
        saveState();

        removeColorModal.style.display = 'none';
    });
});

removeColorBtn.addEventListener('click', () => {
    const activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') {
        showCustomAlert('Selecione uma imagem para remover a cor');
        return;
    }
    activeImage = activeObject;
    prepareRemoveColorCanvas(activeImage);
});

removeRegionBtn.addEventListener('click', () => {
    currentRemoveMode = 'region';
    removeRegionBtn.classList.add('active');
    removeTotalBtn.classList.remove('active');
});

removeTotalBtn.addEventListener('click', () => {
    currentRemoveMode = 'total';
    removeTotalBtn.classList.add('active');
    removeRegionBtn.classList.remove('active');
});

removeColorCanvas.addEventListener('click', (e) => {
    if (currentRemoveMode === 'region') {
        handleRemoveColorRegion(e);
    } else {
        handleRemoveColorTotal(e);
    }
});

closeRemoveColorModal.addEventListener('click', () => {
    removeColorModal.style.display = 'none';
});

undoRemoveColor.addEventListener('click', () => {
    if (removeColorHistoryIndex > 0) {
        removeColorHistoryIndex--;
        const previousState = removeColorHistory[removeColorHistoryIndex];
        const ctx = removeColorCanvas.getContext('2d');
        ctx.putImageData(previousState, 0, 0);
    }
});

function handleRemoveColorRegion(e) {
    if (!removeColorCtx) return;

    const currentState = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    saveRemoveColorHistory(currentState);

    const rect = removeColorCanvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) * (removeColorCanvas.width / rect.width));
    const y = Math.floor((e.clientY - rect.top) * (removeColorCanvas.height / rect.height));

    const imageData = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    const tolerance = parseInt(sensitivityRange.value);

    const processedImageData = floodFillAtPoint(
        imageData,
        x,
        y,
        { r: 0, g: 0, b: 0, a: 0 },
        tolerance
    );

    removeColorCtx.putImageData(processedImageData, 0, 0);
}

function handleRemoveColorTotal(e) {
    if (!removeColorCtx) return;

    const currentState = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    saveRemoveColorHistory(currentState);

    const rect = removeColorCanvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) * (removeColorCanvas.width / rect.width));
    const y = Math.floor((e.clientY - rect.top) * (removeColorCanvas.height / rect.height));

    const imageData = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    const tolerance = parseInt(sensitivityRange.value);
    const targetColor = getPixel(imageData, x, y);

    const processedImageData = floodFillEntireImage(
        imageData,
        targetColor,
        { r: 0, g: 0, b: 0, a: 0 },
        tolerance
    );

    removeColorCtx.putImageData(processedImageData, 0, 0);
}

function prepareRemoveColorCanvas(activeImage) {
    const removeColorCanvas = document.getElementById('removeColorCanvas');
    const removeColorModal = document.getElementById('removeColorModal');
    
    removeColorCtx = removeColorCanvas.getContext('2d');
    
    const originalWidth = activeImage.getElement().naturalWidth;
    const originalHeight = activeImage.getElement().naturalHeight;
    
    removeColorCanvas.width = originalWidth;
    removeColorCanvas.height = originalHeight;
    
    removeColorCtx.drawImage(activeImage.getElement(), 0, 0, originalWidth, originalHeight);
    
    const modalWidth = removeColorModal.clientWidth;
    const modalHeight = removeColorModal.clientHeight;
    const imageRatio = originalWidth / originalHeight;
    const modalRatio = modalWidth / modalHeight;
    
    if (imageRatio > modalRatio) {
        removeColorCanvas.style.width = '90%';
        removeColorCanvas.style.height = 'auto';
    } else {
        removeColorCanvas.style.width = 'auto';
        removeColorCanvas.style.height = '90%';
    }
    
    removeColorHistory = [];
    removeColorHistoryIndex = -1;
    saveRemoveColorHistory();
    
    removeColorModal.style.display = 'flex';
}

function saveRemoveColorHistory() {
    if (!removeColorCtx) return;
    const imageData = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    removeColorHistory = removeColorHistory.slice(0, removeColorHistoryIndex + 1);
    removeColorHistory.push(imageData);
    removeColorHistoryIndex = removeColorHistory.length - 1;
}

function floodFillAtPoint(imageData, startX, startY, fillColor, tolerance) {
    const width = imageData.width;
    const height = imageData.height;
    const visited = new Uint8Array(width * height);
    const queue = [];

    const targetColor = getPixel(imageData, startX, startY);
    if (!targetColor) return imageData;

    queue.push([startX, startY]);
    visited[startY * width + startX] = 1;

    while (queue.length > 0) {
        const [x, y] = queue.shift();
        const currentPixel = getPixel(imageData, x, y);

        if (colorMatch(currentPixel, targetColor, tolerance)) {
            setPixel(imageData, x, y, fillColor);

            [[x-1,y], [x+1,y], [x,y-1], [x,y+1]].forEach(([nx,ny]) => {
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const index = ny * width + nx;
                    if (!visited[index]) {
                        visited[index] = 1;
                        queue.push([nx,ny]);
                    }
                }
            });
        }
    }

    return imageData;
}

function handleRemoveColorTotal(e) {
    if (!removeColorCtx) return;

    const currentState = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    saveRemoveColorHistory(currentState);

    const rect = removeColorCanvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) * (removeColorCanvas.width / rect.width));
    const y = Math.floor((e.clientY - rect.top) * (removeColorCanvas.height / rect.height));

    const imageData = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    const tolerance = parseInt(sensitivityRange.value);
    const targetColor = getPixel(imageData, x, y);

    const processedImageData = floodFillEntireImage(
        imageData,
        targetColor,
        { r: 0, g: 0, b: 0, a: 0 },
        tolerance
    );

    removeColorCtx.putImageData(processedImageData, 0, 0);
}

function floodFillEntireImage(imageData, targetColor, fillColor, tolerance) {
    const width = imageData.width;
    const height = imageData.height;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const currentPixel = getPixel(imageData, x, y);
            if (colorMatch(currentPixel, targetColor, tolerance)) {
                setPixel(imageData, x, y, fillColor);
            }
        }
    }

    return imageData;
}

function getPixel(imageData, x, y) {
    const index = (y * imageData.width + x) * 4;
    if (index >= imageData.data.length) return null;
    return {
        r: imageData.data[index],
        g: imageData.data[index + 1],
        b: imageData.data[index + 2],
        a: imageData.data[index + 3]
    };
}

function setPixel(imageData, x, y, color) {
    const index = (y * imageData.width + x) * 4;
    if (index >= imageData.data.length) return;
    imageData.data[index] = color.r;
    imageData.data[index + 1] = color.g;
    imageData.data[index + 2] = color.b;
    imageData.data[index + 3] = color.a;
}

function colorMatch(c1, c2, tolerance) {
    if (!c1 || !c2) return false;
    return Math.abs(c1.r - c2.r) <= tolerance &&
           Math.abs(c1.g - c2.g) <= tolerance &&
           Math.abs(c1.b - c2.b) <= tolerance;
}
document.getElementById('removeRegionBtn').addEventListener('click', () => {
    currentRemoveMode = 'region';
    removeRegionBtn.classList.add('active');
    removeTotalBtn.classList.remove('active');
    updateButtonStyles();
});

function updateButtonStyles() {
    const removeRegionBtn = document.getElementById('removeRegionBtn');
    const removeTotalBtn = document.getElementById('removeTotalBtn');

    if (currentRemoveMode === 'region') {
        removeRegionBtn.classList.add('active');
        removeTotalBtn.classList.remove('active');
    } else {
        removeTotalBtn.classList.add('active');
        removeRegionBtn.classList.remove('active');
    }
}

document.getElementById('removeTotalBtn').addEventListener('click', () => {
    currentRemoveMode = 'total';
    removeTotalBtn.classList.add('active');
    removeRegionBtn.classList.remove('active');
    updateButtonStyles();
});
document.getElementById('removeColorModal').addEventListener('click', function(e) {
    if (e.target === this) {
        this.style.display = 'none';
    }
});
// ----------------------------------------- Seção Final Remover Cor ----------------------------------------------------

// ----------------------------------------- Seção Inicio Pincel Balde e Borracha ----------------------------------------------------

function openModal(tool) {
    const activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') {
        showCustomAlert('Selecione uma imagem primeiro');
        return;
    }

    let paintingHistory = [];
    let currentPaintingIndex = -1;
    const maxHistoryStates = 10;
	let originalImagePosition = { left: 0, top: 0 };

    function savePaintingHistory(ctx) {
        const imageData = ctx.getImageData(0, 0, paintingCanvas.width, paintingCanvas.height);
        paintingHistory = paintingHistory.slice(0, currentPaintingIndex + 1);
        paintingHistory.push(imageData);
        currentPaintingIndex++;

        if (paintingHistory.length > maxHistoryStates) {
            paintingHistory.shift();
            currentPaintingIndex--;
        }

        undoButton.disabled = currentPaintingIndex <= 0;
    }

    function undoPainting() {
        if (currentPaintingIndex > 0) {
            currentPaintingIndex--;
            const previousState = paintingHistory[currentPaintingIndex];
            paintingCtx.putImageData(previousState, 0, 0);
            undoButton.disabled = currentPaintingIndex <= 0;
        }
    }

    const modal = document.createElement('div');
    modal.classList.add('modal-overlay');

    const modalContent = document.createElement('div');
    modalContent.classList.add('modal-content');

    const modalBody = document.createElement('div');
    modalBody.classList.add('modal-body');

    const paintingCanvas = document.createElement('canvas');
    paintingCanvas.style.maxWidth = '100%';
    paintingCanvas.style.maxHeight = '100%';
    paintingCanvas.style.border = '1px solid #ccc';
    modalBody.appendChild(paintingCanvas);

    const modalFooter = document.createElement('div');
    modalFooter.classList.add('modal-footer');

    const brushButton = document.createElement('button');
    brushButton.id = 'brushButton';
    brushButton.classList.add('modal-btn');
    brushButton.textContent = 'Pincel';
    brushButton.addEventListener('click', () => {
        setTool('brush');
        hideButtonsExcept('brushButton');
    });

    const eraserButton = document.createElement('button');
    eraserButton.id = 'eraserButton';
    eraserButton.classList.add('modal-btn');
    eraserButton.textContent = 'Borracha';
    eraserButton.addEventListener('click', () => {
        setTool('eraser');
        hideButtonsExcept('eraserButton');
    });

    const bucketButton = document.createElement('button');
    bucketButton.id = 'bucketButton';
    bucketButton.classList.add('modal-btn');
    bucketButton.textContent = 'Balde';
    bucketButton.addEventListener('click', () => {
        setTool('bucket');
        hideButtonsExcept('bucketButton');
    });

    const closeButton = document.createElement('button');
    closeButton.classList.add('modal-btn');
    closeButton.textContent = 'Fechar';
    closeButton.addEventListener('click', () => {
        document.body.removeChild(modal);
    });

const saveButton = document.createElement('button');
saveButton.classList.add('modal-btn');
saveButton.textContent = 'Salvar';
saveButton.addEventListener('click', () => {
    const imageURL = paintingCanvas.toDataURL('image/png', 1.0);
    fabric.Image.fromURL(imageURL, (img) => {
        const originalLeft = activeObject.left;
        const originalTop = activeObject.top;

        img.set({
            left: originalLeft,
            top: originalTop,
            scaleX: activeObject.scaleX,
            scaleY: activeObject.scaleY,
            angle: activeObject.angle
        });

        canvas.remove(activeObject);
        canvas.add(img);
        canvas.renderAll();
        document.body.removeChild(modal);
    });
});

    const undoButton = document.createElement('button');
    undoButton.classList.add('modal-btn');
    undoButton.textContent = 'Voltar';
    undoButton.disabled = true;
    undoButton.addEventListener('click', undoPainting);

    const sizeSlider = document.createElement('input');
    sizeSlider.type = 'range';
    sizeSlider.min = '1';
    sizeSlider.max = '500';
    sizeSlider.value = '10';
    sizeSlider.style.width = '100px';
    sizeSlider.classList.add('modal-slider');

    const colorPicker = document.createElement('input');
    colorPicker.type = 'color';
    colorPicker.value = '#000000';

    modalFooter.appendChild(brushButton);
    modalFooter.appendChild(eraserButton);
    modalFooter.appendChild(bucketButton);
    modalFooter.appendChild(sizeSlider);
    modalFooter.appendChild(colorPicker);
    modalFooter.appendChild(undoButton);
    modalFooter.appendChild(closeButton);
    modalFooter.appendChild(saveButton);

    modalContent.appendChild(modalBody);
    modalContent.appendChild(modalFooter);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);

    const paintingCtx = paintingCanvas.getContext('2d');
    const imageElement = activeObject.getElement();
    const originalWidth = imageElement.naturalWidth;
    const originalHeight = imageElement.naturalHeight;

    const imageRatio = originalWidth / originalHeight;
    const modalWidth = modalContent.clientWidth;
    const modalHeight = modalContent.clientHeight;
    let canvasWidth, canvasHeight;

    if (imageRatio > 1) {
        canvasWidth = modalWidth * 0.9;
        canvasHeight = canvasWidth / imageRatio;
    } else {
        canvasHeight = modalHeight * 0.9;
        canvasWidth = canvasHeight * imageRatio;
    }

    paintingCanvas.width = canvasWidth;
    paintingCanvas.height = canvasHeight;

    paintingCtx.drawImage(imageElement, 0, 0, originalWidth, originalHeight, 0, 0, canvasWidth, canvasHeight);

    savePaintingHistory(paintingCtx);

    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let currentTool = tool;

    const hideButtonsExcept = (buttonId) => {
        const buttons = [brushButton, eraserButton, bucketButton];
        buttons.forEach(button => {
            if (button.id !== buttonId) {
                button.style.display = 'none';
            } else {
                button.style.display = 'inline-block';
            }
        });
    };

    if (tool === 'brush') {
        hideButtonsExcept('brushButton');
    } else if (tool === 'eraser') {
        hideButtonsExcept('eraserButton');
    } else if (tool === 'bucket') {
        hideButtonsExcept('bucketButton');
    }

    const getMousePos = (canvas, e) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    };

    const draw = (e) => {
        if (!isDrawing) return;

        const pos = getMousePos(paintingCanvas, e);
        paintingCtx.lineWidth = parseInt(sizeSlider.value);
        paintingCtx.lineCap = 'round';
        paintingCtx.lineJoin = 'round';

        if (currentTool === 'eraser') {
            paintingCtx.globalCompositeOperation = 'destination-out';
            paintingCtx.strokeStyle = 'rgba(0,0,0,1)';
        } else {
            paintingCtx.globalCompositeOperation = 'source-over';
            paintingCtx.strokeStyle = colorPicker.value;
        }

        paintingCtx.beginPath();
        paintingCtx.moveTo(lastX, lastY);
        paintingCtx.lineTo(pos.x, pos.y);
        paintingCtx.stroke();

        [lastX, lastY] = [pos.x, pos.y];
    };

    const floodFill = (x, y, fillColor) => {
        savePaintingHistory(paintingCtx);

        const imageData = paintingCtx.getImageData(0, 0, paintingCanvas.width, paintingCanvas.height);
        const targetColor = getPixel(imageData, x, y);
        const fillColorRGB = hexToRgb(fillColor);

        if (colorMatch(targetColor, fillColorRGB, 0)) return;

        const queue = [[x, y]];
        while (queue.length > 0) {
            const [cx, cy] = queue.shift();
            if (cx < 0 || cx >= paintingCanvas.width || cy < 0 || cy >= paintingCanvas.height) continue;

            const currentPixel = getPixel(imageData, cx, cy);
            if (colorMatch(currentPixel, targetColor, 10)) {
                setPixel(imageData, cx, cy, fillColorRGB);
                queue.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
            }
        }
        paintingCtx.putImageData(imageData, 0, 0);
    };

    const getPixel = (imageData, x, y) => {
        const index = (y * imageData.width + x) * 4;
        return {
            r: imageData.data[index],
            g: imageData.data[index + 1],
            b: imageData.data[index + 2],
            a: imageData.data[index + 3]
        };
    };

    const setPixel = (imageData, x, y, color) => {
        const index = (y * imageData.width + x) * 4;
        imageData.data[index] = color.r;
        imageData.data[index + 1] = color.g;
        imageData.data[index + 2] = color.b;
        imageData.data[index + 3] = color.a;
    };

    const colorMatch = (c1, c2, tolerance) => {
        return Math.abs(c1.r - c2.r) <= tolerance &&
               Math.abs(c1.g - c2.g) <= tolerance &&
               Math.abs(c1.b - c2.b) <= tolerance;
    };

    const hexToRgb = (hex) => {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b, a: 255 };
    };

    const setTool = (tool) => {
        currentTool = tool;
    };

    paintingCanvas.addEventListener('mousedown', (e) => {
        savePaintingHistory(paintingCtx);
        isDrawing = true;
        const pos = getMousePos(paintingCanvas, e);
        [lastX, lastY] = [pos.x, pos.y];

        if (currentTool === 'bucket') {
            floodFill(Math.floor(pos.x), Math.floor(pos.y), colorPicker.value);
        }
    });

    paintingCanvas.addEventListener('mousemove', draw);

    paintingCanvas.addEventListener('mouseup', () => {
        isDrawing = false;
    });

    paintingCanvas.addEventListener('mouseout', () => {
        isDrawing = false;
    });
}

document.getElementById('btnPincel').addEventListener('click', () => openModal('brush'));
document.getElementById('btnBorracha').addEventListener('click', () => openModal('eraser'));
document.getElementById('btnBalde').addEventListener('click', () => openModal('bucket'));
// ----------------------------------------- Seção Final Pincel Balde e Borracha ----------------------------------------------------

// ----------------------------------------- Seção Inicio Menu Imagem ----------------------------------------------------

document.getElementById('rotateBtn').addEventListener('click', () => {
    const activeObject = canvas.getActiveObject();
    const rotateInput = document.getElementById('rotateInput');
    if (activeObject) {
        const rotationValue = parseInt(rotateInput.value);
        activeObject.rotate((activeObject.angle + rotationValue) % 360); // Gira somando o valor do input
        canvas.renderAll();
        saveState();
    } else {
        showCustomAlert('Selecione um objeto para girar.');
    }
});

document.getElementById('duplicateBtn').addEventListener('click', () => {
    const activeObject = canvas.getActiveObject();
    const duplicateInput = document.getElementById('duplicateInput');
    const duplicateCount = parseInt(duplicateInput.value);
    if (activeObject && duplicateCount > 0) {
        for (let i = 0; i < duplicateCount; i++) {
            const clone = fabric.util.object.clone(activeObject);
            clone.set({
                left: activeObject.left + (i + 1) * 10, // Adiciona um pequeno deslocamento
                top: activeObject.top + (i % 2) * 10 // Alterna a linha
            });
            canvas.add(clone);
        }
        canvas.renderAll();
        saveState();
    } else {
        showCustomAlert('Selecione um objeto para duplicar e insira um número válido.');
    }
});

document.getElementById('organizeBtn').addEventListener('click', () => {
    const selectedObjects = canvas.getActiveObjects();
    const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
    const organizeInput = document.getElementById('organizeInput');
    const spacing = parseFloat(organizeInput.value);
    
    if (selectedObjects.length > 0 && cloudFolha) {
        const cloudFolhaWidth = cloudFolha.width * cloudFolha.scaleX;
        const cloudFolhaHeight = cloudFolha.height * cloudFolha.scaleY;

        let currentX = cloudFolha.left;
        let currentY = cloudFolha.top;

        selectedObjects.forEach((obj, index) => {
            obj.set({
                left: currentX,
                top: currentY
            });

            currentX += obj.width * obj.scaleX + spacing; // Move para a direita

            // Se ultrapassar a largura da CloudFolha, desce para a próxima linha
            if (currentX > cloudFolha.left + cloudFolhaWidth) {
                currentX = cloudFolha.left; // Reseta para a esquerda
                currentY += obj.height * obj.scaleY + spacing; // Move para baixo
            }
        });

        canvas.renderAll();
        saveState();
    } else {
        showCustomAlert('Selecione objetos para organizar.');
    }
});

document.getElementById('alignVerticalBtn').addEventListener('click', () => {
    const selectedObjects = canvas.getActiveObjects();
    if (selectedObjects.length > 0) {
        const firstObject = selectedObjects[0];
        const centerY = firstObject.top + (firstObject.height * firstObject.scaleY) / 2;

        selectedObjects.forEach(obj => {
            obj.set({
                top: centerY - (obj.height * obj.scaleY) / 2 // Alinha verticalmente
            });
        });

        canvas.renderAll();
        saveState();
    } else {
        showCustomAlert('Selecione objetos para alinhar verticalmente.');
    }
});

document.getElementById('alignHorizontalBtn').addEventListener('click', () => {
    const selectedObjects = canvas.getActiveObjects();
    if (selectedObjects.length > 0) {
        const firstObject = selectedObjects[0];
        const centerX = firstObject.left + (firstObject.width * firstObject.scaleX) / 2;

        selectedObjects.forEach(obj => {
            obj.set({
                left: centerX - (obj.width * obj.scaleX) / 2 // Alinha horizontalmente
            });
        });

        canvas.renderAll();
        saveState();
    } else {
        showCustomAlert('Selecione objetos para alinhar horizontalmente.');
    }
});

document.getElementById('flipHorizontalBtn').addEventListener('click', () => {
    const selectedObjects = canvas.getActiveObjects();
    if (selectedObjects.length > 0) {
        selectedObjects.forEach(obj => {
            obj.set({
                scaleX: -obj.scaleX
            });
        });

        canvas.renderAll();
        saveState();
    } else {
        showCustomAlert('Selecione objetos para espelhar horizontalmente.');
    }
});

document.getElementById('flipVerticalBtn').addEventListener('click', () => {
    const activeObjects = canvas.getActiveObjects();
    if (!activeObjects || activeObjects.length === 0) {
        showCustomAlert('Selecione objetos para espelhar verticalmente.');
        return;
    }

    activeObjects.forEach(obj => {
        obj.set('flipY', !obj.flipY);
    });

    canvas.renderAll();
    saveState();
});
// ----------------------------------------- Seção Final Menu Imagem ----------------------------------------------------

// ----------------------------------------- Seção Inicio Menu Editar ----------------------------------------------------

document.getElementById('copyBtn').addEventListener('click', async () => {
    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type === 'image') {
        const dataUrl = activeObject.toDataURL(); 
        const blob = await (await fetch(dataUrl)).blob(); 
        const item = new ClipboardItem({ 'image/png': blob });
        await navigator.clipboard.write([item]);
        showCustomAlert('Imagem copiada para a área de transferência.');
    } else {
        showCustomAlert('Selecione uma imagem para copiar.');
    }
});

document.getElementById('pasteBtn').addEventListener('click', async () => {
    try {
        const clipboardItems = await navigator.clipboard.read();
        for (const clipboardItem of clipboardItems) {
            const types = clipboardItem.types;
            for (const type of types) {
                if (type === 'image/png') {
                    const blob = await clipboardItem.getType(type);
                    const imgUrl = URL.createObjectURL(blob);
                    fabric.Image.fromURL(imgUrl, function(img) {
                        img.set({
                            left: 10,
                            top: 10
                        });
                        canvas.add(img);
                        canvas.setActiveObject(img);
                        canvas.renderAll();
                    });
                } else if (type === 'text/plain') {
                    const textBlob = await clipboardItem.getType(type);
                    const text = await textBlob.text();
                    const textObject = new fabric.IText(text, {
                        left: 10,
                        top: 10,
                        fontSize: 20,
                        fill: 'black'
                    });
                    canvas.add(textObject);
                    canvas.setActiveObject(textObject);
                    canvas.renderAll();
                }
            }
        }
    } catch (error) {
        showCustomAlert('Erro ao colar: ' + error.message);
    }
});
// ----------------------------------------- Seção Final Menu Editar ----------------------------------------------------

// ----------------------------------------- Seção Inicio Contorno ----------------------------------------------------
document.getElementById('addContorno').addEventListener('click', function() {
    const activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') {
        showCustomAlert('Selecione uma imagem para adicionar contorno.');
        return;
    }

    const outlineModal = document.getElementById('outlineModal');
    const outlineImagePreview = document.getElementById('outlineImagePreview');
    
    outlineImagePreview.src = activeObject.toDataURL();
    outlineImagePreview.style.display = 'block';
    outlineImagePreview.style.maxWidth = '80%';
    outlineImagePreview.style.maxHeight = '80vh';
    outlineImagePreview.style.objectFit = 'contain';
    outlineImagePreview.style.margin = 'auto';
    
    outlineModal.style.display = 'flex';
    
    updateSliderValues();
    [outlineSlider1, outlineSlider2, colorPicker1, colorPicker2].forEach(element => {
        element.addEventListener('input', function() {
            applyOutlines();
            updateSliderValues();
        });
    });
});

document.getElementById('closeOutlineModal').addEventListener('click', function() {
    document.getElementById('outlineModal').style.display = 'none';
});

document.getElementById('closeOutlineModal').addEventListener('click', function() {
    document.getElementById('outlineModal').style.display = 'none';
});

document.getElementById('applyOutlineBtn').addEventListener('click', function() {
    const width1 = parseInt(document.getElementById('outlineSlider1').value);
    const width2 = parseInt(document.getElementById('outlineSlider2').value);
    const color1 = document.getElementById('colorPicker1').value;
    const color2 = document.getElementById('colorPicker2').value;
    const activeObject = canvas.getActiveObject();
    
    if (activeObject) {
        const imgElement = activeObject.getElement();

        // Calcular o tamanho necessário para o contorno
        const maxOutlineWidth = Math.max(width1, width2);
        const padding = maxOutlineWidth * 2; // Aumentar o padding para acomodar o contorno

        // Criar um canvas temporário para aplicar o contorno
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = imgElement.width + (padding * 2); // Padding em ambos os lados
        tempCanvas.height = imgElement.height + (padding * 2); // Padding em ambos os lados

        // Centralizar a imagem no canvas temporário
        const offsetX = padding;
        const offsetY = padding;

        // Aplicar os contornos em uma única operação
        const shadows = [];
        if (width1 > 0) {
            shadows.push(
                `drop-shadow(${width1}px 0 0 ${color1})`,
                `drop-shadow(-${width1}px 0 0 ${color1})`,
                `drop-shadow(0 ${width1}px 0 ${color1})`,
                `drop-shadow(0 -${width1}px 0 ${color1})`
            );
        }
        if (width2 > 0) {
            shadows.push(
                `drop-shadow(${width2}px 0 0 ${color2})`,
                `drop-shadow(-${width2}px 0 0 ${color2})`,
                `drop-shadow(0 ${width2}px 0 ${color2})`,
                `drop-shadow(0 -${width2}px 0 ${color2})`
            );
        }

        // Aplicar o filtro de contorno
        tempCtx.filter = shadows.join(' ');
        tempCtx.drawImage(imgElement, offsetX, offsetY);

        // Desenhar a imagem original no centro (sem contorno)
        tempCtx.globalCompositeOperation = 'source-over';
        tempCtx.drawImage(imgElement, offsetX, offsetY);

        // Converter o canvas temporário para uma imagem e substituir a original
        const dataUrl = tempCanvas.toDataURL('image/png', 1.0);
        fabric.Image.fromURL(dataUrl, function(img) {
            img.set({
                left: activeObject.left - (offsetX * activeObject.scaleX), // Ajustar a posição
                top: activeObject.top - (offsetY * activeObject.scaleY),  // Ajustar a posição
                scaleX: activeObject.scaleX,
                scaleY: activeObject.scaleY,
                angle: activeObject.angle,
                selectable: true,
                evented: true
            });

            canvas.remove(activeObject);
            canvas.add(img);
            canvas.setActiveObject(img);
            canvas.renderAll();
        });

        // Fechar o modal
        document.getElementById('outlineModal').style.display = 'none';
    }
});

function updateSliderValues() {
    document.getElementById('sliderValue1').textContent = document.getElementById('outlineSlider1').value + 'px';
    document.getElementById('sliderValue2').textContent = document.getElementById('outlineSlider2').value + 'px';
}

function applyOutlines() {
    const width1 = document.getElementById('outlineSlider1').value;
    const width2 = document.getElementById('outlineSlider2').value;
    const color1 = document.getElementById('colorPicker1').value;
    const color2 = document.getElementById('colorPicker2').value;
    const shadows = [];
    
    if (width1 > 0) {
        shadows.push(
            `drop-shadow(${width1}px 0 0 ${color1})`,
            `drop-shadow(-${width1}px 0 0 ${color1})`,
            `drop-shadow(0 ${width1}px 0 ${color1})`,
            `drop-shadow(0 -${width1}px 0 ${color1})`
        );
    }
    
    if (width2 > 0) {
        shadows.push(
            `drop-shadow(${width2}px 0 0 ${color2})`,
            `drop-shadow(-${width2}px 0 0 ${color2})`,
            `drop-shadow(0 ${width2}px 0 ${color2})`,
            `drop-shadow(0 -${width2}px 0 ${color2})`
        );
    }
    
    document.getElementById('outlineImagePreview').style.filter = shadows.join(' ');
}

updateSliderValues();
// ----------------------------------------- Seção Final Contorno ----------------------------------------------------

// Event Listeners para exportação
document.getElementById('exportPNGBtn').addEventListener('click', function() {
    exportCanvas('png'); // Exportar como PNG
});

document.getElementById('exportJPGBtn').addEventListener('click', function() {
    exportCanvas('jpg'); // Exportar como JPG
});

document.getElementById('exportPDFBtn').addEventListener('click', function() {
    exportPdf(); // Exportar como PDF
});

// Função para exportar o canvas em PNG ou JPG
async function exportCanvas(format) {
    const dpi = parseInt(document.getElementById('resolutionInput').value) || 150; // Usar o valor do input ou 150 como padrão
    const scale = dpi / 96;

    const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
    if (!cloudFolha) return;

    // Criar um canvas temporário com dimensões otimizadas
    const tempContainer = document.createElement('div');
    document.body.appendChild(tempContainer);

    const exportCanvas = document.createElement('canvas');
    const targetWidth = cloudFolha.width * scale;
    const targetHeight = cloudFolha.height * scale;

    exportCanvas.width = targetWidth;
    exportCanvas.height = targetHeight;
    tempContainer.appendChild(exportCanvas);

    const exportFabricCanvas = new fabric.Canvas(exportCanvas, {
        enableRetinaScaling: true,
        imageSmoothingQuality: 'high'
    });

    // Configurar canvas de exportação
    exportFabricCanvas.setWidth(targetWidth);
    exportFabricCanvas.setHeight(targetHeight);

    // Adicionar o fundo branco (CloudFolha) apenas para JPG
    if (format === 'jpg') {
        const whiteBackground = new fabric.Rect({
            width: cloudFolha.width,
            height: cloudFolha.height,
            fill: 'white',
            originX: 'left',
            originY: 'top',
            scaleX: scale,
            scaleY: scale
        });
        exportFabricCanvas.add(whiteBackground);
    }

    // Clonar e ajustar objetos
    const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
    const promises = objects.map(async (obj) => {
        const clonedObj = await cloneObjectWithQuality(obj);
        
        const relativeLeft = (obj.left - cloudFolha.left) / cloudFolha.scaleX;
        const relativeTop = (obj.top - cloudFolha.top) / cloudFolha.scaleY;

        const scaleFactor = targetWidth / cloudFolha.width;
        
        clonedObj.set({
            left: relativeLeft * scaleFactor,
            top: relativeTop * scaleFactor,
            scaleX: (obj.scaleX / cloudFolha.scaleX) * scaleFactor,
            scaleY: (obj.scaleY / cloudFolha.scaleY) * scaleFactor
        });

        return clonedObj;
    });

    // Aguardar todos os objetos serem processados
    const clonedObjects = await Promise.all(promises);
    clonedObjects.forEach(obj => exportFabricCanvas.add(obj));

    exportFabricCanvas.renderAll();

    // Configurações específicas por formato
    const exportOptions = {
        format: format,
        quality: 1.0,
        enableRetinaScaling: true,
        multiplier: 1,
        imageSmoothingEnabled: true,
        imageSmoothingQuality: 'high'
    };

    if (format === 'jpg') {
        exportOptions.backgroundColor = '#ffffff'; // Fundo branco para JPG
    }

    // Exportar com qualidade otimizada
    const dataUrl = exportFabricCanvas.toDataURL(exportOptions);
    
    const link = document.createElement('a');
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');
    link.href = dataUrl;
    link.download = `CloudApp_${timestamp}.${format}`;
    link.click();

    // Limpar recursos
    tempContainer.remove();
    exportFabricCanvas.dispose();
}

async function exportPdf() {
    const dpi = parseInt(document.getElementById('resolutionInput').value) || 150; // Usar o valor do input ou 150 como padrão
    const scale = dpi / 96;

    const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
    if (!cloudFolha) return;

    const pageWidth = cmToPoints(cloudFolha.width / CM_TO_PX);
    const pageHeight = cmToPoints(cloudFolha.height / CM_TO_PX);

    // Criar canvas temporário com dimensões otimizadas
    const tempCanvas = document.createElement('canvas');
    const targetWidth = Math.min(cloudFolha.width * scale, 4096);
    const targetHeight = Math.min(cloudFolha.height * scale, 4096);
    
    tempCanvas.width = targetWidth;
    tempCanvas.height = targetHeight;
    
    const tempFabricCanvas = new fabric.StaticCanvas(tempCanvas, {
        enableRetinaScaling: true,
        imageSmoothingQuality: 'high'
    });

    // Clonar e processar objetos com alta qualidade
    const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
    const clonedObjects = await Promise.all(
        objects.map(obj => cloneObjectWithQuality(obj))
    );

    clonedObjects.forEach(obj => {
        const relativeLeft = (obj.left - cloudFolha.left) / cloudFolha.scaleX;
        const relativeTop = (obj.top - cloudFolha.top) / cloudFolha.scaleY;
        
        const scaleFactor = targetWidth / cloudFolha.width;
        
        obj.set({
            left: relativeLeft * scaleFactor,
            top: relativeTop * scaleFactor,
            scaleX: (obj.scaleX / cloudFolha.scaleX) * scaleFactor,
            scaleY: (obj.scaleY / cloudFolha.scaleY) * scaleFactor
        });
        
        tempFabricCanvas.add(obj);
    });

    tempFabricCanvas.renderAll();

    const pdfDoc = await PDFLib.PDFDocument.create();
    const page = pdfDoc.addPage([pageWidth, pageHeight]);
    
    const pngImage = await pdfDoc.embedPng(
        tempCanvas.toDataURL('image/png', 1.0)
    );
    
    page.drawImage(pngImage, {
        x: 0,
        y: 0,
        width: pageWidth,
        height: pageHeight
    });

    const pdfBytes = await pdfDoc.save({
        useObjectStreams: true,
        addDefaultPage: false,
        compress: true
    });

    // Download do PDF
    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');
    link.download = `CloudApp_${timestamp}.pdf`;
    link.click();
    URL.revokeObjectURL(url);
    
    tempFabricCanvas.dispose();
}

async function cloneObjectWithQuality(obj) {
    return new Promise(async (resolve) => {
        const clonedObj = fabric.util.object.clone(obj);

        // Remover bordas e contornos
        clonedObj.set({
            stroke: null, 
            strokeWidth: 0,
            shadow: null 
        });

        if (obj.type === 'image' && obj.getSrc) {
            const imgSrc = obj.getSrc();
            fabric.Image.fromURL(imgSrc, function(img) {
                img.set(clonedObj);
                resolve(img);
            }, {
                crossOrigin: 'anonymous',
                quality: 1.0
            });
        } else {
            resolve(clonedObj);
        }
    });
}

function cmToPoints(cm) {
    return cm * 28.3465;
}

// ----------------------------------------- Seção Inicio Drag and Drop ---------------------------------

function loadDocumentFile(file) {
    const reader = new FileReader();
    reader.onload = function(event) {
        const canvasState = JSON.parse(event.target.result);
        const cloudFolhaState = canvasState.cloudFolha;

        canvas.clear();

        canvas.loadFromJSON(canvasState, function () {
            let cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');

            if (!cloudFolha) {
                createCloudFolha();
                cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
            }

            if (cloudFolha && cloudFolhaState) {
                cloudFolha.set({
                    width: Number(cloudFolhaState.width) || 21 * CM_TO_PX, 
                    height: Number(cloudFolhaState.height) || 29.7 * CM_TO_PX,
                    left: Number(cloudFolhaState.left) || (canvas.width - cloudFolha.width) / 2,
                    top: Number(cloudFolhaState.top) || (canvas.height - cloudFolha.height) / 2
                });
                canvas.sendToBack(cloudFolha);
            }

            if (cloudFolha) {
                const widthCm = convertDimensions(cloudFolha.width, 'px', 'cm');
                const heightCm = convertDimensions(cloudFolha.height, 'px', 'cm');
                widthInput.value = widthCm.toFixed(1);
                heightInput.value = heightCm.toFixed(1);
            }

            canvas.renderAll();
            updateLayersList();
            saveState();
        });
    };
    reader.readAsText(file);
}

function handleDrop(e) {
    e.preventDefault();
    e.stopPropagation();

    // Verificar se o drop ocorreu dentro do canvas
    const canvasElement = document.getElementById('canvas');
    const rect = canvasElement.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    if (mouseX < 0 || mouseX > rect.width || mouseY < 0 || mouseY > rect.height) {
        return; // Ignorar o drop fora do canvas
    }

    const files = e.dataTransfer.files;
    if (!files || files.length === 0) {
        showCustomAlert('Nenhum arquivo foi detectado. Por favor, tente novamente.');
        return;
    }

    handleFiles(files);
}

function handleFiles(files) {
    Array.from(files).forEach(file => {
        if (file.type.startsWith('image/')) {
            handleImageFile(file);
        } else if (file.type === 'application/pdf') {
            handlePdfFile(file);
        } else if (file.name.endsWith('.cloudapp')) {
            loadDocumentFile(file); // Aqui a função é chamada
        } else {
            showCustomAlert('Arquivo não suportado. Por favor, insira imagens, PDFs ou arquivos .cloudapp.');
        }
    });
}

function handleImageFile(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        if (!canvas || !canvas.add) {
            showCustomAlert('Erro ao carregar a área de trabalho. Por favor, feche e abra o app..');
            return;
        }

        // Criar uma imagem temporária para obter dimensões originais
        const tempImg = new Image();
        tempImg.onload = function() {
            const originalWidth = this.width;
            const originalHeight = this.height;

            fabric.Image.fromURL(e.target.result, function(img) {
                if (!img) {
                    showCustomAlert('Falha ao carregar a imagem.');
                    return;
                }

                const canvasCenter = getCanvasCenter();
                
                // Configurar a imagem com alta qualidade
                img.set({
                    left: canvasCenter.left,
                    top: canvasCenter.top,
                    originX: 'center',
                    originY: 'center',
                    perPixelTargetFind: true,
                    lockMovementX: false,
                    lockMovementY: false,
                    scaleX: 1,
                    scaleY: 1,
                    width: originalWidth,
                    height: originalHeight
                });

                // Definir DPI para 300
                img.set('dpi', 300);

                try {
                    canvas.add(img);
                    canvas.setActiveObject(img);
                    canvas.renderAll();
                    saveState();
                } catch (error) {
                    showCustomAlert('Erro ao adicionar a imagem ao canvas.');
                }
            }, { crossOrigin: 'Anonymous' });
        };
        tempImg.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function handlePdfFile(file) {
    const modalHtml = `
        <div id="pdfModal" class="modal-overlay" style="display: flex;">
            <div class="modal-content" style="width: 600px; height: auto; padding: 20px; min-width: 300px; max-height: 80%; overflow-y: auto; display: flex;">
                <div id="pdfImageContainer" style="flex: 1; display: flex; justify-content: center; align-items: center; margin-right: 20px;">
                    <img id="pdfPageImage" src="" alt="PDF Page" style="max-width: 100%; max-height: 400px; border: 1px solid #ccc;">
                </div>
                <div style="flex: 1;">
                    <h3 style="color: white; margin-bottom: 20px;">Selecionar Página do PDF</h3>
                    <div style="margin-bottom: 20px;">
                        <input type="number" id="pdfPageInput" value="1" min="1"
                               style="width: 100%; padding: 8px; background: #1a4b8c; color: white; border: 1px solid #235ab4;">
                    </div>
                    <div style="display: flex; justify-content: flex-end; gap: 10px;">
                        <button id="pdfCancelBtn" class="menu-item" style="width: auto;">Cancelar</button>
                        <button id="pdfConfirmBtn" class="menu-item" style="width: auto; background: #ffd700; color: black;">Importar</button>
                    </div>
                </div>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', modalHtml);

    const modal = document.getElementById('pdfModal');
    const cancelBtn = document.getElementById('pdfCancelBtn');
    const confirmBtn = document.getElementById('pdfConfirmBtn');
    const pageInput = document.getElementById('pdfPageInput');
    const pdfPageImage = document.getElementById('pdfPageImage');

    // Evento para mudar a página
    pageInput.addEventListener('input', () => {
        const pageNumber = parseInt(pageInput.value) || 1;
        loadPdfPageImage(file, pageNumber - 1);
    });

    // Função para carregar a imagem da página do PDF
    async function loadPdfPageImage(file, pageNumber) {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        
        // Atualizar o máximo de páginas no input
        pageInput.max = pdf.numPages;

        if (pageNumber >= pdf.numPages) {
            showCustomAlert('Página não existente no PDF.');
            return;
        }

        const page = await pdf.getPage(pageNumber + 1);
        // Escala para preview
        const scale = 2;
        const viewport = page.getViewport({ scale });

        const tempCanvas = document.createElement('canvas');
        const context = tempCanvas.getContext('2d');
        tempCanvas.height = viewport.height;
        tempCanvas.width = viewport.width;

        // Configurar contexto para melhor qualidade mesmo no preview
        context.imageSmoothingEnabled = true;
        context.imageSmoothingQuality = 'high';

        await page.render({
            canvasContext: context,
            viewport: viewport
        }).promise;

        pdfPageImage.src = tempCanvas.toDataURL('image/png', 1.0);
    }

    // Carrega a primeira página ao abrir o modal
    loadPdfPageImage(file, 0);

    cancelBtn.addEventListener('click', () => {
        modal.remove();
    });

    confirmBtn.addEventListener('click', () => {
        const selectedPage = parseInt(pageInput.value) || 1;
        convertPdfToImage(file, selectedPage - 1).then(() => {
            modal.remove();
        });
    });
}

async function convertPdfToImage(file, pageNumber) {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;

    if (pageNumber >= pdf.numPages) {
        showCustomAlert('Página não existente no PDF.');
        return;
    }

    const page = await pdf.getPage(pageNumber + 1);
    // Aumentar a escala para 300 DPI (300/72 = 4.17)
    const scale = 4.17;
    const viewport = page.getViewport({ scale });

    const tempCanvas = document.createElement('canvas');
    const context = tempCanvas.getContext('2d');
    
    // Configurar o canvas com dimensões maiores para maior qualidade
    tempCanvas.height = viewport.height;
    tempCanvas.width = viewport.width;
    
    // Configurar contexto para melhor qualidade
    context.imageSmoothingEnabled = true;
    context.imageSmoothingQuality = 'high';

    await page.render({
        canvasContext: context,
        viewport: viewport
    }).promise;

    if (!canvas || !canvas.add) {
        showCustomAlert('Erro ao carregar a área de trabalho. Por favor, feche e abra o app..');
        return;
    }

    fabric.Image.fromURL(tempCanvas.toDataURL('image/png', 1.0), function(img) {
        if (!img) {
            showCustomAlert('Erro ao carregar páginas do PDF.');
            return;
        }

        const canvasCenter = getCanvasCenter();
        img.set({
            left: canvasCenter.left,
            top: canvasCenter.top,
            originX: 'center',
            originY: 'center',
            perPixelTargetFind: true,
            lockMovementX: false,
            lockMovementY: false,
            scaleX: 1,
            scaleY: 1
        });

        img.set('dpi', 300);

        try {
            canvas.add(img);
            canvas.setActiveObject(img);
            canvas.renderAll();
            saveState();
        } catch (error) {
            showCustomAlert('Erro ao adicionar a página do PDF na área de trabalho.');
        }
    });
}

function getCanvasCenter() {
    return {
        left: canvas.getWidth() / 2,
        top: canvas.getHeight() / 2
    };
}

document.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.stopPropagation();
});

document.addEventListener('drop', handleDrop);
// ---------- Fim Seção Drag and Drop -------------------------------------------

// ---------- Inicio Seção Modal Ferramenta links -------------------------------------------
function openDynamicModal(url) {
    const modal = document.getElementById('dynamicModal');
    const iframe = document.getElementById('dynamicIframe');

    iframe.src = url;
    modal.style.display = 'flex';
}

document.getElementById('closeDynamicModal').addEventListener('click', function () {
    const modal = document.getElementById('dynamicModal');
    modal.style.display = 'none';
});

document.getElementById('calendarBtn').addEventListener('click', function () {
    openDynamicModal('https://nkmplay.github.io/cgf/ferramentas/calend.html');
});
// ---------- Fim Seção Modal Ferramenta links -------------------------------------------

</script>
</body>
</html>
