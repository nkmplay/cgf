<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CloudPhoto</title>
<link rel="stylesheet" href="https://example.com/styles.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
<style>
  body {
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    height: 100vh;
    font-family: Arial, sans-serif;
    background-color: #151f28;
  }

  .main-container {
    display: flex;
    flex-grow: 1;
    overflow: hidden;
  }

  .top-menu {
    background-color: #2c3e50;
    padding: 5px 10px;
    display: flex;
    align-items: center;
    color: #ecf0f1;
  }

  .menu-buttons {
    display: flex;
    gap: 10px;
    margin-right: 20px;
  }

  .menu-button {
    background: none;
    border: none;
    color: #ecf0f1;
    padding: 5px 3px;
    cursor: pointer;
    border-radius: 3px;
    position: relative;
  }

  .menu-button:hover {
    background-color: #34495e;
  }

  .dropdown-toggle::after {
    content: " ▼";
    font-size: 0.6em;
  }

  .dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    background-color: #34495e;
    min-width: 150px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 1000;
  }

  .dropdown:hover .dropdown-menu {
    display: block;
  }

  .dropdown-menu button {
    width: 100%;
    text-align: left;
    background: none;
    border: none;
    color: #ecf0f1;
    padding: 10px;
    cursor: pointer;
    font-size: 14px;
  }

  .dropdown-menu button:hover {
    background-color: #3d566e;
  }

  .guide-option {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 5px 10px;
  }

  .guide-option button {
    flex: 1;
    padding: 5px;
    background: none;
    border: none;
    color: #ecf0f1;
    cursor: pointer;
    font-size: 14px;
  }

  .guide-option button:hover {
    background-color: #3d566e;
  }

  .guide-option input {
    flex: 1;
    padding: 3px;
    border: 1px solid #34495e;
    border-radius: 3px;
    background-color: #34495e;
    color: #ecf0f1;
  }

  .dimension-controls {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .dimension-input {
    width: 60px;
    padding: 3px;
    border: 1px solid #34495e;
    border-radius: 3px;
    background-color: #34495e;
    color: #ecf0f1;
  }

  .dimension-input:focus {
    outline: none;
    background-color: #3d566e;
  }

  .sidebar {
    width: 60px;
    background-color: #2c3e50;
    color: #ecf0f1;
    padding: 10px;
    box-sizing: border-box;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
  }

  .sidebar ul {
    list-style: none;
    padding: 0;
    margin: 0;
    flex-grow: 1;
  }

  .sidebar li {
    margin-bottom: 15px;
  }

  .sidebar button {
    width: 100%;
    padding: 5px;
    background-color: #34495e;
    color: #ecf0f1;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: background-color 0.3s ease;
    font-size: 8px;
    text-align: center;
  }

  .sidebar button svg {
    margin-bottom: 4px;
  }

  .sidebar button:hover {
    background-color: #3d566e;
  }

  #container {
    background-color: #e0e0e0;
    flex-grow: 1;
  }

  .layers-panel {
    width: 200px;
    background-color: #2c3e50;
    color: #ecf0f1;
    padding: 10px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    border-left: 1px solid #34495e;
  }

  .layers-title {
    font-size: 12px;
    font-weight: bold;
    padding: 5px;
    margin-bottom: 10px;
    border-bottom: 1px solid #34495e;
  }

  .layers-list {
    list-style: none;
    padding: 0;
    margin: 0;
    flex-grow: 1;
    overflow-y: auto;
  }

  .layer-item {
    padding: 8px;
    margin: 2px 0;
    background-color: #34495e;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    font-size: 12px;
    position: relative;
    transition: transform 0.2s, background-color 0.3s;
  }

  .layer-item.selected {
    background-color: #3498db;
  }

  .layer-item.dragging {
    opacity: 0.5;
    background-color: #2c3e50;
  }

  .layer-item.drag-over {
    border-top: 2px solid #3498db;
    transform: translateY(2px);
  }

  .layer-item.drag-over-bottom {
    border-bottom: 2px solid #3498db;
    transform: translateY(-2px);
  }

  .selection-rect {
    position: absolute;
    border: 1px solid #0099ff;
    background: rgba(0, 153, 255, 0.1);
    pointer-events: none;
  }

  textarea.text-edit {
    position: absolute;
    border: none;
    padding: 0px;
    margin: 0px;
    overflow: hidden;
    background: none;
    outline: none;
    resize: none;
    line-height: 1;
    font-family: Arial, sans-serif;
    font-size: 20px;
    color: #000;
  }

  .dropdown {
    position: relative;
  }

  .dropdown-toggle {
    background: none;
    border: none;
    color: #ecf0f1;
    padding: 5px 10px;
    cursor: pointer;
    border-radius: 3px;
  }

  .dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    background-color: #34495e;
    min-width: 150px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 1000;
  }

  .dropdown:hover .dropdown-menu {
    display: block;
  }

  .dropdown-menu button {
    width: 100%;
    text-align: left;
    background: none;
    border: none;
    color: #ecf0f1;
    padding: 10px;
    cursor: pointer;
  }

  .dropdown-menu button:hover {
    background-color: #3d566e;
  }

  .text-styling-controls {
    display: none;
    align-items: center;
    gap: 10px;
    margin-left: 20px;
  }

  select.dimension-input {
    padding: 3px;
    border: 1px solid #34495e;
    border-radius: 3px;
    background-color: #34495e;
    color: #ecf0f1;
  }

  input.dimension-input[type="color"] {
    padding: 3px;
    border: 1px solid #34495e;
    border-radius: 3px;
    background-color: #34495e;
    color: #ecf0f1;
  }

  /* New Styles for Guide Interval Options */
  .guide-interval {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 5px 10px;
  }

  .guide-interval label {
    flex: 1;
    font-size: 14px;
  }

  .guide-interval input {
    flex: 1;
    padding: 3px;
    border: 1px solid #34495e;
    border-radius: 3px;
    background-color: #34495e;
    color: #ecf0f1;
  }

  .guide-interval input:focus {
    outline: none;
    background-color: #3d566e;
  }
	#swap-dimensions {
	  background-color: #5b738a;
	  padding: 5px 10px;
	  cursor: pointer;
	  border-radius: 4px;
	}

	#swap-dimensions:hover {
	  background-color: #1e2d3c;
	}  
	.text-styling-controls span {
	  white-space: nowrap;
	  margin-left: 10px;
	}
	#customAlertModal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}

.alert-content {
    background: #0f3460;
    padding: 20px;
    border-radius: 8px;
    min-width: 300px;
    border: 2px solid #4a90e2;
}

#customAlertMessage {
    color: white;
    text-align: center;
}
.tool-button {
  background-color: #0f3460;
  color: #fff;
  border: 2px solid #4a90e2;
  padding: 8px 8px;
  border-radius: 4px;
  width: 100%;
  cursor: pointer;
  font-size: 9px;
  font-weight: 700;
  height: 50px;
  margin: 5px 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 10px;
}

.tool-button i {
  font-size: 12px;
}

.tool-button.selected {
  background-color: #4a90e2;
}
.dropdown-menu .dropdown-menu {
  left: 100%;
  top: 0;
  margin-left: 1px;
}

.dropdown-menu .dropdown-toggle::after {
  content: " ▶";
  font-size: 0.6em;
}
.hidden-canvas {
  display: none;
  position: absolute;
  left: -9999px;
}
.imagem-dropdown-menu {
  width: 200px;
}
.ajustes-dropdown-menu {
  width: 300px; 
}
.guias-dropdown-menu {
  width: 300px; /* Ajuste a largura conforme necessário */
}

.guide-input {
  width: 30px; 
  padding: 3px;
  border: 1px solid #34495e;
  border-radius: 3px;
  background-color: #34495e;
  color: #ecf0f1;
}

.guide-option, .guide-interval {
  display: flex;
  align-items: center;
  gap: 10px; /* Ajuste o espaço entre os elementos conforme necessário */
  padding: 5px 10px;
}

.guide-option button, .guide-interval label {
  flex: 1;
  font-size: 14px;
}
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  justify-content: center;
  align-items: center;
  z-index: 10000;
}

.modal-content {
  width: 800px;
  height: 600px;
  background-color: #2c3e50;
  border-radius: 8px;
  display: flex;
  overflow: hidden;
}

.modal-buttons {
    display: flex;
    justify-content: space-between; /* Distribui os botões uniformemente */
    margin-top: auto; /* Faz com que os botões fiquem na parte inferior do modal */
    padding: 10px; /* Adiciona um pouco de espaço ao redor dos botões */
}

.image-container {
  width: 600px;
  height: 600px;
  background-color: #1e2d3c;
  display: flex;
  justify-content: center;
  align-items: center;
}

#previewCanvas {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.controls-container {
  width: 200px;
  height: 600px;
  padding: 20px;
  background-color: #34495e;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.control-group label {
  color: #ecf0f1;
  font-size: 14px;
}

.control-group input[type="number"] {
  width: 100%;
  padding: 5px;
  border: 1px solid #2c3e50;
  border-radius: 4px;
  background-color: #2c3e50;
  color: #ecf0f1;
}

.control-group input[type="range"] {
  width: 100%;
}

.buttons {
  display: flex;
  gap: 10px;
  margin-top: auto;
}

.buttons button {
  flex: 1;
  padding: 10px;
  border: none;
  border-radius: 4px;
  background-color: #3498db;
  color: #ecf0f1;
  cursor: pointer;
}

.buttons button:hover {
  background-color: #2980b9;
}
.dropdown-menu .dropdown-menu {
  left: 100%;
  top: 0;
  margin-left: 1px;
}

.dropdown-menu .dropdown-toggle::after {
  content: " ▶";
  font-size: 0.6em;
}

.dropdown-menu .dpi-option {
  display: flex;
  align-items: center;
  gap: 5px;
}

.dropdown-menu .dpi-option label {
  font-size: 14px;
  color: #ecf0f1;
}

.dropdown-menu .dpi-option input {
  width: 60px;
  padding: 5px;
  border: 1px solid #34495e;
  border-radius: 3px;
  background-color: #34495e;
  color: #ecf0f1;
}

.dropdown-menu .dpi-option input:focus {
  outline: none;
  background-color: #3d566e;
}
.dropdown-menu .export-option {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px; 
}
.dropdown-menu .export-option button {
  flex: 1;
  padding: 8px 12px;
  background-color: #34495e;
  border: none;
  color: #ecf0f1;
  cursor: pointer;
  border-radius: 3px;
  text-align: left;
  font-size: 14px;
}
.dropdown-menu .export-option button:hover {
  background-color: #3d566e;
}
.dropdown-menu .export-submenu {
  width: 300px; 
  padding: 10px; 
}
.dropdown-menu .dropdown .dropdown-menu {
  display: none; 
  position: absolute;
  left: 100%; 
  top: 0;
  margin-left: 1px;
  background-color: #34495e;
  border-radius: 3px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  z-index: 1000;
}
.dropdown-menu .dropdown:hover .dropdown-menu {
  display: block;
}
.general-controls {
  margin-top: 10px;
  display: none; 
}

.general-controls label {
  margin-right: 5px;
}

.general-controls input {
  width: 50px;
}

.general-controls button {
  margin-left: 5px;
  padding: 5px 10px;
  border: none;
  border-radius: 4px;
  background-color: #007bff;
  color: white;
  cursor: pointer;
}

.general-controls button:hover {
  background-color: #0056b3;
}
@media print {
  @page {
    margin: 0;
  }
  body {
    margin: 0;
    padding: 0;
  }
  #print-container img {
    width: 100vw;
    height: 100vh;
    object-fit: contain;
  }
}

</style>
</head>
<body>
  <div class="top-menu">
    <div class="menu-buttons">
	
<div class="menu-button dropdown">
  <button class="dropdown-toggle">Arquivo</button>
  <div class="dropdown-menu">
	<button id="openImagePDFBtn">Abrir Imagem | PDF </button>
    <button id="openDocumentBtn">Abrir Documento</button>
	<button id="separar">▬▬▬▬▬▬▬▬▬▬▬▬</button>
    <button id="saveDocumentBtn">Salvar Documento</button>
	<button id="separar">▬▬▬▬▬▬▬▬▬▬▬▬</button>
    <div class="dropdown">
      <button class="dropdown-toggle">Exportar</button>
      <div class="dropdown-menu export-submenu">
        <div class="export-option">
          <button id="export-png">Exportar como PNG</button>
          <div class="dpi-option">
            <label for="dpi-input">DPI:</label>
            <input type="number" id="dpi-input" value="300" min="72" max="1200">
          </div>
        </div>
		<div class="export-option">
          <button id="export-JPG">Exportar como JPG</button>
          <div class="dpi-option">
            <label for="dpijpg-input">DPI:</label>
            <input type="number" id="dpijpg-input" value="300" min="72" max="1200">
          </div>
        </div>
		<div class="export-option">
          <button id="export-PDF">Exportar como PDF</button>
          <div class="dpi-option">
            <label for="dpipdf-input">DPI:</label>
            <input type="number" id="dpipdf-input" value="300" min="72" max="1200">
          </div>
        </div>
      </div>
    </div>
	<div class="dropdown">
      <button class="dropdown-toggle">Importar</button>
      <div class="dropdown-menu export-submenu">
        <div class="export-option">
          <button id="import-svg">Importar SVG</button>
        </div>
      </div>
    </div>
	
	<button id="separar">▬▬▬▬▬▬▬▬▬▬▬▬</button>
    <button id="print-button">Imprimir</button>
  </div>
</div>
	  
      <div class="menu-button dropdown">
		  <button class="dropdown-toggle">Editar</button>
		  <div class="dropdown-menu">
			<button id="duplicate-selected">Duplicar Objeto Selecionado</button>
			<button id="delete-selected">Excluir Objeto Selecionado</button>
			<button id="select-all">Selecionar Tudo</button>
			<button id="remove-selection">Remover Seleção</button>
			<button id="paste">Colar</button>
			<div class="guide-option">
			  <button id="organize-objects">Organizar:</button>
			  <input type="number" id="spacing-input" placeholder="cm" min="0" step="0.1" value="0.2">
			</div>
		  </div>
		</div>
		
		<div class="menu-button dropdown">
		  <button class="dropdown-toggle">Imagem</button>
		  <div class="dropdown-menu imagem-dropdown-menu">
			<button class="dropdown-toggle">Ajustes </button>
			<div class="dropdown-menu ajustes-dropdown-menu">
			  <button id="Btn-BrilhoContraste">Brilho | Contraste | Saturação | Matiz </button>
			  <button id="Btn-Nitidez">Adicionar Nitidez</button>
			  <button id="Btn-InverterCor">Inverter Cor</button>
			  <button id="Btn-PretoBranco">Preto e Branco</button>
			</div>
			<button id="separar">▬▬▬▬▬▬▬▬▬▬▬▬</button>
			<button id="BtnContrasteAutm">✦ Contraste Automático</button>
			<button id="BtnCorAutm">✦ Cor Automática</button>
			<button id="BtnTomAutm">✦Tom Automático</button>
			<button id="separar">▬▬▬▬▬▬▬▬▬▬▬▬</button>
		  </div>
		</div>

		<div class="menu-button dropdown">
		  <button class="dropdown-toggle">Guias</button>
		  <div class="dropdown-menu guias-dropdown-menu">
			<button id="add-guides">Adicionar Guias Padrão</button>
			<div class="guide-option">
			  <button id="add-vertical-guide">Guia Vertical</button>
			  <input type="number" id="vertical-guide-cm" class="guide-input" placeholder="cm" min="0">
			</div>
			<div class="guide-option">
			  <button id="add-horizontal-guide">Guia Horizontal</button>
			  <input type="number" id="horizontal-guide-cm" class="guide-input" placeholder="cm" min="0">
			</div>
			<div class="guide-interval">
			  <label for="horizontal-interval">Horizontal a cada:</label>
			  <input type="number" id="horizontal-interval" class="guide-input" placeholder="cm" min="0">
			</div>
			<div class="guide-interval">
			  <label for="vertical-interval">Vertical a cada:</label>
			  <input type="number" id="vertical-interval" class="guide-input" placeholder="cm" min="0">
			</div>
			<button id="delete-all-guides">Apagar Todas as Guias</button>
		  </div>
		</div>
	  
	  <div class="menu-button dropdown">
		  <button class="dropdown-toggle">Texto</button>
		  <div class="dropdown-menu">
			<button id="split-text">Dividir Texto em 2</button>
		  </div>
		</div>
	  
      <div class="menu-button dropdown">
		  <button class="dropdown-toggle">Formas</button>
		  <div class="dropdown-menu">
			<button class="dropdown-toggle">Inserir </button>
			<div class="dropdown-menu">
			  <button id="insert-square">Quadrado</button>
			  <button id="insert-circle">Circulo</button>
			  <button id="insert-triangle">Triangulo</button>
			  <button id="insert-line">Linha</button>
			</div>
		  </div>
		</div>
		
    </div>
    <div class="dimension-controls">
      <span>&#x2194;</span>
      <input type="number" id="width-input" class="dimension-input" step="0.1" placeholder="L (cm)">
      <button id="swap-dimensions" class="menu-button">&#x21c5;</button>
      <span>&#x2195;</span>
      <input type="number" id="height-input" class="dimension-input" step="0.1" placeholder="A (cm)">
      <button id="lock-ratio" class="menu-button">&#x1f513;</button>
    </div>
    <div class="text-styling-controls">
      <select id="font-select" class="dimension-input">
			<option value="Arial" style="font-family: Arial;">Arial</option>
			<option value="Amarillo" style="font-family: Amarillo;">Amarillo</option>
			<option value="Catalish Huntera" style="font-family: 'Catalish Huntera';">Catalish Huntera</option>
			<option value="Cream Cake" style="font-family: 'Cream Cake';">Cream Cake</option>
			<option value="Daily" style="font-family: Daily;">Daily</option>
			<option value="GROBOLD" style="font-family: GROBOLD;">GROBOLD</option>
			<option value="Lobster 1.4" style="font-family: 'Lobster 1.4';">Lobster 1.4</option>
			<option value="Love" style="font-family: Love;">Love</option>
			<option value="josephsophia" style="font-family: josephsophia;">josephsophia</option>
			<option value="Arial Black" style="font-family: 'Arial Black';">Arial Black</option>
			<option value="Brush Script MT" style="font-family: 'Brush Script MT';">Brush Script MT</option>
			<option value="Bookman Old Style" style="font-family: 'Bookman Old Style';">Bookman Old Style</option>
			<option value="Comic Sans MS" style="font-family: 'Comic Sans MS';">Comic Sans MS</option>
			<option value="Courier" style="font-family: Courier;">Courier</option>
			<option value="Dancing Script" style="font-family: 'Dancing Script';">Dancing Script</option>
			<option value="Impact" style="font-family: Impact;">Impact</option>
			<option value="Lucida Handwriting" style="font-family: 'Lucida Handwriting';">Lucida Handwriting</option>
			<option value="Lucida Sans Unicode" style="font-family: 'Lucida Sans Unicode';">Lucida Sans Unicode</option>
			<option value="Papyrus" style="font-family: Papyrus;">Papyrus</option>
			<option value="Segoe Print" style="font-family: 'Segoe Print';">Segoe Print</option>
			<option value="Segoe Script" style="font-family: 'Segoe Script';">Segoe Script</option>
			<option value="Times New Roman" style="font-family: 'Times New Roman';">Times New Roman</option>
			<option value="Trebuchet MS" style="font-family: 'Trebuchet MS';">Trebuchet MS</option>
			<option value="Verdana" style="font-family: Verdana;">Verdana</option>
			<option value="Monotype Corsiva" style="font-family: 'Monotype Corsiva';">Monotype Corsiva</option>
			<option value="Mistral" style="font-family: Mistral;">Mistral</option>
			<option value="Freestyle Script" style="font-family: 'Freestyle Script';">Freestyle Script</option>
			<option value="Bradley Hand ITC" style="font-family: 'Bradley Hand ITC';">Bradley Hand ITC</option>
			<option value="Edwardian Script ITC" style="font-family: 'Edwardian Script ITC';">Edwardian Script ITC</option>
			<option value="Vivaldi" style="font-family: Vivaldi;">Vivaldi</option>
			<option value="Rage Italic" style="font-family: 'Rage Italic';">Rage Italic</option>
      </select>
      <input type="color" id="text-color-picker" class="dimension-input">
      <input type="number" id="font-size-input" class="dimension-input" min="8" max="72" value="20">
	  <span style="color: #ecf0f1; font-size: 14px;">Contorno:</span>
	  <input type="number" id="stroke-width-input" class="dimension-input" min="0" value="0">
	  <input type="color" id="stroke-color-picker" class="dimension-input" value="#000000">
    </div>
		<div class="general-controls" style="display: none;">
		  <label for="opacity-input">Opac.:</label>
		  <input type="number" id="opacity-input" class="dimension-input" min="1" max="100" step="1">
		  <button id="export-png-selected">PNG</button>
		</div>
  </div>
  <div class="main-container">
    <div class="sidebar">
      <ul>
        <li>
          <button id="insert-image">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M21 19V5H3V19H21Z" stroke="currentColor" stroke-width="2" fill="none"/>
              <circle cx="8.5" cy="12.5" r="2.5" stroke="currentColor" stroke-width="2" fill="none"/>
              <path d="M21 19L16 14L12 18L8 14L3 19" stroke="currentColor" stroke-width="2" fill="none"/>
            </svg>
            Imagem
          </button>
          <input type="file" id="image-upload" accept="image/*" multiple style="display: none;">
        </li>
        <li>
          <button id="insert-text">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M4 4H20V20H4V4Z" stroke="currentColor" stroke-width="2" fill="none"/>
              <text x="12" y="16" text-anchor="middle" fill="currentColor" font-size="12">T</text>
            </svg>
            Texto
          </button>
        </li>
		<li>
		  <button id="selectBtn">
			  <span style="font-size: 24px;">⿴</span> Seleção
			</button>
		</li>
		
		<li>
      <button id="crop-button">
		  <span style="font-size: 24px;">✂</span> Recortar
		</button>
    </li>
		
      </ul>
    </div>
    <canvas id="canvas"></canvas>
    <div class="layers-panel">
      <div class="layers-title">Camadas</div>
      <ul class="layers-list"></ul>
    </div>
  </div>
  
  <div id="customAlertModal" style="display: none;">
	  <div class="alert-content">
		<div id="customAlertMessage"></div>
	  </div>
	</div>
	
	<!-- Modal para Ajustes de Brilho, Contraste, Saturação e Matiz -->
<div id="brightnessContrastModal" class="modal">
  <div class="modal-content">
    <div class="image-container">
      <canvas id="previewCanvas"></canvas>
    </div>
    <div class="controls-container">
      <div class="control-group">
        <label for="brightness">Brilho:</label>
        <input type="number" id="brightness" value="0" min="-100" max="100">
        <input type="range" id="brightnessRange" min="-100" max="100" value="0">
      </div>
      <div class="control-group">
        <label for="contrast">Contraste:</label>
        <input type="number" id="contrast" value="0" min="-100" max="100">
        <input type="range" id="contrastRange" min="-100" max="100" value="0">
      </div>
      <div class="control-group">
        <label for="saturation">Saturação:</label>
        <input type="number" id="saturation" value="0" min="-100" max="100">
        <input type="range" id="saturationRange" min="-100" max="100" value="0">
      </div>
      <div class="control-group">
        <label for="hue">Matiz:</label>
        <input type="number" id="hue" value="0" min="-180" max="180">
        <input type="range" id="hueRange" min="-180" max="180" value="0">
      </div>
      <div class="control-group">
        <button id="saveAdjustments">Salvar</button>
        <button id="cancelAdjustments">Cancelar</button>
      </div>
    </div>
  </div>
</div>




	
	<canvas id="hiddenCanvas" class="hidden-canvas"></canvas>
	
<script src="https://nkmplay.github.io/cgf/ferramentas/modalselect.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // ---------- Configurações Iniciais -------------------------------------------
      const sidebarWidth = 60;
      const layersPanelWidth = 200;
      const topMenuHeight = document.querySelector('.top-menu').offsetHeight;
      const ROTATION_SNAP_ANGLE = 15;
      const canvasElement = document.getElementById('canvas');
      const canvas = new fabric.Canvas('canvas', {
        width: window.innerWidth - sidebarWidth - layersPanelWidth,
        height: window.innerHeight - topMenuHeight,
        selection: true,
        preserveObjectStacking: true,
        rotationCursor: 'crosshair',
        snapAngle: ROTATION_SNAP_ANGLE * (Math.PI / 180)
      });

      const cmToPx = 37.795275591;
      const a4Width = 21 * cmToPx;
      const a4Height = 29.7 * cmToPx;
      const initialScale = 0.7;

      let objectIdCounter = 0;
      let imageCounter = 1;
      let clipboardData = null;
	  
	  let isOrganizing = false;
	  
	  
      // ---------- Função para Adicionar Objetos com ID Único -------------------------------------------
      function addObject(obj) {
        obj.id = objectIdCounter++;
        canvas.add(obj);
      }

      // ---------- Criação do Objeto CloudFolha -------------------------------------------
      const cloudFolha = new fabric.Rect({
        width: a4Width,
        height: a4Height,
        left: (canvas.getWidth() / 2) - (a4Width / 2) - 250,
        top: (canvas.getHeight() / 2) - (a4Height / 2) + 100,
        fill: 'white',
        stroke: '#ccc',
        strokeWidth: 1,
        selectable: false,
        name: 'CloudFolha'
      });

      cloudFolha.set({
        hoverCursor: 'default'
      });

      addObject(cloudFolha);
      canvas.sendToBack(cloudFolha);

      canvas.setZoom(initialScale);
      canvas.absolutePan({
        x: -((canvas.getWidth() - a4Width * initialScale) / 2),
        y: -((canvas.getHeight() - a4Height * initialScale) / 2)
      });
	  
	  // ---------- evento da ferramenta de seleção -----------------------------------
document.getElementById('selectBtn').addEventListener('click', function () {
    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type === 'image') {
        initSelectModal(canvas);
    } else {
        showCustomAlert('Selecione uma imagem antes de usar a ferramenta de seleção.');
    }
});	  
	  
	  
      // ---------- Eventos de Zoom e Panning -------------------------------------------
      canvas.on('mouse:wheel', opt => {
		if (isOrganizing) {
			opt.e.preventDefault();
			opt.e.stopPropagation();
			return;
		}

		const delta = opt.e.deltaY;
		let zoom = canvas.getZoom();
		zoom *= 0.999 ** delta;
		zoom = Math.min(Math.max(0.1, zoom), 4);
		const point = new fabric.Point(opt.e.offsetX, opt.e.offsetY);
		canvas.zoomToPoint(point, zoom);
		opt.e.preventDefault();
		opt.e.stopPropagation();
	});

      canvas.on('mouse:down', opt => {
        const evt = opt.e;
        if (evt.altKey === true) {
          canvas.isDragging = true;
          canvas.selection = false;
          canvas.lastPosX = evt.clientX;
          canvas.lastPosY = evt.clientY;
        }
      });

      canvas.on('mouse:move', opt => {
        if (canvas.isDragging) {
          const e = opt.e;
          const vpt = canvas.viewportTransform;
          vpt[4] += e.clientX - canvas.lastPosX;
          vpt[5] += e.clientY - canvas.lastPosY;
          canvas.requestRenderAll();
          canvas.lastPosX = e.clientX;
          canvas.lastPosY = e.clientY;
        }
      });

      canvas.on('mouse:up', () => {
        canvas.setViewportTransform(canvas.viewportTransform);
        canvas.isDragging = false;
        canvas.selection = true;
      });

      // ---------- Eventos de Rotação e Escala -------------------------------------------
      canvas.on('object:rotating', opt => {
        const target = opt.target;
        target.set({
          angle: Math.round(target.angle / ROTATION_SNAP_ANGLE) * ROTATION_SNAP_ANGLE
        });
      });

      canvas.on('object:modified', opt => {
        updateDimensionInputs();
      });

      canvas.on('object:scaling', opt => {
        const obj = opt.target;
        if (obj.type === 'i-text') {
          const fontSizeInput = document.getElementById('font-size-input');
          const newFontSize = Math.round(obj.fontSize * obj.scaleX);
          fontSizeInput.value = newFontSize;
          obj.set({
            fontSize: newFontSize,
            scaleX: 1,
            scaleY: 1
          });
          const pxToCm = 1 / cmToPx;
          const widthInput = document.getElementById('width-input');
          const heightInput = document.getElementById('height-input');
          widthInput.value = (obj.width * pxToCm).toFixed(1);
          heightInput.value = (obj.height * pxToCm).toFixed(1);
        }
        const pxToCm = 1 / cmToPx;
        const widthInput = document.getElementById('width-input');
        const heightInput = document.getElementById('height-input');
        widthInput.value = (obj.width * obj.scaleX * pxToCm).toFixed(1);
        heightInput.value = (obj.height * obj.scaleY * pxToCm).toFixed(1);
      });

      // ---------- Eventos de Seleção -------------------------------------------
      canvas.on('selection:created', () => {
        updateDimensionInputs();
        updateLayersList();
        updateTextStylingControls();
      });

      canvas.on('selection:updated', () => {
        updateDimensionInputs();
        updateLayersList();
        updateTextStylingControls();
      });

      canvas.on('selection:cleared', () => {
        updateDimensionInputs();
        updateLayersList();
        const textStylingControls = document.querySelector('.text-styling-controls');
        textStylingControls.style.display = 'none';
      });

      // ---------- Inserção de Imagens -------------------------------------------
      document.getElementById('insert-image').addEventListener('click', () => {
        document.getElementById('image-upload').click();
      });

      document.getElementById('image-upload').addEventListener('change', e => {
        const files = e.target.files;
        for (let file of files) {
          const reader = new FileReader();
          reader.onload = f => {
            fabric.Image.fromURL(f.target.result, img => {
              img.set({
                left: cloudFolha.left + cloudFolha.width / 2,
                top: cloudFolha.top + cloudFolha.height / 2,
                originX: 'center',
                originY: 'center'
              });
              if (file.name) {
                img.fileName = file.name;
              } else {
                img.fileName = `Imagem - imagem${imageCounter++}`;
              }
              addObject(img);
              canvas.setActiveObject(img);
              updateLayersList();
            });
          };
          reader.readAsDataURL(file);
        }
      });

      // ---------- Atualização dos Inputs de Dimensão -------------------------------------------
      function updateDimensionInputs() {
        const pxToCm = 1 / cmToPx;
        const widthInput = document.getElementById('width-input');
        const heightInput = document.getElementById('height-input');

        const activeObjects = canvas.getActiveObjects();
        if (activeObjects.length === 0) {
          widthInput.value = (cloudFolha.width * pxToCm).toFixed(1);
          heightInput.value = (cloudFolha.height * pxToCm).toFixed(1);
          return;
        }

        if (activeObjects.length === 1) {
          const activeObj = activeObjects[0];
          let width = activeObj.width * activeObj.scaleX;
          let height = activeObj.height * activeObj.scaleY;

          if (activeObj.type === 'i-text') {
            const fontSizeInput = document.getElementById('font-size-input');
            widthInput.value = (activeObj.width * pxToCm).toFixed(1);
            heightInput.value = (activeObj.height * pxToCm).toFixed(1);
            fontSizeInput.value = Math.round(activeObj.fontSize * activeObj.scaleX) || 20;
          } else {
            widthInput.value = (width * pxToCm).toFixed(1);
            heightInput.value = (height * pxToCm).toFixed(1);
          }
        } else {
          widthInput.value = '';
          heightInput.value = '';
        }
      }

      // ---------- Eventos de Alteração de Dimensão -------------------------------------------
document.getElementById('width-input').addEventListener('change', e => {
    const newWidthCm = parseFloat(e.target.value);
    const activeObjects = canvas.getActiveObjects();

    if (activeObjects.length > 0) {
        activeObjects.forEach(obj => {
            if (obj.name && obj.name.startsWith('Guia')) {
                return;
            }
            const newWidth = newWidthCm * cmToPx;
            obj.scaleX = newWidth / obj.width;
            if (isRatioLocked) {
                obj.scaleY = obj.scaleX;
            }
            if (obj.type === 'i-text') {
                const fontSizeInput = document.getElementById('font-size-input');
                fontSizeInput.value = Math.round(obj.fontSize * obj.scaleX);
            }
            obj.setCoords();
        });
    } else {
        const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
        if (cloudFolha) {
            const newWidth = newWidthCm * cmToPx;
            cloudFolha.set('width', newWidth);
            cloudFolha.setCoords();
        }
    }

    canvas.requestRenderAll();
    updateLayersList();
});

document.getElementById('height-input').addEventListener('change', e => {
    const newHeightCm = parseFloat(e.target.value);
    const activeObjects = canvas.getActiveObjects();

    if (activeObjects.length > 0) {
        activeObjects.forEach(obj => {
            if (obj.name && obj.name.startsWith('Guia')) {
                return;
            }
            const newHeight = newHeightCm * cmToPx;
            obj.scaleY = newHeight / obj.height;
            if (isRatioLocked) {
                obj.scaleX = obj.scaleY;
            }
            if (obj.type === 'i-text') {
                const fontSizeInput = document.getElementById('font-size-input');
                fontSizeInput.value = Math.round(obj.fontSize * obj.scaleX);
            }
            obj.setCoords();
        });
    } else {
        const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
        if (cloudFolha) {
            const newHeight = newHeightCm * cmToPx;
            cloudFolha.set('height', newHeight);
            cloudFolha.setCoords();
        }
    }

    canvas.requestRenderAll();
    updateLayersList();
});
	  
	   // ---------- alerta personalizado -------------------------------------------
		function showCustomAlert(message) {
		  const modal = document.getElementById('customAlertModal');
		  const messageElement = document.getElementById('customAlertMessage');
		  messageElement.textContent = message;
		  modal.style.display = 'flex';
		}

		function closeCustomAlert() {
		  const modal = document.getElementById('customAlertModal');
		  modal.style.display = 'none';
		}

		document.getElementById('customAlertModal').addEventListener('click', function (e) {
		  if (e.target === this) {
			closeCustomAlert();
		  }
		});

      // ---------- Bloqueio de Proporção e troca de dimensão -------------------------------------------
      document.getElementById('swap-dimensions').addEventListener('click', () => {
        const widthInput = document.getElementById('width-input');
        const heightInput = document.getElementById('height-input');
        
        const tempWidth = widthInput.value;
        const tempHeight = heightInput.value;
        
        widthInput.value = tempHeight;
        heightInput.value = tempWidth;
        
        const activeObjects = canvas.getActiveObjects();
        if (activeObjects.length > 0) {
          activeObjects.forEach(obj => {
            if (obj.name && obj.name.startsWith('Guia')) {
              return;
            }
            const newWidth = parseFloat(widthInput.value) * cmToPx;
            const newHeight = parseFloat(heightInput.value) * cmToPx;
            
            obj.set({
              scaleX: newWidth / obj.width,
              scaleY: newHeight / obj.height
            });
            obj.setCoords();
          });
        } else {
          const newWidth = parseFloat(widthInput.value) * cmToPx;
          const newHeight = parseFloat(heightInput.value) * cmToPx;
          
          cloudFolha.set({
            width: newWidth,
            height: newHeight
          });
          
          cloudFolha.set({
            left: (canvas.getWidth() / 2) - (cloudFolha.width / 2) - 250,
            top: (canvas.getHeight() / 2) - (cloudFolha.height / 2) + 100
          });
          
          cloudFolha.setCoords(); 
        }
        
        canvas.requestRenderAll();
        updateLayersList();
      });

      let isRatioLocked = false;
      document.getElementById('lock-ratio').addEventListener('click', () => {
        isRatioLocked = !isRatioLocked;
        document.getElementById('lock-ratio').textContent = isRatioLocked ? '🔒' : '🔓';
      });

      // ---------- Atualização da Lista de Camadas -------------------------------------------
      function updateLayersList() {
    const layersList = document.querySelector('.layers-list');
    layersList.innerHTML = '';
    const objects = canvas.getObjects().filter(obj => obj.name !== 'CloudFolha'); // Ignora o CloudFolha

    const orderedObjects = [...objects].reverse();

    orderedObjects.forEach((obj, index) => {
        const li = document.createElement('li');
        li.className = 'layer-item';
        li.setAttribute('data-id', obj.id);
        li.draggable = true;

        if (canvas.getActiveObjects().includes(obj)) {
            li.classList.add('selected');
        }

        if (obj.type === 'i-text') {
            const textSnippet = obj.text ? obj.text.substring(0, 10) : '';
            li.textContent = `Texto - ${textSnippet}`;
        } else if (obj.type === 'image') {
            const fileName = obj.fileName ? obj.fileName.substring(0, 10) : `Imagem - imagem${imageCounter++}`;
            li.textContent = `Imagem - ${fileName}`;
        } else if (obj.type === 'line' && obj.name && obj.name.includes('Guia')) {
            li.textContent = obj.name;
        } else {
            li.textContent = `Objeto - ${index + 1}`;
        }

        li.addEventListener('click', (e) => {
            const isShiftPressed = e.shiftKey;
            if (isShiftPressed) {
                const activeObjects = canvas.getActiveObjects();
                if (activeObjects.includes(obj)) {
                    const newActive = activeObjects.filter(o => o !== obj);
                    canvas.discardActiveObject();
                    if (newActive.length > 0) {
                        const activeSelection = new fabric.ActiveSelection(newActive, { canvas: canvas });
                        canvas.setActiveObject(activeSelection);
                    }
                } else {
                    const newActive = activeObjects.concat(obj);
                    const activeSelection = new fabric.ActiveSelection(newActive, { canvas: canvas });
                    canvas.setActiveObject(activeSelection);
                }
            } else {
                canvas.discardActiveObject();
                canvas.setActiveObject(obj);
            }
            canvas.requestRenderAll();
        });
        layersList.appendChild(li);
    });

    // Inicializa Sortable.js se ainda não estiver inicializado
    if (!layersList.sortable) {
        Sortable.create(layersList, {
            animation: 150,
            onEnd: function (evt) {
                const layers = layersList.querySelectorAll('.layer-item');
                const newOrder = Array.from(layers).map(li => parseInt(li.getAttribute('data-id')));

                newOrder.forEach((id, index) => {
                    const obj = canvas.getObjects().find(obj => obj.id === id);
                    if (obj) {
                        canvas.moveTo(obj, canvas.getObjects().length - index - 1);
                    }
                });

                canvas.requestRenderAll();
                updateLayersList();
            },
        });
        layersList.sortable = true;
    }
}

      // ---------- Inserção de Texto -------------------------------------------
      document.getElementById('insert-text').addEventListener('click', () => {
        const text = new fabric.IText('Texto', {
          left: cloudFolha.left + cloudFolha.width / 2,
          top: cloudFolha.top + cloudFolha.height / 2,
          originX: 'center',
          originY: 'center',
          fontSize: 20,
		  strokeWidth: 0,
		  paintFirst: 'stroke'
        });
        addObject(text);
        canvas.setActiveObject(text);
        updateLayersList();
      });

      // ---------- Atualização do Estilo do Texto -------------------------------------------
      function updateTextStylingControls() {
  const activeObjects = canvas.getActiveObjects();
  const textStylingControls = document.querySelector('.text-styling-controls');
  
  if (activeObjects.length === 1 && activeObjects[0].type === 'i-text') {
    const activeObj = activeObjects[0];
    textStylingControls.style.display = 'flex';
    
    // Elementos existentes
    const fontSelect = document.getElementById('font-select');
    const textColorPicker = document.getElementById('text-color-picker');
    const fontSizeInput = document.getElementById('font-size-input');
    
    // Novos elementos de contorno
    const strokeWidthInput = document.getElementById('stroke-width-input');
    const strokeColorPicker = document.getElementById('stroke-color-picker');

    // Atualizar valores dos controles
    fontSelect.value = activeObj.fontFamily || 'Arial';
    textColorPicker.value = activeObj.fill || '#000000';
    fontSizeInput.value = Math.round(activeObj.fontSize * activeObj.scaleX) || 20;
    strokeWidthInput.value = activeObj.strokeWidth || 0;
    strokeColorPicker.value = activeObj.stroke || '#000000';

    // Substituir elementos para evitar múltiplos listeners
    const newFontSelect = fontSelect.cloneNode(true);
    const newTextColorPicker = textColorPicker.cloneNode(true);
    const newFontSizeInput = fontSizeInput.cloneNode(true);
    const newStrokeWidthInput = strokeWidthInput.cloneNode(true);
    const newStrokeColorPicker = strokeColorPicker.cloneNode(true);

    fontSelect.replaceWith(newFontSelect);
    textColorPicker.replaceWith(newTextColorPicker);
    fontSizeInput.replaceWith(newFontSizeInput);
    strokeWidthInput.replaceWith(newStrokeWidthInput);
    strokeColorPicker.replaceWith(newStrokeColorPicker);

    // Adicionar listeners
    newFontSelect.addEventListener('change', updateTextStyle);
    newTextColorPicker.addEventListener('input', updateTextStyle);
    newFontSizeInput.addEventListener('change', updateTextStyle);
    newStrokeWidthInput.addEventListener('change', updateTextStyle);
    newStrokeColorPicker.addEventListener('input', updateTextStyle);
    
  } else {
    textStylingControls.style.display = 'none';
  }
}

function updateTextStyle() {
  const activeObjects = canvas.getActiveObjects();
  activeObjects.forEach(obj => {
    if (obj.type === 'i-text') {
      // Obter valores dos controles
      const fontSelect = document.getElementById('font-select');
      const textColorPicker = document.getElementById('text-color-picker');
      const fontSizeInput = document.getElementById('font-size-input');
      const strokeWidthInput = document.getElementById('stroke-width-input');
      const strokeColorPicker = document.getElementById('stroke-color-picker');

      // Calcular novas propriedades
      const newFontSize = parseInt(fontSizeInput.value);
      const strokeWidth = parseInt(strokeWidthInput.value) || 0;

      // Aplicar propriedades
      obj.set({
        fontFamily: fontSelect.value,
        fill: textColorPicker.value,
        fontSize: newFontSize,
        stroke: strokeWidth > 0 ? strokeColorPicker.value : null,
        strokeWidth: strokeWidth,
        paintFirst: 'stroke', // Renderiza o contorno primeiro
        scaleX: 1,
        scaleY: 1
      });

      // Atualizar dimensões nos inputs
      const pxToCm = 1 / cmToPx;
      const widthInput = document.getElementById('width-input');
      const heightInput = document.getElementById('height-input');
      widthInput.value = (obj.width * pxToCm).toFixed(1);
      heightInput.value = (obj.height * pxToCm).toFixed(1);
    }
  });
  canvas.requestRenderAll();
}

	  function updateTextStroke() {
	  const activeObjects = canvas.getActiveObjects();
	  const strokeWidth = parseInt(document.getElementById('stroke-width-input').value) || 0;
	  const strokeColor = document.getElementById('stroke-color-picker').value;

	  activeObjects.forEach(obj => {
		if (obj.type === 'i-text') {
		  obj.set({
			stroke: strokeWidth > 0 ? strokeColor : null,
			strokeWidth: strokeWidth,
			paintFirst: 'stroke'
		  });
		}
	  });
	  canvas.requestRenderAll();
	}
	
	document.getElementById('stroke-width-input').addEventListener('change', updateTextStroke);
	document.getElementById('stroke-color-picker').addEventListener('input', updateTextStroke);

      // ---------- Eventos de Redimensionamento da Janela -------------------------------------------
      window.addEventListener('resize', () => {
        canvas.setWidth(window.innerWidth - sidebarWidth - layersPanelWidth);
        canvas.setHeight(window.innerHeight - topMenuHeight);
        canvas.requestRenderAll();
      });

     // ---------- Função de Impressão Corrigida (Contorno Ajustado) -------------------------------------------
document.getElementById('print-button').addEventListener('click', () => {
  const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
  if (!cloudFolhaObj) return;

  const originalZoom = canvas.getZoom();
  const originalViewportTransform = [...canvas.viewportTransform];
  const originalWidth = canvas.getWidth();
  const originalHeight = canvas.getHeight();

  // Marca todos os objetos como "dirty" antes de qualquer manipulação
  canvas.forEachObject(obj => {
    obj.dirty = true;
    obj.setCoords(); // Marca as coordenadas dos objetos
  });
  canvas.requestRenderAll();

  canvas.setZoom(1);
  canvas.requestRenderAll();

  const TARGET_DPI = 300; 
  const BROWSER_DPI = 96;
  const dpiScale = TARGET_DPI / BROWSER_DPI;

  const printWidth = cloudFolhaObj.width * dpiScale;
  const printHeight = cloudFolhaObj.height * dpiScale;

  const printCanvas = new fabric.Canvas(null, {
    width: printWidth,
    height: printHeight,
    backgroundColor: 'white'
  });

  const objectsToPrint = canvas.getObjects()
    .filter(obj => obj !== cloudFolhaObj && !obj.name?.includes('Guia'))
    .map(obj => {
      const clone = fabric.util.object.clone(obj);
      const relativeLeft = obj.left - cloudFolhaObj.left;
      const relativeTop = obj.top - cloudFolhaObj.top;

      clone.set({
        left: relativeLeft * dpiScale,
        top: relativeTop * dpiScale,
        scaleX: obj.scaleX * dpiScale,
        scaleY: obj.scaleY * dpiScale,
        selectable: false
      });

      if (clone.type === 'i-text') {
        const strokeScale = dpiScale * (clone.strokeWidth > 0 ? 1.2 : 1); 
        clone.set({
          fontSize: clone.fontSize * dpiScale,
          strokeWidth: clone.strokeWidth * strokeScale, 
          scaleX: 1,
          scaleY: 1,
          paintFirst: 'stroke',
          left: clone.left,
          top: clone.top
        });
      }

      return clone;
    });

  printCanvas.add(...objectsToPrint);
  printCanvas.renderAll();

  const printContainer = document.createElement('div');
  printContainer.id = 'print-container';
  printContainer.style = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: white;
    z-index: 10000;
    display: flex;
    justify-content: center;
    align-items: center;
  `;

  const printImg = document.createElement('img');
  printImg.src = printCanvas.toDataURL({
    format: 'png',
    quality: 1.0,
    enableRetinaScaling: true,
    width: printWidth,
    height: printHeight 
  });
  printImg.style = `
    width: 100%;
    height: 100%;
    object-fit: contain;
    image-rendering: pixelated;
    margin: -1px; /* Tentativa de remover a possível margem invisível */
  `;

  printContainer.appendChild(printImg);

  document.body.appendChild(printContainer);

  window.setTimeout(() => {
    window.print();
    document.body.removeChild(printContainer);

    canvas.setDimensions({
      width: originalWidth,
      height: originalHeight
    });
    canvas.setViewportTransform(originalViewportTransform);
    canvas.setZoom(originalZoom);

    // Marca os objetos novamente como "dirty" e atualiza suas coordenadas após o retorno
    canvas.forEachObject(obj => {
      obj.dirty = true;
      obj.setCoords(); 
    });

    canvas.requestRenderAll();

    setTimeout(() => {
      canvas.calcViewportBoundaries();
      canvas.discardActiveObject();
      canvas.forEachObject(obj => {
        obj.set("dirty", true);
        obj.setCoords();
      });
      canvas.renderAll();
    }, 100);

  }, 500);
});


      // ---------- Função para Excluir Selecionados -------------------------------------------
      document.getElementById('delete-selected').addEventListener('click', () => {
        const activeObjects = canvas.getActiveObjects();
        if (activeObjects.length) {
          activeObjects.forEach(obj => {
            canvas.remove(obj);
          });
          canvas.discardActiveObject();
          canvas.requestRenderAll();
          updateLayersList();
        }
      });

      // ---------- Função para Duplicar Selecionados -------------------------------------------
document.getElementById('duplicate-selected').addEventListener('click', () => {
    const activeObjects = canvas.getActiveObjects();
    if (!activeObjects.length) return;

    const zoom = canvas.getZoom();
    const offset = {
        x: 20 / zoom,
        y: 20 / zoom
    };

    const clones = [];
    const vpt = canvas.viewportTransform;

    activeObjects.forEach(obj => {
        if (obj.name?.startsWith('Guia')) return;

        obj.clone(clonedObj => {
            const objCenter = obj.getCenterPoint();
            const transformedPoint = fabric.util.transformPoint(objCenter, vpt);

            const newPosition = {
                x: transformedPoint.x + offset.x,
                y: transformedPoint.y + offset.y
            };

            const finalPosition = fabric.util.transformPoint(newPosition, fabric.util.invertTransform(vpt));

            clonedObj.set({
                left: finalPosition.x,
                top: finalPosition.y,
                angle: obj.angle,
                scaleX: obj.scaleX,
                scaleY: obj.scaleY,
                originX: 'center',
                originY: 'center'
            });

            clonedObj.set({
                shadow: obj.shadow ? new fabric.Shadow(obj.shadow) : null,
                stroke: obj.stroke,
                strokeWidth: obj.strokeWidth,
                opacity: obj.opacity,
                flipX: obj.flipX,
                flipY: obj.flipY
            });

            if (clonedObj.type === 'i-text') {
                clonedObj.set({
                    fontSize: obj.fontSize,
                    fontFamily: obj.fontFamily,
                    textBackgroundColor: obj.textBackgroundColor
                });
            }

            if (clonedObj.type === 'image') {
                clonedObj.set({
                    crossOrigin: 'anonymous',
                    filters: obj.filters ? [...obj.filters] : []
                });
                clonedObj.applyFilters();
            }

            canvas.add(clonedObj);
            clonedObj.setCoords();
            clones.push(clonedObj);
        });
    });

    canvas.discardActiveObject();
    const activeSelection = new fabric.ActiveSelection(clones, {
        canvas: canvas,
        originX: 'center',
        originY: 'center'
    });
    
    canvas.setActiveObject(activeSelection);
    canvas.requestRenderAll();
    updateLayersList();
});

      // ---------- Função para Selecionar Tudo -------------------------------------------
      document.getElementById('select-all').addEventListener('click', () => {
        const objects = canvas.getObjects().filter(obj => obj !== cloudFolha);
        if (objects.length) {
          canvas.discardActiveObject();
          const activeSelection = new fabric.ActiveSelection(objects, { canvas: canvas });
          canvas.setActiveObject(activeSelection);
          canvas.requestRenderAll();
          updateLayersList();
        }
      });

      // ---------- Função para Remover Seleção -------------------------------------------
      document.getElementById('remove-selection').addEventListener('click', () => {
        canvas.discardActiveObject();
        canvas.requestRenderAll();
        updateLayersList();
      });

      
      // ---------- Atualização da Lista de Camadas após Modificações -------------------------------------------
      canvas.on('object:added', () => {
        updateLayersList();
      });

      canvas.on('object:removed', () => {
        updateLayersList();
      });

      canvas.on('object:modified', () => {
        updateLayersList();
      });

      // ---------- Inicialização -------------------------------------------
      updateDimensionInputs();
      updateLayersList();
      canvas.requestRenderAll();
	  
	  // ---------- Função para Colar -------------------------------------------
function handlePaste(e) {
  const activeObject = canvas.getActiveObject();

  if (activeObject && activeObject.type === 'i-text' && activeObject.isEditing) {
    e.preventDefault(); 

    if (e && e.clipboardData) {
      const items = e.clipboardData.items;
      for (const item of items) {
        if (item.type === 'text/plain') {
          item.getAsString(text => {
            const cursorPosition = activeObject.selectionStart;
            const currentText = activeObject.text;
            const newText =
              currentText.slice(0, cursorPosition) +
              text +
              currentText.slice(cursorPosition);
            activeObject.set('text', newText);

            activeObject.selectionStart = cursorPosition + text.length;
            activeObject.selectionEnd = cursorPosition + text.length;

            canvas.requestRenderAll();
          });
          return;
        }
      }
    }
    else {
      navigator.clipboard.read().then(clipboardItems => {
        for (const item of clipboardItems) {
          if (item.types.includes('text/plain')) {
            item.getType('text/plain').then(textBlob => {
              textBlob.text().then(text => {
                const cursorPosition = activeObject.selectionStart;
                const currentText = activeObject.text;
                const newText =
                  currentText.slice(0, cursorPosition) +
                  text +
                  currentText.slice(cursorPosition);
                activeObject.set('text', newText);

                activeObject.selectionStart = cursorPosition + text.length;
                activeObject.selectionEnd = cursorPosition + text.length;

                canvas.requestRenderAll();
              });
            });
            return;
          }
        }
         showCustomAlert("Nenhum texto encontrado na área de transferência.");
      }).catch(err => {
        console.error('Falha ao acessar a área de transferência:', err);
         showCustomAlert("Falha ao acessar a área de transferência. Certifique-se de que o site está em HTTPS.");
      });
    }
  }
  else {
    if (e && e.clipboardData) {
      const items = e.clipboardData.items;
      for (const item of items) {
        if (item.type.indexOf('image') !== -1) {
          const blob = item.getAsFile();
          const url = URL.createObjectURL(blob);
          fabric.Image.fromURL(url, img => {
            img.set({
              left: cloudFolha.left + cloudFolha.width / 2,
              top: cloudFolha.top + cloudFolha.height / 2,
              originX: 'center',
              originY: 'center'
            });
            img.fileName = `Imagem - imagem${imageCounter++}`;
            addObject(img);
            canvas.setActiveObject(img);
            updateLayersList();
          });
          return;
        } else if (item.type === 'text/plain') {
          item.getAsString(text => {
            const iText = new fabric.IText(text, {
              left: cloudFolha.left + cloudFolha.width / 2,
              top: cloudFolha.top + cloudFolha.height / 2,
              originX: 'center',
              originY: 'center',
              fontSize: 20
            });
            addObject(iText);
            canvas.setActiveObject(iText);
            updateLayersList();
          });
          return;
        }
      }
       showCustomAlert("Nenhum dado válido foi colado.");
    } else {
      navigator.clipboard.read().then(clipboardItems => {
        for (const item of clipboardItems) {
          if (item.types.includes('image/png')) {
            item.getType('image/png').then(blob => {
              const url = URL.createObjectURL(blob);
              fabric.Image.fromURL(url, img => {
                img.set({
                  left: cloudFolha.left + cloudFolha.width / 2,
                  top: cloudFolha.top + cloudFolha.height / 2,
                  originX: 'center',
                  originY: 'center'
                });
                img.fileName = `Imagem - imagem${imageCounter++}`;
                addObject(img);
                canvas.setActiveObject(img);
                updateLayersList();
              });
            });
            return;
          } else if (item.types.includes('text/plain')) {
            item.getType('text/plain').then(textBlob => {
              textBlob.text().then(text => {
                const iText = new fabric.IText(text, {
                  left: cloudFolha.left + cloudFolha.width / 2,
                  top: cloudFolha.top + cloudFolha.height / 2,
                  originX: 'center',
                  originY: 'center',
                  fontSize: 20
                });
                addObject(iText);
                canvas.setActiveObject(iText);
                updateLayersList();
              });
            });
            return;
          }
        }
         showCustomAlert("Nenhum dado válido encontrado na área de transferência.");
      }).catch(err => {
        console.error('Falha ao acessar a área de transferência:', err);
         showCustomAlert("Falha ao acessar a área de transferência. Certifique-se de que o site está em HTTPS.");
      });
    }
  }
}
document.addEventListener('paste', (e) => {
  e.preventDefault();
  handlePaste(e);
});

document.getElementById('paste').addEventListener('click', () => {
  handlePaste();
});

      // ---------- Função para Adicionar Guias Padrão -------------------------------------------
      document.getElementById('add-guides').addEventListener('click', () => {
        addStandardGuides();
      });

      function addStandardGuides() {
        const guideOffsetCm = 0.5;
        const guideOffsetPx = guideOffsetCm * cmToPx;

        const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
        if (!cloudFolhaObj) return;

        const left = cloudFolhaObj.left;
        const top = cloudFolhaObj.top;
        const width = cloudFolhaObj.width * cloudFolhaObj.scaleX;
        const height = cloudFolhaObj.height * cloudFolhaObj.scaleY;

        const guidePositions = {
          'Esquerda': left + guideOffsetPx,
          'Direita': left + width - guideOffsetPx,
          'Topo': top + guideOffsetPx,
          'Fundo': top + height - guideOffsetPx
        };

        const leftGuide = new fabric.Line([guidePositions.Esquerda, top, guidePositions.Esquerda, top + height], {
          stroke: 'rgba(0, 255, 255, 0.8)',
          strokeWidth: 1,
          selectable: true,
          name: 'Guia - Esquerda'
        });

        const rightGuide = new fabric.Line([guidePositions.Direita, top, guidePositions.Direita, top + height], {
          stroke: 'rgba(0, 255, 255, 0.8)',
          strokeWidth: 1,
          selectable: true,
          name: 'Guia - Direita'
        });

        const topGuide = new fabric.Line([left, guidePositions.Topo, left + width, guidePositions.Topo], {
          stroke: 'rgba(0, 255, 255, 0.8)',
          strokeWidth: 1,
          selectable: true,
          name: 'Guia - Topo'
        });

        const bottomGuide = new fabric.Line([left, guidePositions.Fundo, left + width, guidePositions.Fundo], {
          stroke: 'rgba(0, 255, 255, 0.8)',
          strokeWidth: 1,
          selectable: true,
          name: 'Guia - Fundo'
        });

        [leftGuide, rightGuide, topGuide, bottomGuide].forEach(guide => {
          guide.id = objectIdCounter++;
          canvas.add(guide);
        });

        canvas.requestRenderAll();
        updateLayersList();
      }

      // ---------- Função para Adicionar Guia Vertical -------------------------------------------
document.getElementById('add-vertical-guide').addEventListener('click', () => {
  addVerticalGuideFromInput();
});

document.getElementById('vertical-guide-cm').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    addVerticalGuideFromInput();
  }
});

function addVerticalGuideFromInput() {
  const cmValue = document.getElementById('vertical-guide-cm').value;
  if (cmValue === '') {
    const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
    if (!cloudFolhaObj) return;

    const middleX = cloudFolhaObj.left + (cloudFolhaObj.width * cloudFolhaObj.scaleX) / 2;
    const middleYTop = cloudFolhaObj.top;
    const middleYBottom = cloudFolhaObj.top + cloudFolhaObj.height * cloudFolhaObj.scaleY;

    const verticalGuide = new fabric.Line([middleX, middleYTop, middleX, middleYBottom], {
      stroke: 'rgba(0, 255, 255, 0.8)',
      strokeWidth: 1,
      selectable: true,
      name: 'Guia Vertical (Meio)'
    });

    verticalGuide.id = objectIdCounter++;
    canvas.add(verticalGuide);
    canvas.requestRenderAll();
    updateLayersList();
  } else {
    const cmValueNum = parseFloat(cmValue);
    if (isNaN(cmValueNum)) {
       showCustomAlert("Por favor, insira um valor válido em centímetros para a Guia Vertical.");
      return;
    }
    addVerticalGuide(cmValueNum);
  }
}

function addVerticalGuide(cmValue) {
  const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
  if (!cloudFolhaObj) return;

  const guideX = cloudFolhaObj.left + cmValue * cmToPx;
  const guideYTop = cloudFolhaObj.top;
  const guideYBottom = cloudFolhaObj.top + cloudFolhaObj.height * cloudFolhaObj.scaleY;

  const verticalGuide = new fabric.Line([guideX, guideYTop, guideX, guideYBottom], {
    stroke: 'rgba(0, 255, 255, 0.8)',
    strokeWidth: 1,
    selectable: true,
    name: `Guia Vertical (${cmValue}cm)`
  });

  verticalGuide.id = objectIdCounter++;
  canvas.add(verticalGuide);
  canvas.requestRenderAll();
  updateLayersList();
}

      // ---------- Função para Adicionar Guia Horizontal -------------------------------------------
 document.getElementById('add-horizontal-guide').addEventListener('click', () => {
  addHorizontalGuideFromInput();
});

document.getElementById('horizontal-guide-cm').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    addHorizontalGuideFromInput();
  }
});

function addHorizontalGuideFromInput() {
  const cmValue = document.getElementById('horizontal-guide-cm').value;
  if (cmValue === '') {
    const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
    if (!cloudFolhaObj) return;

    const middleY = cloudFolhaObj.top + (cloudFolhaObj.height * cloudFolhaObj.scaleY) / 2;
    const middleXLeft = cloudFolhaObj.left;
    const middleXRight = cloudFolhaObj.left + cloudFolhaObj.width * cloudFolhaObj.scaleX;

    const horizontalGuide = new fabric.Line([middleXLeft, middleY, middleXRight, middleY], {
      stroke: 'rgba(0, 255, 255, 0.8)',
      strokeWidth: 1,
      selectable: true,
      name: 'Guia Horizontal (Meio)'
    });

    horizontalGuide.id = objectIdCounter++;
    canvas.add(horizontalGuide);
    canvas.requestRenderAll();
    updateLayersList();
  } else {
    const cmValueNum = parseFloat(cmValue);
    if (isNaN(cmValueNum)) {
	
	showCustomAlert("Por favor, insira um valor válido em centímetros para a Guia Horizontal.");
      return;
    }
    addHorizontalGuide(cmValueNum);
  }
}

function addHorizontalGuide(cmValue) {
  const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
  if (!cloudFolhaObj) return;

  const guideY = cloudFolhaObj.top + cmValue * cmToPx;
  const guideXLeft = cloudFolhaObj.left;
  const guideXRight = cloudFolhaObj.left + cloudFolhaObj.width * cloudFolhaObj.scaleX;

  const horizontalGuide = new fabric.Line([guideXLeft, guideY, guideXRight, guideY], {
    stroke: 'rgba(0, 255, 255, 0.8)',
    strokeWidth: 1,
    selectable: true,
    name: `Guia Horizontal (${cmValue}cm)`
  });

  horizontalGuide.id = objectIdCounter++;
  canvas.add(horizontalGuide);
  canvas.requestRenderAll();
  updateLayersList();
}
      // ---------- Função para Apagar Todas as Guias -------------------------------------------
      document.getElementById('delete-all-guides').addEventListener('click', () => {
        const guides = canvas.getObjects().filter(obj => obj.name && obj.name.includes('Guia'));
        guides.forEach(guide => {
          canvas.remove(guide);
        });
        canvas.requestRenderAll();
        updateLayersList();
      });

      // ---------- Eventos para Adicionar Guias por Intervalo -------------------------------------------
      document.getElementById('horizontal-interval').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addHorizontalGuidesAtInterval();
        }
      });

      document.getElementById('vertical-interval').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addVerticalGuidesAtInterval();
        }
      });

      document.getElementById('horizontal-interval').addEventListener('blur', () => {
        addHorizontalGuidesAtInterval();
      });

      document.getElementById('vertical-interval').addEventListener('blur', () => {
        addVerticalGuidesAtInterval();
      });

      function addHorizontalGuidesAtInterval() {
        const intervalCm = parseFloat(document.getElementById('horizontal-interval').value);
        if (isNaN(intervalCm) || intervalCm <= 0) {
           showCustomAlert("Por favor, insira um valor válido e maior que zero para o intervalo horizontal.");
          return;
        }
        const intervalPx = intervalCm * cmToPx;

        const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
        if (!cloudFolhaObj) return;

        const topStart = cloudFolhaObj.top;
        const topEnd = cloudFolhaObj.top + cloudFolhaObj.height * cloudFolhaObj.scaleY;

        for (let y = topStart + intervalPx; y < topEnd; y += intervalPx) {
          const horizontalGuide = new fabric.Line([cloudFolhaObj.left, y, cloudFolhaObj.left + cloudFolhaObj.width * cloudFolhaObj.scaleX, y], {
            stroke: 'rgba(0, 255, 255, 0.8)',
            strokeWidth: 1,
            selectable: true,
            name: `Guia Horizontal (${(y - topStart)/cmToPx}cm)`
          });
          horizontalGuide.id = objectIdCounter++;
          canvas.add(horizontalGuide);
        }
        canvas.requestRenderAll();
        updateLayersList();
      }

      function addVerticalGuidesAtInterval() {
        const intervalCm = parseFloat(document.getElementById('vertical-interval').value);
        if (isNaN(intervalCm) || intervalCm <= 0) {
           showCustomAlert("Por favor, insira um valor válido e maior que zero para o intervalo vertical.");
          return;
        }
        const intervalPx = intervalCm * cmToPx;

        const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
        if (!cloudFolhaObj) return;

        const leftStart = cloudFolhaObj.left;
        const leftEnd = cloudFolhaObj.left + cloudFolhaObj.width * cloudFolhaObj.scaleX;

        for (let x = leftStart + intervalPx; x < leftEnd; x += intervalPx) {
          const verticalGuide = new fabric.Line([x, cloudFolhaObj.top, x, cloudFolhaObj.top + cloudFolhaObj.height * cloudFolhaObj.scaleY], {
            stroke: 'rgba(0, 255, 255, 0.8)',
            strokeWidth: 1,
            selectable: true,
            name: `Guia Vertical (${(x - leftStart)/cmToPx}cm)`
          });
          verticalGuide.id = objectIdCounter++;
          canvas.add(verticalGuide);
        }
        canvas.requestRenderAll();
        updateLayersList();
      }

      // ---------- Implementação de Magnetismo nas Guias -------------------------------------------
      const SNAP_DISTANCE_WEAK = 20;
      const SNAP_DISTANCE_STRONG = 10;

      canvas.on('object:moving', (opt) => {
        const obj = opt.target;
        const padding = 5; 

        const objLeftEdge = obj.left - (obj.width * obj.scaleX) / 2;
        const objRightEdge = obj.left + (obj.width * obj.scaleX) / 2;
        const objTopEdge = obj.top - (obj.height * obj.scaleY) / 2;
        const objBottomEdge = obj.top + (obj.height * obj.scaleY) / 2;

        let snapPoints = [];

        canvas.getObjects().forEach((guide) => {
          if (guide === cloudFolha) return;
          if (guide.type === 'line') {
            if (guide.x1 === guide.x2) {
              const guideX = guide.x1;
              let distLeft = Math.abs(objLeftEdge - guideX);
              if (distLeft <= SNAP_DISTANCE_WEAK) {
                snapPoints.push({ axis: 'x', snap: guideX + (obj.width * obj.scaleX) / 2, distance: distLeft });
              }
              let distRight = Math.abs(objRightEdge - guideX);
              if (distRight <= SNAP_DISTANCE_WEAK) {
                snapPoints.push({ axis: 'x', snap: guideX - (obj.width * obj.scaleX) / 2, distance: distRight });
              }
            } else if (guide.y1 === guide.y2) {
              const guideY = guide.y1;
              let distTop = Math.abs(objTopEdge - guideY);
              if (distTop <= SNAP_DISTANCE_WEAK) {
                snapPoints.push({ axis: 'y', snap: guideY + (obj.height * obj.scaleY) / 2, distance: distTop });
              }
              let distBottom = Math.abs(objBottomEdge - guideY);
              if (distBottom <= SNAP_DISTANCE_WEAK) {
                snapPoints.push({ axis: 'y', snap: guideY - (obj.height * obj.scaleY) / 2, distance: distBottom });
              }
            }
          }
        });

        let closestSnapX = null;
        let closestSnapY = null;
        let minDistX = Infinity;
        let minDistY = Infinity;

        snapPoints.forEach(point => {
          if (point.axis === 'x' && point.distance < minDistX) {
            closestSnapX = point.snap;
            minDistX = point.distance;
          }
          if (point.axis === 'y' && point.distance < minDistY) {
            closestSnapY = point.snap;
            minDistY = point.distance;
          }
        });

        if (closestSnapX !== null) {
          if (minDistX <= SNAP_DISTANCE_STRONG) {
            obj.left = closestSnapX;
          } else if (minDistX <= SNAP_DISTANCE_WEAK) {
            obj.left += (closestSnapX - obj.left) * 0.5;
          }
        }

        if (closestSnapY !== null) {
          if (minDistY <= SNAP_DISTANCE_STRONG) {
            obj.top = closestSnapY;
          } else if (minDistY <= SNAP_DISTANCE_WEAK) {
            obj.top += (closestSnapY - obj.top) * 0.5;
          }
        }
      });

      // ---------- Implementação de Atalhos de Teclado -------------------------------------------
      document.addEventListener('keydown', (e) => {
		  const activeObject = canvas.getActiveObject();

		  if (activeObject && activeObject.isEditing && activeObject.type === 'i-text') {
			return;
		  }

		  if (e.code === 'Delete') {
			e.preventDefault();
			document.getElementById('delete-selected').click();
		  }

		  if (e.ctrlKey && e.code === 'KeyD') {
			e.preventDefault();
			document.getElementById('duplicate-selected').click();
		  }
		  if (e.ctrlKey && e.code === 'KeyA') {
			e.preventDefault();
			document.getElementById('select-all').click();
		  }
		  if (e.code === 'F2') {
			e.preventDefault();
			document.getElementById('add-guides').click();
		  }
		  if (e.ctrlKey && e.code === 'KeyP') {
			e.preventDefault();
			document.getElementById('print-button').click();
		  }
		});
		
		// ------------ dividir o texto em colunas----------------------------------
		function splitTextIntoTwoColumns() {
		  const activeObject = canvas.getActiveObject();

		  if (activeObject && activeObject.type === 'i-text') {
			const text = activeObject.text;
			const words = text.split(' ');
			const middle = Math.ceil(words.length / 2);

			const firstHalf = words.slice(0, middle).join(' ');
			const secondHalf = words.slice(middle).join(' ');

			activeObject.set('text', firstHalf);
			activeObject.setCoords();

			const secondColumn = new fabric.IText(secondHalf, {
			  left: activeObject.left + activeObject.width + 20, 
			  top: activeObject.top,
			  fontSize: activeObject.fontSize,
			  fontFamily: activeObject.fontFamily,
			  fill: activeObject.fill,
			  originX: 'left',
			  originY: 'top',
			});

			canvas.add(secondColumn);
			canvas.setActiveObject(secondColumn); 
			canvas.requestRenderAll();
		  } else {
		    showCustomAlert("Selecione um texto para dividir.");
		  }
		}
	  	  document.getElementById('split-text').addEventListener('click', () => {
		  splitTextIntoTwoColumns();
		});
		
		// ----------------------------------------- Seção Inicio Mover com Setas do teclado ---------------------------------

let arrowKeys = {
    ArrowUp: false,
    ArrowDown: false,
    ArrowLeft: false,
    ArrowRight: false
};

let moveSpeed = 0.1;
const fastSpeed = 0.5;
const maxSpeed = 1;
const speedIncrement = 0.05;

let keyPressTime = 0;
let isKeyPressed = false;

function moveSelectedObjects(dx, dy) {
    const activeObjects = canvas.getActiveObjects();
    if (activeObjects && activeObjects.length > 0) {
        activeObjects.forEach(obj => {
            if (obj.id !== 'CloudFolha') {
                obj.set({
                    left: obj.left + dx,
                    top: obj.top + dy
                });
                obj.setCoords();
            }
        });
        canvas.renderAll();
    }
}

function handleArrowKeys() {
    if (isKeyPressed) {
        keyPressTime += 0.1;
        if (keyPressTime > 5) {
            keyPressTime = 5;
        }
        if (keyPressTime > 5) {
            moveSpeed = fastSpeed;
        }
        if (moveSpeed < maxSpeed) {
            moveSpeed += speedIncrement;
        }
    }

    if (arrowKeys.ArrowUp) {
        moveSelectedObjects(0, -moveSpeed);
    }
    if (arrowKeys.ArrowDown) {
        moveSelectedObjects(0, moveSpeed);
    }
    if (arrowKeys.ArrowLeft) {
        moveSelectedObjects(-moveSpeed, 0);
    }
    if (arrowKeys.ArrowRight) {
        moveSelectedObjects(moveSpeed, 0);
    }

    requestAnimationFrame(handleArrowKeys); 
}

handleArrowKeys();

document.addEventListener('keydown', function (e) {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        if (!arrowKeys[e.key]) {
            arrowKeys[e.key] = true;
            isKeyPressed = true;  
            keyPressTime = 0;  
            e.preventDefault();  
        }
    }
});

document.addEventListener('keyup', function (e) {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        arrowKeys[e.key] = false;
        isKeyPressed = false;  
        moveSpeed = 0.1;  
        keyPressTime = 0;  
    }
});


// ----------------------------------------- Seção Mover zoom espaço do teclado --------------------------------- 

let isSpacePressed = false;

let isDraggingCanvas = false;
let lastPosX = 0;
let lastPosY = 0;

function startDraggingCanvas(e) {
    if (isSpacePressed && !isDraggingCanvas) {
        isDraggingCanvas = true;
        lastPosX = e.clientX;
        lastPosY = e.clientY;
        canvas.defaultCursor = 'grabbing';
        canvas.renderAll();
    }
}

function dragCanvas(e) {
    if (isDraggingCanvas) {
        const deltaX = e.clientX - lastPosX;
        const deltaY = e.clientY - lastPosY;

        const vpt = canvas.viewportTransform;
        vpt[4] += deltaX;
        vpt[5] += deltaY;

        canvas.requestRenderAll();

        lastPosX = e.clientX;
        lastPosY = e.clientY;
    }
}

function stopDraggingCanvas() {
    if (isDraggingCanvas) {
        isDraggingCanvas = false;
        canvas.defaultCursor = isSpacePressed ? 'grab' : 'default';
        canvas.renderAll();
    }
}

document.addEventListener('keydown', function (e) {
    if (e.code === 'Space' && !isSpacePressed) {
        isSpacePressed = true;

        const activeObject = canvas.getActiveObject();
        if (!activeObject || (activeObject.type !== 'i-text' && activeObject.type !== 'text')) {
            canvas.defaultCursor = 'grab';
            canvas.renderAll();
        }
    }
});

document.addEventListener('keyup', function (e) {
    if (e.code === 'Space' && isSpacePressed) {
        isSpacePressed = false;
        canvas.defaultCursor = 'default';
        canvas.renderAll();
    }
});

canvas.on('mouse:down', function (e) {
    if (isSpacePressed) {
        startDraggingCanvas(e.e);
    }
});

canvas.on('mouse:move', function (e) {
    if (isDraggingCanvas) {
        dragCanvas(e.e);
    }
});

canvas.on('mouse:up', function () {
    stopDraggingCanvas();
});

canvas.on('text:editing:entered', function () {
    isSpacePressed = false;
    canvas.defaultCursor = 'text';
    canvas.renderAll();
});

canvas.on('text:editing:exited', function () {
    if (isSpacePressed) {
        canvas.defaultCursor = 'grab';
    } else {
        canvas.defaultCursor = 'default';
    }
    canvas.renderAll();
});

			// ------------- organizar objetos -------------------------
function cmToPixels(cm) {
  return cm * 37.795275591; 
}

async function organizeObjects() {
    isOrganizing = true; 

    const spacingCm = parseFloat(document.getElementById('spacing-input').value) || 0.2;
    const targetZoom = 1.0; 
    const zoom = canvas.getZoom();
    const spacingPx = cmToPixels(spacingCm) / targetZoom; 
    const marginPx = spacingPx;

    const extraTopCm = 0.0;
    const extraLeftCm = 0.0;

    const extraTopPx = cmToPixels(extraTopCm);
    const extraLeftPx = cmToPixels(extraLeftCm);

    const selectedObjects = canvas.getActiveObjects();
    const objectIds = selectedObjects.map(obj => obj.id);
    
    canvas.discardActiveObject();
    canvas.requestRenderAll();

    const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
    if (!cloudFolhaObj) return;

    canvas.setZoom(targetZoom);
    canvas.absolutePan({
        x: (canvas.getWidth() / 2) - (cloudFolhaObj.left + (cloudFolhaObj.width * cloudFolhaObj.scaleX) / 2 + 500),
        y: (canvas.getHeight() / 2) - (cloudFolhaObj.top + (cloudFolhaObj.height * cloudFolhaObj.scaleY) / 2+ 100)
    });

    const folhaBounds = {
        leftTop: fabric.util.transformPoint(
            new fabric.Point(cloudFolhaObj.left, cloudFolhaObj.top),
            canvas.viewportTransform
        ),
        rightBottom: fabric.util.transformPoint(
            new fabric.Point(
                cloudFolhaObj.left + cloudFolhaObj.width * cloudFolhaObj.scaleX,
                cloudFolhaObj.top + cloudFolhaObj.height * cloudFolhaObj.scaleY
            ),
            canvas.viewportTransform
        )
    };

    let currentX = folhaBounds.leftTop.x + marginPx + extraLeftPx;
    let currentY = folhaBounds.leftTop.y + marginPx + extraTopPx; 
    let maxHeightInRow = 0;

    const sortedObjects = selectedObjects.sort((a, b) => {
        const aCenter = a.getCenterPoint();
        const bCenter = b.getCenterPoint();
        return aCenter.y - bCenter.y || aCenter.x - bCenter.x;
    });

    for (const obj of sortedObjects) {
        const objWidth = obj.getScaledWidth();
        const objHeight = obj.getScaledHeight();

        if ((currentX + objWidth) > (folhaBounds.rightBottom.x - marginPx)) {
            currentX = folhaBounds.leftTop.x + marginPx + extraLeftPx; // Reinicia a posição X com o espaço extra
            currentY += maxHeightInRow + spacingPx;
            maxHeightInRow = 0;
        }

        if ((currentY + objHeight) > (folhaBounds.rightBottom.y - marginPx)) {
            console.warn("Não há espaço vertical suficiente");
            break;
        }

        obj.set({
            originX: 'left',
            originY: 'top'
        });

        await new Promise(resolve => {
            obj.animate({
                left: (currentX - canvas.viewportTransform[4]) / targetZoom,
                top: (currentY - canvas.viewportTransform[5]) / targetZoom
            }, {
                duration: 50,
                onChange: canvas.requestRenderAll.bind(canvas),
                onComplete: () => {
                    obj.setCoords();
                    resolve();
                }
            });
        });

        currentX += objWidth + spacingPx;
        maxHeightInRow = Math.max(maxHeightInRow, objHeight);
    }

    const newSelection = sortedObjects.filter(obj => objectIds.includes(obj.id));
    const activeSelection = new fabric.ActiveSelection(newSelection, { canvas: canvas });
    canvas.setActiveObject(activeSelection);
    canvas.requestRenderAll();

    isOrganizing = false;
}
document.getElementById('organize-objects').addEventListener('click', organizeObjects);

// -------------- Formas menu ---------------------------------------------
document.getElementById('insert-square').addEventListener('click', () => {
  const square = new fabric.Rect({
    width: 100,
    height: 100,
    left: cloudFolha.left + cloudFolha.width / 2,
    top: cloudFolha.top + cloudFolha.height / 2,
    fill: '#FF0000',
    originX: 'center',
    originY: 'center',
    padding: 0,
    cornerSize: 10,
    transparentCorners: false,
    borderColor: 'blue',
    cornerColor: 'blue',
    objectCaching: false,
    rx: 0,
    ry: 0 
  });

  const controlPoint = new fabric.Circle({
    radius: 4, 
    fill: 'white', 
    stroke: 'black', 
    strokeWidth: 1, 
    left: square.left - square.width / 2 + 10,
    top: square.top - square.height / 2 + 10,
    originX: 'center',
    originY: 'center',
    hasControls: false,
    hasBorders: false,
    selectable: true,
    evented: true,
    visible: true 
  });

  addObject(square);
  addObject(controlPoint);
  canvas.setActiveObject(square);
  updateLayersList();

  const MIN_RADIUS = 0; 

  function getMinDimension(obj) {
    const width = obj.width * obj.scaleX;
    const height = obj.height * obj.scaleY;
    return Math.min(width, height);
  }

  function normalizeCornerRadius(square, radius) {
    const MAX_RADIUS = getMinDimension(square) / 2; 
    return Math.max(MIN_RADIUS, Math.min(radius, MAX_RADIUS));
  }

  controlPoint.on('moving', function (e) {
    controlPoint.set({ 
      left: square.left - square.width * square.scaleX / 2 + 10 
    });

    const deltaY = controlPoint.top - (square.top - square.height * square.scaleY / 2 + 10);

    let radius = normalizeCornerRadius(square, deltaY);

    square.set({ rx: radius, ry: radius });

    controlPoint.set({
      top: square.top - square.height * square.scaleY / 2 + 10 + radius
    });

    canvas.requestRenderAll();
  });

  controlPoint.on('mouseup', function () {
    updateControlPointPosition();
    canvas.setActiveObject(square);
    canvas.requestRenderAll();
  });

  function updateControlPointPosition() {
    const radius = square.rx || 0;
    controlPoint.set({
      left: square.left - square.width * square.scaleX / 2 + 10, 
      top: square.top - square.height * square.scaleY / 2 + 10 + radius
    });
  }

  square.on('moving', function () {
    updateControlPointPosition();
    canvas.requestRenderAll();
  });

  square.on('scaling', function () {
    const currentRadius = square.rx || 0;
    const newRadius = normalizeCornerRadius(square, currentRadius);
    square.set({ rx: newRadius, ry: newRadius });
    
    updateControlPointPosition();
    canvas.requestRenderAll();
  });

  square.on('selected', function () {
    controlPoint.set({ visible: true });
    canvas.bringToFront(controlPoint);
    canvas.requestRenderAll();
  });

  square.on('deselected', function () {
    controlPoint.set({ visible: false });
    canvas.requestRenderAll();
  });

  canvas.on('mouse:down', function (e) {
    if (e.target !== square && e.target !== controlPoint) {
      controlPoint.set({ visible: false });
      canvas.requestRenderAll();
    }
  });
});

document.getElementById('insert-circle').addEventListener('click', () => {
  const circle = new fabric.Circle({
    radius: 50,
    left: cloudFolha.left + cloudFolha.width / 2,
    top: cloudFolha.top + cloudFolha.height / 2,
    fill: '#00FF00',
    originX: 'center',
    originY: 'center',
    padding: 0,
    cornerSize: 10, 
    transparentCorners: false, 
    borderColor: 'blue', 
    cornerColor: 'blue',
    objectCaching: false
  });
  addObject(circle);
  canvas.setActiveObject(circle);
  updateLayersList();
});

document.getElementById('insert-triangle').addEventListener('click', () => {
  const triangle = new fabric.Triangle({
    width: 100,
    height: 100,
    left: cloudFolha.left + cloudFolha.width / 2,
    top: cloudFolha.top + cloudFolha.height / 2,
    fill: '#0000FF',
    originX: 'center',
    originY: 'center',
    padding: 0,
    cornerSize: 10,
    transparentCorners: false,
    borderColor: 'blue',
    cornerColor: 'blue',
    objectCaching: false 
  });
  addObject(triangle);
  canvas.setActiveObject(triangle);
  updateLayersList();
});
document.getElementById('insert-line').addEventListener('click', () => {
  const line = new fabric.Line([50, 50, 200, 50], {
    left: cloudFolha.left + cloudFolha.width / 2,
    top: cloudFolha.top + cloudFolha.height / 2,
    stroke: '#FF00FF',
    strokeWidth: 5,
    originX: 'center',
    originY: 'center'
  });
  addObject(line);
  canvas.setActiveObject(line);
  updateLayersList();
});

// ---------------- abrir e salvar documento --------------------------------------
document.getElementById('openDocumentBtn').addEventListener('click', function () {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.cloudapp';
    input.style.display = 'none';
    document.body.appendChild(input);
    input.click();

    input.addEventListener('change', function (e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (event) {
            const canvasState = JSON.parse(event.target.result);
            const cloudFolhaState = canvasState.cloudFolha;

            const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
            if (cloudFolha && cloudFolhaState) {
                cloudFolha.set({
                    width: cloudFolhaState.width,
                    height: cloudFolhaState.height
                });
                cloudFolha.setCoords();
            }

            canvas.loadFromJSON(canvasState, function () {
                if (cloudFolha) {
                    const widthCm = cloudFolha.width / cmToPx;
                    const heightCm = cloudFolha.height / cmToPx;
                    document.getElementById('width-input').value = widthCm.toFixed(1);
                    document.getElementById('height-input').value = heightCm.toFixed(1);
                }

                canvas.requestRenderAll();
                updateLayersList();
            });
        };

        reader.readAsText(file);
    });

    document.body.removeChild(input);
});

document.getElementById('saveDocumentBtn').addEventListener('click', function () {
    const objectsToSave = canvas.getObjects().filter(obj => obj.name !== 'CloudFolha');
    const canvasState = canvas.toDatalessJSON(['id', 'name', 'selectable', 'evented', 'left', 'top', 'width', 'height', 'scaleX', 'scaleY', 'angle', 'fill', 'stroke', 'strokeWidth']);

    const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
    if (cloudFolha) {
        canvasState.cloudFolha = {
            width: cloudFolha.width,
            height: cloudFolha.height
        };
    }

    const blob = new Blob([JSON.stringify(canvasState)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'documento.cloudapp'; 
    document.body.appendChild(a);
    a.click(); 
    document.body.removeChild(a);
    URL.revokeObjectURL(url); 
});

// ---------------- ferramenta de corte ---------------------------
let cropMode = false; 
let cropRect = null; 
let originalImage = null; 
let cropButtons = null;

function createCropButtons() {
  const cropButtonsContainer = document.createElement('div');
  cropButtonsContainer.className = 'crop-buttons';
  cropButtonsContainer.style.display = 'none';
  cropButtonsContainer.style.position = 'absolute';
  cropButtonsContainer.style.zIndex = '1000';
  cropButtonsContainer.style.textAlign = 'center'; // Alinha os botões no centro

  const confirmButton = document.createElement('button');
  confirmButton.id = 'crop-confirm';
  confirmButton.textContent = 'Confirmar';
  confirmButton.style.background = '#1a1a1a';
  confirmButton.style.color = 'white';
  confirmButton.style.border = 'none';
  confirmButton.style.padding = '5px 10px';
  confirmButton.style.margin = '5px';
  confirmButton.style.borderRadius = '5px';
  confirmButton.style.cursor = 'pointer';
  confirmButton.addEventListener('click', applyCrop);

  const cancelButton = document.createElement('button');
  cancelButton.id = 'crop-cancel';
  cancelButton.textContent = 'Cancelar';
  cancelButton.style.background = '#1a1a1a';
  cancelButton.style.color = 'white';
  cancelButton.style.border = 'none';
  cancelButton.style.padding = '5px 10px';
  cancelButton.style.margin = '5px';
  cancelButton.style.borderRadius = '5px';
  cancelButton.style.cursor = 'pointer';
  cancelButton.addEventListener('click', cancelCrop);

  cropButtonsContainer.appendChild(confirmButton);
  cropButtonsContainer.appendChild(cancelButton);

  document.body.appendChild(cropButtonsContainer);

  return cropButtonsContainer;
}

function activateCropMode() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para recortar.');
    return;
  }

  cropMode = true;
  originalImage = activeObject;

  canvas.forEachObject(obj => {
    if (obj.name === 'CloudFolha') {
      obj.selectable = false;
      obj.evented = false;
    } else if (obj !== originalImage) {
      obj.selectable = false;
      obj.evented = false;
    }
  });

  const imgBounds = originalImage.getBoundingRect(true);

  cropRect = new fabric.Rect({
    left: imgBounds.left,
    top: imgBounds.top,
    width: imgBounds.width,
    height: imgBounds.height,
    fill: 'rgba(0, 0, 0, 0)',
    stroke: 'blue',
    strokeWidth: 1,
    hasControls: true,
    hasBorders: true,
    lockRotation: true,
    selectable: true,
    evented: true,
    originX: 'left',
    originY: 'top',
    transparentCorners: false,
    cornerColor: 'blue',
    cornerStyle: 'rect',
    cornerSize: 10,
    padding: 0,
    lockUniScaling: false // Inicia com movimento livre por padrão
  });

  // Monitora o início do scaling para definir o estado inicial
  canvas.on('mouse:down', function(e) {
    if (e.target === cropRect) {
      cropRect.lockUniScaling = false; // Garante que começa livre
    }
  });

  // Durante o scaling, verifica o Shift
  canvas.on('object:scaling', function(e) {
    if (e.target === cropRect) {
      cropRect.lockUniScaling = e.e.shiftKey; // true quando Shift está pressionado
    }
  });

  // Adiciona os botões de corte
  cropButtons = createCropButtons();

  canvas.add(cropRect);
  canvas.bringToFront(cropRect);
  canvas.setActiveObject(cropRect);

  canvas.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  canvas.renderAll();

  // Exibe os botões no centro do retângulo de corte
  const cropBounds = cropRect.getBoundingRect(true);
  cropButtons.style.display = 'block';
  cropButtons.style.left = `${cropBounds.left + cropBounds.width / 2 - cropButtons.offsetWidth / 2}px`;
  cropButtons.style.top = `${cropBounds.top + cropBounds.height / 2 - cropButtons.offsetHeight / 2}px`;

  // Adiciona listeners para controlar a visibilidade e posicionamento dos botões
  canvas.on('mouse:down', (e) => {
    if (e.target === cropRect) {
      cropButtons.style.display = 'none';
    }
  });

  canvas.on('mouse:up', (e) => {
    if (e.target === cropRect) {
      const cropBounds = cropRect.getBoundingRect(true);
      cropButtons.style.display = 'block';
      cropButtons.style.left = `${cropBounds.left + cropBounds.width / 2 - cropButtons.offsetWidth / 2}px`;
      cropButtons.style.top = `${cropBounds.top + cropBounds.height / 2 - cropButtons.offsetHeight / 2}px`;
    }
  });
}

function applyCrop() {
  if (!cropRect || !originalImage) return;

  const angle = fabric.util.degreesToRadians(originalImage.angle);
  const imgElement = originalImage.getElement();

  const imgBounds = originalImage.getBoundingRect(true);
  const cropBounds = cropRect.getBoundingRect(true);

  const scaleX = originalImage.scaleX;
  const scaleY = originalImage.scaleY;

  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');

  tempCanvas.width = imgBounds.width;
  tempCanvas.height = imgBounds.height;

  tempCtx.translate(imgBounds.width / 2, imgBounds.height / 2);
  tempCtx.rotate(angle);
  
  const scaledWidth = originalImage.width * scaleX;
  const scaledHeight = originalImage.height * scaleY;
  tempCtx.drawImage(
    imgElement,
    -scaledWidth / 2,
    -scaledHeight / 2,
    scaledWidth,
    scaledHeight
  );

  const cropCanvas = document.createElement('canvas');
  const cropCtx = cropCanvas.getContext('2d');
  
  cropCanvas.width = cropBounds.width;
  cropCanvas.height = cropBounds.height;

  const dx = cropBounds.left - (imgBounds.left);
  const dy = cropBounds.top - (imgBounds.top);

  cropCtx.drawImage(
    tempCanvas,
    dx,
    dy,
    cropBounds.width,
    cropBounds.height,
    0,
    0,
    cropBounds.width,
    cropBounds.height
  );

  fabric.Image.fromURL(cropCanvas.toDataURL(), newImg => {
    newImg.set({
      left: cropBounds.left + cropBounds.width / 2,
      top: cropBounds.top + cropBounds.height / 2,
      originX: 'center',
      originY: 'center',
      angle: 0
    });

    canvas.remove(originalImage);
    canvas.remove(cropRect);
    canvas.add(newImg);
    canvas.setActiveObject(newImg);

    canvas.forEachObject(obj => {
      if (obj.name === 'CloudFolha') {
        obj.selectable = false;
        obj.evented = false;
      } else {
        obj.selectable = true;
        obj.evented = true;
      }
    });

    canvas.off('mouse:down');
    canvas.off('object:scaling');
    canvas.off('mouse:up');

    if (cropButtons) {
      document.body.removeChild(cropButtons);
      cropButtons = null;
    }

    canvas.backgroundColor = '#151f28';
    canvas.requestRenderAll();

    cropMode = false;
    cropRect = null;
    originalImage = null;
  });
}

function cancelCrop() {
  if (cropRect) {
    canvas.remove(cropRect);
    canvas.renderAll();
  }

  canvas.off('mouse:down');
  canvas.off('object:scaling');
  canvas.off('mouse:up');

  if (cropButtons) {
    document.body.removeChild(cropButtons);
    cropButtons = null;
  }

  canvas.forEachObject(obj => {
    obj.selectable = true;
    obj.evented = true;
  });

  canvas.backgroundColor = '#151f28';
  canvas.renderAll();

  cropMode = false;
  cropRect = null;
  originalImage = null;
}

document.getElementById('crop-button').addEventListener('click', activateCropMode);
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && cropMode) {
    cancelCrop();
  }
});

// ---------------------------- contraste Automático --------------------------------------------------

function applyAutoContrast() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para aplicar o contraste automático.');
    return;
  }

  const img = activeObject.getElement();
  const canvasEl = document.createElement('canvas');
  const ctx = canvasEl.getContext('2d');

  const originalProps = {
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    angle: activeObject.angle,
    left: activeObject.left,
    top: activeObject.top,
    width: activeObject.width,
    height: activeObject.height,
    flipX: activeObject.flipX,
    flipY: activeObject.flipY,
    originX: activeObject.originX,
    originY: activeObject.originY,
    filters: activeObject.filters || [],
    clipPath: activeObject.clipPath,
    objectIndex: canvas.getObjects().indexOf(activeObject)
  };

  canvasEl.width = img.naturalWidth;
  canvasEl.height = img.naturalHeight;

  if (originalProps.filters.length > 0) {
    fabric.util.applyFilters(canvasEl, originalProps.filters, {
      width: img.naturalWidth,
      height: img.naturalHeight
    });
  }

  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
  const data = imageData.data;

  let minR = 255, maxR = 0;
  let minG = 255, maxG = 0;
  let minB = 255, maxB = 0;

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    minR = Math.min(minR, r);
    maxR = Math.max(maxR, r);
    minG = Math.min(minG, g);
    maxG = Math.max(maxG, g);
    minB = Math.min(minB, b);
    maxB = Math.max(maxB, b);
  }

  const rangeR = maxR - minR || 1;
  const rangeG = maxG - minG || 1;
  const rangeB = maxB - minB || 1;

  for (let i = 0; i < data.length; i += 4) {
    data[i] = ((data[i] - minR) / rangeR) * 255; 
    data[i + 1] = ((data[i + 1] - minG) / rangeG) * 255;
    data[i + 2] = ((data[i + 2] - minB) / rangeB) * 255;
  }

  ctx.putImageData(imageData, 0, 0);

  fabric.Image.fromURL(canvasEl.toDataURL(), newImg => {
    newImg.set({
      ...originalProps,
      crossOrigin: 'anonymous'
    });

    canvas.remove(activeObject);

    if (originalProps.objectIndex >= 0) {
      canvas.insertAt(newImg, originalProps.objectIndex);
    } else {
      canvas.add(newImg);
    }

    canvas.setActiveObject(newImg);
    canvas.requestRenderAll();
  });
}

document.getElementById('BtnContrasteAutm').addEventListener('click', applyAutoContrast);

function applyAutoColor() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para aplicar a cor automática.');
    return;
  }

  const img = activeObject.getElement();
  const canvasEl = document.createElement('canvas');
  const ctx = canvasEl.getContext('2d');

  const originalProps = {
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    angle: activeObject.angle,
    left: activeObject.left,
    top: activeObject.top,
    width: activeObject.width,
    height: activeObject.height,
    filters: activeObject.filters || [],
    flipX: activeObject.flipX,
    flipY: activeObject.flipY,
    opacity: activeObject.opacity,
    shadow: activeObject.shadow ? new fabric.Shadow(activeObject.shadow) : null,
    stroke: activeObject.stroke,
    strokeWidth: activeObject.strokeWidth,
    strokeDashArray: activeObject.strokeDashArray,
    strokeLineCap: activeObject.strokeLineCap,
    strokeLineJoin: activeObject.strokeLineJoin,
    strokeMiterLimit: activeObject.strokeMiterLimit,
    padding: activeObject.padding,
    backgroundColor: activeObject.backgroundColor,
    clipPath: activeObject.clipPath,
    originX: activeObject.originX,
    originY: activeObject.originY,
    cropX: activeObject.cropX,
    cropY: activeObject.cropY
  };

  canvasEl.width = img.naturalWidth;
  canvasEl.height = img.naturalHeight;

  if (originalProps.filters.length > 0) {
    fabric.util.applyFilters(canvasEl, originalProps.filters, {
      width: img.naturalWidth,
      height: img.naturalHeight
    });
  }

  ctx.drawImage(img, 0, 0);

  const imageData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
  const data = imageData.data;

  let rTotal = 0, gTotal = 0, bTotal = 0;
  let count = 0;
  for (let i = 0; i < data.length; i += 4) {
    rTotal += data[i];
    gTotal += data[i + 1];
    bTotal += data[i + 2];
    count++;
  }
  let rAvg = rTotal / count;
  let gAvg = gTotal / count;
  let bAvg = bTotal / count;

  let avg = (rAvg + gAvg + bAvg) / 3;
  let rFactor = avg / rAvg;
  let gFactor = avg / gAvg;
  let bFactor = avg / bAvg;

  for (let i = 0; i < data.length; i += 4) {
    data[i] = Math.min(255, data[i] * rFactor);       // R
    data[i + 1] = Math.min(255, data[i + 1] * gFactor); // G
    data[i + 2] = Math.min(255, data[i + 2] * bFactor); // B
  }

  ctx.putImageData(imageData, 0, 0);

  fabric.Image.fromURL(canvasEl.toDataURL(), newImg => {
    newImg.set(originalProps);

    canvas.remove(activeObject);
    canvas.add(newImg);
    canvas.setActiveObject(newImg);
    canvas.requestRenderAll();
  });
}

document.getElementById('BtnCorAutm').addEventListener('click', applyAutoColor);

function applyAutoTone() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para aplicar o tom automático.');
    return;
  }

  const img = activeObject.getElement();
  const canvasEl = document.createElement('canvas');
  const ctx = canvasEl.getContext('2d');

  const originalProps = {
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    angle: activeObject.angle,
    left: activeObject.left,
    top: activeObject.top,
    width: activeObject.width,
    height: activeObject.height,
    flipX: activeObject.flipX,
    flipY: activeObject.flipY,
    originX: activeObject.originX,
    originY: activeObject.originY,
    filters: activeObject.filters || [],
    clipPath: activeObject.clipPath,
    objectIndex: canvas.getObjects().indexOf(activeObject)
  };

  canvasEl.width = img.naturalWidth;
  canvasEl.height = img.naturalHeight;

  if (originalProps.filters.length > 0) {
    fabric.util.applyFilters(canvasEl, originalProps.filters, {
      width: img.naturalWidth,
      height: img.naturalHeight
    });
  }

  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
  const data = imageData.data;

  const histR = new Array(256).fill(0);
  const histG = new Array(256).fill(0);
  const histB = new Array(256).fill(0);

  for (let i = 0; i < data.length; i += 4) {
    histR[data[i]]++;
    histG[data[i + 1]]++;
    histB[data[i + 2]]++;
  }

  function findCutoffPoints(histogram) {
    const totalPixels = histogram.reduce((a, b) => a + b, 0);
    const cutoffPercent = 0.005;
    
    let sumLow = 0;
    let lowCut = 0;
    while (sumLow < totalPixels * cutoffPercent && lowCut < 255) {
      sumLow += histogram[lowCut];
      lowCut++;
    }

    let sumHigh = 0;
    let highCut = 255;
    while (sumHigh < totalPixels * cutoffPercent && highCut > 0) {
      sumHigh += histogram[highCut];
      highCut--;
    }

    return { lowCut, highCut };
  }

  const cutoffsR = findCutoffPoints(histR);
  const cutoffsG = findCutoffPoints(histG);
  const cutoffsB = findCutoffPoints(histB);

  function adjustValue(value, low, high) {
    if (value <= low) return 0;
    if (value >= high) return 255;
    return Math.round((value - low) / (high - low) * 255);
  }

  for (let i = 0; i < data.length; i += 4) {
    data[i] = adjustValue(data[i], cutoffsR.lowCut, cutoffsR.highCut);
    data[i + 1] = adjustValue(data[i + 1], cutoffsG.lowCut, cutoffsG.highCut);
    data[i + 2] = adjustValue(data[i + 2], cutoffsB.lowCut, cutoffsB.highCut);
  }

  ctx.putImageData(imageData, 0, 0);

  fabric.Image.fromURL(canvasEl.toDataURL(), newImg => {
    newImg.set({
      ...originalProps,
      crossOrigin: 'anonymous'
    });

    canvas.remove(activeObject);

    if (originalProps.objectIndex >= 0) {
      canvas.insertAt(newImg, originalProps.objectIndex);
    } else {
      canvas.add(newImg);
    }

    canvas.setActiveObject(newImg);
    canvas.requestRenderAll();
  });
}

document.getElementById('BtnTomAutm').addEventListener('click', applyAutoTone);

function convertToBlackAndWhite() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para converter para preto e branco.');
    return;
  }

  const img = activeObject.getElement();
  const canvasEl = document.createElement('canvas');
  const ctx = canvasEl.getContext('2d');

  const originalProps = {
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    angle: activeObject.angle,
    left: activeObject.left,
    top: activeObject.top,
    width: activeObject.width,
    height: activeObject.height,
    flipX: activeObject.flipX,
    flipY: activeObject.flipY,
    originX: activeObject.originX,
    originY: activeObject.originY,
    filters: activeObject.filters || [],
    clipPath: activeObject.clipPath,
    objectIndex: canvas.getObjects().indexOf(activeObject)
  };

  canvasEl.width = img.naturalWidth;
  canvasEl.height = img.naturalHeight;

  if (originalProps.filters.length > 0) {
    fabric.util.applyFilters(canvasEl, originalProps.filters, {
      width: img.naturalWidth,
      height: img.naturalHeight
    });
  }

  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
  const data = imageData.data;

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const gray = Math.round(r * 0.299 + g * 0.587 + b * 0.114);
    data[i] = gray;
    data[i + 1] = gray;
    data[i + 2] = gray;
  }

  ctx.putImageData(imageData, 0, 0);

  fabric.Image.fromURL(canvasEl.toDataURL(), newImg => {
    newImg.set({
      ...originalProps,
      crossOrigin: 'anonymous'
    });

    canvas.remove(activeObject);

    if (originalProps.objectIndex >= 0) {
      canvas.insertAt(newImg, originalProps.objectIndex);
    } else {
      canvas.add(newImg);
    }

    canvas.setActiveObject(newImg);
    canvas.requestRenderAll();
  });
}

function invertColors() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para inverter as cores.');
    return;
  }

  const img = activeObject.getElement();
  const canvasEl = document.createElement('canvas');
  const ctx = canvasEl.getContext('2d');

  const originalProps = {
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    angle: activeObject.angle,
    left: activeObject.left,
    top: activeObject.top,
    width: activeObject.width,
    height: activeObject.height,
    flipX: activeObject.flipX,
    flipY: activeObject.flipY,
    originX: activeObject.originX,
    originY: activeObject.originY,
    filters: activeObject.filters || [],
    clipPath: activeObject.clipPath,
    objectIndex: canvas.getObjects().indexOf(activeObject)
  };

  canvasEl.width = img.naturalWidth;
  canvasEl.height = img.naturalHeight;

  if (originalProps.filters.length > 0) {
    fabric.util.applyFilters(canvasEl, originalProps.filters, {
      width: img.naturalWidth,
      height: img.naturalHeight
    });
  }

  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
  const data = imageData.data;

  for (let i = 0; i < data.length; i += 4) {
    data[i] = 255 - data[i];         
    data[i + 1] = 255 - data[i + 1];
    data[i + 2] = 255 - data[i + 2]; 
  }

  ctx.putImageData(imageData, 0, 0);

  fabric.Image.fromURL(canvasEl.toDataURL(), newImg => {
    newImg.set({
      ...originalProps,
      crossOrigin: 'anonymous'
    });

    canvas.remove(activeObject);

    if (originalProps.objectIndex >= 0) {
      canvas.insertAt(newImg, originalProps.objectIndex);
    } else {
      canvas.add(newImg);
    }

    canvas.setActiveObject(newImg);
    canvas.requestRenderAll();
  });
}

document.getElementById('Btn-PretoBranco').addEventListener('click', convertToBlackAndWhite);
document.getElementById('Btn-InverterCor').addEventListener('click', invertColors);

// ---------------- adicionar nitidez ----------------------------------
function addSharpness() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para adicionar nitidez.');
    return;
  }

  const img = activeObject.getElement();
  const canvasEl = document.createElement('canvas');
  const ctx = canvasEl.getContext('2d');

  const originalProps = {
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    angle: activeObject.angle,
    left: activeObject.left,
    top: activeObject.top,
    width: activeObject.width,
    height: activeObject.height,
    flipX: activeObject.flipX,
    flipY: activeObject.flipY,
    originX: activeObject.originX,
    originY: activeObject.originY,
    filters: activeObject.filters || [],
    clipPath: activeObject.clipPath,
    objectIndex: canvas.getObjects().indexOf(activeObject)
  };

  canvasEl.width = img.naturalWidth;
  canvasEl.height = img.naturalHeight;

  if (originalProps.filters.length > 0) {
    fabric.util.applyFilters(canvasEl, originalProps.filters, {
      width: img.naturalWidth,
      height: img.naturalHeight
    });
  }

  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
  const data = imageData.data;

  const kernel = [
    0, -1,  0,
   -1,  5, -1,
    0, -1,  0
  ];

  const width = canvasEl.width;
  const height = canvasEl.height;
  const outputData = new Uint8ClampedArray(data.length);

  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      for (let c = 0; c < 3; c++) { 
        const idx = (y * width + x) * 4 + c;
        let sum = 0;
        
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const srcIdx = ((y + ky) * width + (x + kx)) * 4 + c;
            sum += data[srcIdx] * kernel[(ky + 1) * 3 + (kx + 1)];
          }
        }
        
        outputData[idx] = sum;
      }
      
      outputData[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3];
    }
  }

  for (let i = 0; i < outputData.length; i++) {
    data[i] = outputData[i];
  }

  ctx.putImageData(imageData, 0, 0);

  fabric.Image.fromURL(canvasEl.toDataURL(), newImg => {
    newImg.set({
      ...originalProps,
      crossOrigin: 'anonymous'
    });

    canvas.remove(activeObject);

    if (originalProps.objectIndex >= 0) {
      canvas.insertAt(newImg, originalProps.objectIndex);
    } else {
      canvas.add(newImg);
    }

    canvas.setActiveObject(newImg);
    canvas.requestRenderAll();
  });
}

document.getElementById('Btn-Nitidez').addEventListener('click', addSharpness);

// ------------ brilho saturação matiz contraste -------------------------------
// Variáveis globais
let previewCanvas = null;
let previewContext = null;
let currentImage = null;

document.getElementById('Btn-BrilhoContraste').addEventListener('click', async () => {
  const activeObject = canvas.getActiveObject();
  
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem primeiro!');
    return;
  }

  try {
    originalImage = activeObject;
    await openBrightnessContrastModal(activeObject);
  } catch (error) {
    console.error('Erro ao abrir modal:', error);
    showCustomAlert('Erro ao preparar imagem para edição');
  }
});

function openBrightnessContrastModal(image) {
  const modal = document.getElementById('brightnessContrastModal');
  modal.style.display = 'flex';

  previewCanvas = document.getElementById('previewCanvas');
  previewContext = previewCanvas.getContext('2d');

  const img = new Image();
  img.src = image.toDataURL();
  img.onload = () => {
    const scale = Math.min(600 / img.width, 600 / img.height);
    previewCanvas.width = img.width * scale;
    previewCanvas.height = img.height * scale;
    previewContext.drawImage(img, 0, 0, previewCanvas.width, previewCanvas.height);
    currentImage = img;
    resetControls();
  };

  setupControls();
}

function resetControls() {
  document.getElementById('brightness').value = 0;
  document.getElementById('brightnessRange').value = 0;
  document.getElementById('contrast').value = 0;
  document.getElementById('contrastRange').value = 0;
  document.getElementById('saturation').value = 0;
  document.getElementById('saturationRange').value = 0;
  document.getElementById('hue').value = 0;
  document.getElementById('hueRange').value = 0;
}

function applyFilters() {
  if (!currentImage || !previewContext || !previewCanvas) return;

  const brightness = parseInt(document.getElementById('brightness').value);
  const contrast = parseInt(document.getElementById('contrast').value);
  const saturation = parseInt(document.getElementById('saturation').value);
  const hue = parseInt(document.getElementById('hue').value);

  previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
  previewContext.filter = `
    brightness(${100 + brightness}%)
    contrast(${100 + contrast}%)
    saturate(${100 + saturation}%)
    hue-rotate(${hue}deg)
  `;
  previewContext.drawImage(currentImage, 0, 0, previewCanvas.width, previewCanvas.height);
}

async function processLargeImage(sourceCanvas, filters) {
  const CHUNK_SIZE = 2048; // Tamanho do chunk para processamento
  const finalCanvas = document.createElement('canvas');
  finalCanvas.width = sourceCanvas.width;
  finalCanvas.height = sourceCanvas.height;
  const finalCtx = finalCanvas.getContext('2d');

  // Processa a imagem em chunks
  for (let y = 0; y < sourceCanvas.height; y += CHUNK_SIZE) {
    for (let x = 0; x < sourceCanvas.width; x += CHUNK_SIZE) {
      const chunkWidth = Math.min(CHUNK_SIZE, sourceCanvas.width - x);
      const chunkHeight = Math.min(CHUNK_SIZE, sourceCanvas.height - y);

      const chunkCanvas = document.createElement('canvas');
      chunkCanvas.width = chunkWidth;
      chunkCanvas.height = chunkHeight;
      const chunkCtx = chunkCanvas.getContext('2d');

      // Copia parte da imagem para o chunk
      chunkCtx.drawImage(sourceCanvas, 
        x, y, chunkWidth, chunkHeight,
        0, 0, chunkWidth, chunkHeight
      );

      // Aplica filtros no chunk
      chunkCtx.filter = filters;
      
      const processedChunk = document.createElement('canvas');
      processedChunk.width = chunkWidth;
      processedChunk.height = chunkHeight;
      const processedCtx = processedChunk.getContext('2d');
      processedCtx.drawImage(chunkCanvas, 0, 0);

      // Cola o chunk processado no canvas final
      finalCtx.drawImage(processedChunk, x, y);

      // Pequena pausa para evitar travamento do navegador
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }

  return finalCanvas;
}

async function applyChangesToOriginalImage() {
  if (!originalImage) return;

  // Capturar propriedades antes de qualquer alteração
  const originalProps = {
    scaleX: originalImage.scaleX,
    scaleY: originalImage.scaleY,
    angle: originalImage.angle,
    left: originalImage.left,
    top: originalImage.top,
    flipX: originalImage.flipX,
    flipY: originalImage.flipY,
    originX: originalImage.originX,
    originY: originalImage.originY,
    objectIndex: canvas.getObjects().indexOf(originalImage)
  };

  try {
    const loadingDiv = createLoadingIndicator();
    document.body.appendChild(loadingDiv);

    // Criar canvas temporário com dimensões otimizadas
    const tempCanvas = document.createElement('canvas');
    const scaleFactor = Math.min(1, 4096 / originalImage.width);
    tempCanvas.width = originalImage.width * scaleFactor;
    tempCanvas.height = originalImage.height * scaleFactor;
    
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(originalImage.getElement(), 0, 0, tempCanvas.width, tempCanvas.height);

    // Aplicar filtros
    const filters = getCurrentFilters();
    tempCtx.filter = filters;
    tempCtx.drawImage(tempCanvas, 0, 0);

    // Criar nova imagem Fabric.js
    const newImg = await createFabricImage(tempCanvas, originalProps);

    // Substituir a imagem no canvas
    replaceOriginalImage(newImg, originalProps.objectIndex);

    document.body.removeChild(loadingDiv);
  } catch (error) {
    console.error('Erro:', error);
    showCustomAlert('Erro ao processar imagem grande. Tente com resolução menor.');
  }
}

function createLoadingIndicator() {
  const div = document.createElement('div');
  div.style = 'position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.8); color:white; padding:20px; border-radius:5px; z-index:10000;';
  div.textContent = 'Processando imagem grande...';
  return div;
}

async function createFabricImage(canvas, props) {
  return new Promise((resolve, reject) => {
    canvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      fabric.Image.fromURL(url, img => {
        img.set({
          ...props,
          width: canvas.width,
          height: canvas.height,
          scaleX: props.scaleX * (originalImage.width / canvas.width),
          scaleY: props.scaleY * (originalImage.height / canvas.height)
        });
        resolve(img);
      }, { crossOrigin: 'anonymous' });
    }, 'image/png', 0.9);
  });
}

function replaceOriginalImage(newImg, originalIndex) {
  canvas.remove(originalImage);
  
  if (originalIndex >= 0 && originalIndex < canvas.getObjects().length) {
    canvas.insertAt(newImg, originalIndex);
  } else {
    canvas.add(newImg);
  }
  
  canvas.setActiveObject(newImg);
  canvas.requestRenderAll();
  originalImage = newImg; // Atualizar referência
}

function getCurrentFilters() {
  const brightness = parseInt(document.getElementById('brightness').value);
  const contrast = parseInt(document.getElementById('contrast').value);
  const saturation = parseInt(document.getElementById('saturation').value);
  const hue = parseInt(document.getElementById('hue').value);

  return `
    brightness(${100 + brightness}%)
    contrast(${100 + contrast}%)
    saturate(${100 + saturation}%)
    hue-rotate(${hue}deg)
  `;
}


function closeModal() {
  const modal = document.getElementById('brightnessContrastModal');
  modal.style.display = 'none';
  
  if (previewContext && previewCanvas) {
    previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
  }
  
  currentImage = null;
}

function setupControls() {
  const controls = ['brightness', 'contrast', 'saturation', 'hue'];
  
  controls.forEach(control => {
    const input = document.getElementById(control);
    const range = document.getElementById(`${control}Range`);
    
    if (input && range) {
      const newInput = input.cloneNode(true);
      const newRange = range.cloneNode(true);
      input.parentNode.replaceChild(newInput, input);
      range.parentNode.replaceChild(newRange, range);
      
      newInput.addEventListener('input', () => {
        newRange.value = newInput.value;
        applyFilters();
      });
      
      newRange.addEventListener('input', () => {
        newInput.value = newRange.value;
        applyFilters();
      });
    }
  });

  const saveButton = document.getElementById('saveAdjustments');
  const newSaveButton = saveButton.cloneNode(true);
  saveButton.parentNode.replaceChild(newSaveButton, saveButton);
  newSaveButton.addEventListener('click', async () => {
    await applyChangesToOriginalImage();
    closeModal();
  });

  const cancelButton = document.getElementById('cancelAdjustments');
  const newCancelButton = cancelButton.cloneNode(true);
  cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
  newCancelButton.addEventListener('click', closeModal);
}

// ------------- arrastar e soltar drag drop dragdrop ------------------------------------
canvas.wrapperEl.addEventListener('dragover', (e) => {
  e.preventDefault();
  e.stopPropagation();
  e.dataTransfer.dropEffect = 'copy';
});

canvas.wrapperEl.addEventListener('dragleave', (e) => {
  e.preventDefault();
  e.stopPropagation();
});

function validateFileType(file) {
  const validTypes = ['application/pdf', 'application/octet-stream'];
  return validTypes.includes(file.type) || file.type.startsWith('image/');
}

function getUniqueFileName(fileName) {
  const baseName = fileName.replace(/\.[^/.]+$/, "").replace(/[^a-zA-Z0-9]/g, "_");
  return baseName.substring(0, 20);
}

canvas.wrapperEl.addEventListener('drop', async (e) => {
  e.preventDefault();
  e.stopPropagation();
  const files = e.dataTransfer.files;
  
  if (files.length > 0) {
    for (const file of files) {
      if (file.type.startsWith('image/')) {
        await processImageFile(file, true);
      } else if (file.type === 'application/pdf') {
        await processPDFFile(file, true); 
      } else if (file.name.endsWith('.cloudapp')) {
        await processCloudAppFile(file);
      } else {
        showCustomAlert('Por favor, arraste apenas arquivos de imagem, PDF ou .cloudapp.');
      }
    }
  }
});

// ----------------- abrir imagem ou pdf menu --------------------------------
const fileInput = document.createElement('input');
fileInput.type = 'file';
fileInput.multiple = true;
fileInput.accept = 'image/*,.pdf,.cloudapp';
fileInput.style.display = 'none';
document.body.appendChild(fileInput);

async function processImageFile(file, center = true) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            fabric.Image.fromURL(event.target.result, (img) => {
                const fileName = getUniqueFileName(file.name);

                const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
                if (cloudFolha) {
                    const scaleX = cloudFolha.width / img.width;
                    const scaleY = cloudFolha.height / img.height;
                    const scale = Math.min(scaleX, scaleY); 

                    img.set({
                        left: cloudFolha.left + cloudFolha.width / 2,
                        top: cloudFolha.top + cloudFolha.height / 2,
                        originX: 'center',
                        originY: 'center',
                        scaleX: scale,
                        scaleY: scale,
                        fileName: fileName,
                        name: fileName,
                        originalFile: file.name
                    });

                    addObject(img);
                    canvas.setActiveObject(img);
                    canvas.requestRenderAll();
                }

                resolve(img);
            });
        };
        reader.readAsDataURL(file);
    });
}


async function processPDFFile(file, center = true) {
    const pdf = await pdfjsLib.getDocument({ url: URL.createObjectURL(file) }).promise;
    const numPages = pdf.numPages;
    const pdfName = getUniqueFileName(file.name);

    for (let pageNum = 1; pageNum <= numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);

        const scale = 4; 
        const viewport = page.getViewport({ scale });

        const canvasElement = document.createElement('canvas');
        const context = canvasElement.getContext('2d', { alpha: false });
        canvasElement.width = viewport.width;
        canvasElement.height = viewport.height;

        await page.render({
            canvasContext: context,
            viewport: viewport
        }).promise;

        const imgData = canvasElement.toDataURL('image/png'); 

        await new Promise((resolve) => {
            fabric.Image.fromURL(imgData, (img) => {
                const pageName = `${pdfName}_p${pageNum}`;

                const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
                if (cloudFolha) {
                    const scaleX = cloudFolha.width / img.width;
                    const scaleY = cloudFolha.height / img.height;
                    const finalScale = Math.min(scaleX, scaleY);

                    img.set({
                        left: cloudFolha.left + cloudFolha.width / 2,
                        top: cloudFolha.top + cloudFolha.height / 2,
                        originX: 'center',
                        originY: 'center',
                        scaleX: finalScale,
                        scaleY: finalScale,
                        fileName: pageName,
                        name: pageName,
                        originalFile: `${file.name} - Página ${pageNum}`,
                        isPdfPage: true,
                        pageNumber: pageNum
                    });

                    addObject(img);
                    canvas.setActiveObject(img);
                    canvas.requestRenderAll();
                }

                resolve();
            });
        });
    }
}


async function processCloudAppFile(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            const canvasState = JSON.parse(event.target.result);
            const cloudFolhaState = canvasState.cloudFolha;
            const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
            
            const preserveNames = (objects) => {
                objects.forEach(obj => {
                    if (obj.fileName) {
                        obj.name = obj.fileName;
                    }
                });
            };
            
            if (cloudFolha && cloudFolhaState) {
                cloudFolha.set({
                    width: cloudFolhaState.width,
                    height: cloudFolhaState.height
                });
                cloudFolha.setCoords();
            }
            
            canvas.loadFromJSON(canvasState, function () {
                preserveNames(canvas.getObjects());
                if (cloudFolha) {
                    const widthCm = cloudFolha.width / cmToPx;
                    const heightCm = cloudFolha.height / cmToPx;
                    document.getElementById('width-input').value = widthCm.toFixed(1);
                    document.getElementById('height-input').value = heightCm.toFixed(1);
                }
                resolve();
            });
        };
        reader.readAsText(file);
    });
}

document.getElementById('openImagePDFBtn').addEventListener('click', () => {
    fileInput.click();
});

fileInput.addEventListener('change', async (e) => {
    const files = e.target.files;
    
    if (files.length > 0) {
        for (const file of files) {
            try {
                if (file.type.startsWith('image/')) {
                    await processImageFile(file);
                } else if (file.type === 'application/pdf') {
                    await processPDFFile(file);
                } else if (file.name.endsWith('.cloudapp')) {
                    await processCloudAppFile(file);
                } else {
                    showCustomAlert('Por favor, selecione apenas arquivos de imagem, PDF ou .cloudapp.');
                }
            } catch (error) {
                console.error('Erro ao processar arquivo:', error);
                showCustomAlert('Erro ao processar o arquivo. Por favor, tente novamente.');
            }
        }
        
        canvas.requestRenderAll();
        updateLayersList();
        
        fileInput.value = '';
    }
});

// --------- exportar png jpg e pdf ----------------------------------
document.getElementById('export-png').addEventListener('click', () => {
  const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
  if (!cloudFolhaObj) return;

  const cloudFolhaBackup = {
    id: cloudFolhaObj.id,
    name: cloudFolhaObj.name,
    selectable: cloudFolhaObj.selectable,
    hoverCursor: cloudFolhaObj.hoverCursor,
    hasControls: cloudFolhaObj.hasControls,
    hasBorders: cloudFolhaObj.hasBorders,
    lockMovementX: cloudFolhaObj.lockMovementX,
    lockMovementY: cloudFolhaObj.lockMovementY
  };

  const originalState = canvas.toJSON();
  const originalZoom = canvas.getZoom();
  const originalViewportTransform = [...canvas.viewportTransform];
  const originalWidth = canvas.getWidth();
  const originalHeight = canvas.getHeight();

  canvas.setZoom(1);
  canvas.requestRenderAll();

  const TARGET_DPI = parseInt(document.getElementById('dpi-input').value) || 300;
  const BROWSER_DPI = 96;
  const dpiScale = TARGET_DPI / BROWSER_DPI;
  const marginCompensation = 0.1 * cmToPx * dpiScale;

  const exportWidth = cloudFolhaObj.width * dpiScale + marginCompensation;
  const exportHeight = cloudFolhaObj.height * dpiScale + marginCompensation;

  const exportCanvas = new fabric.Canvas(null, {
    width: exportWidth,
    height: exportHeight,
    backgroundColor: 'white'
  });

  const clipPath = new fabric.Rect({
    left: marginCompensation / 2,
    top: marginCompensation / 2,
    width: cloudFolhaObj.width * dpiScale,
    height: cloudFolhaObj.height * dpiScale,
    absolutePositioned: true
  });

  const objectsToExport = canvas.getObjects()
    .filter(obj => obj !== cloudFolhaObj && !obj.name?.includes('Guia'))
    .map(obj => {
      const clone = fabric.util.object.clone(obj);
      const relativeLeft = obj.left - cloudFolhaObj.left;
      const relativeTop = obj.top - cloudFolhaObj.top;

      clone.set({
        left: (relativeLeft * dpiScale) + (marginCompensation / 2),
        top: (relativeTop * dpiScale) + (marginCompensation / 2),
        scaleX: obj.scaleX * dpiScale,
        scaleY: obj.scaleY * dpiScale,
        clipPath: clipPath,
        selectable: false
      });

      return clone;
    });

  exportCanvas.add(...objectsToExport);
  exportCanvas.renderAll();

  const link = document.createElement('a');
  link.download = `CloudAppPNG_${TARGET_DPI}dpi.png`;
  link.href = exportCanvas.toDataURL({
    format: 'png',
    quality: 1.0,
    enableRetinaScaling: true
  });
  link.click();

  canvas.clear();
  canvas.loadFromJSON(originalState, () => {
    canvas.setDimensions({
      width: originalWidth,
      height: originalHeight
    });
    canvas.setViewportTransform(originalViewportTransform);
    canvas.setZoom(originalZoom);

    const restoredCloudFolha = canvas.getObjects().find(obj => obj.type === 'rect' && (!obj.name || obj.name === 'CloudFolha'));
    if (restoredCloudFolha) {
      restoredCloudFolha.set({
        ...cloudFolhaBackup,
        id: cloudFolhaBackup.id,
        name: 'CloudFolha',
        selectable: false,
        hoverCursor: 'default',
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true
      });
      canvas.sendToBack(restoredCloudFolha);
    }

    canvas.discardActiveObject();
    canvas.requestRenderAll();
    updateLayersList();
  });
});

document.getElementById('export-JPG').addEventListener('click', () => {
  const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
  if (!cloudFolhaObj) return;

  const cloudFolhaBackup = {
    id: cloudFolhaObj.id,
    name: cloudFolhaObj.name,
    selectable: cloudFolhaObj.selectable,
    hoverCursor: cloudFolhaObj.hoverCursor,
    hasControls: cloudFolhaObj.hasControls,
    hasBorders: cloudFolhaObj.hasBorders,
    lockMovementX: cloudFolhaObj.lockMovementX,
    lockMovementY: cloudFolhaObj.lockMovementY
  };

  const originalState = canvas.toJSON();
  const originalZoom = canvas.getZoom();
  const originalViewportTransform = [...canvas.viewportTransform];
  const originalWidth = canvas.getWidth();
  const originalHeight = canvas.getHeight();

  canvas.setZoom(1);
  canvas.requestRenderAll();

  const TARGET_DPI = parseInt(document.getElementById('dpijpg-input').value) || 300;
  const BROWSER_DPI = 96;
  const dpiScale = TARGET_DPI / BROWSER_DPI;
  const marginCompensation = 0.1 * cmToPx * dpiScale;

  const exportWidth = cloudFolhaObj.width * dpiScale + marginCompensation;
  const exportHeight = cloudFolhaObj.height * dpiScale + marginCompensation;

  const exportCanvas = new fabric.Canvas(null, {
    width: exportWidth,
    height: exportHeight,
    backgroundColor: 'white'
  });

  const clipPath = new fabric.Rect({
    left: marginCompensation / 2,
    top: marginCompensation / 2,
    width: cloudFolhaObj.width * dpiScale,
    height: cloudFolhaObj.height * dpiScale,
    absolutePositioned: true
  });

  const objectsToExport = canvas.getObjects()
    .filter(obj => obj !== cloudFolhaObj && !obj.name?.includes('Guia'))
    .map(obj => {
      const clone = fabric.util.object.clone(obj);
      const relativeLeft = obj.left - cloudFolhaObj.left;
      const relativeTop = obj.top - cloudFolhaObj.top;

      clone.set({
        left: (relativeLeft * dpiScale) + (marginCompensation / 2),
        top: (relativeTop * dpiScale) + (marginCompensation / 2),
        scaleX: obj.scaleX * dpiScale,
        scaleY: obj.scaleY * dpiScale,
        clipPath: clipPath,
        selectable: false
      });

      if (clone.type === 'i-text') {
        const strokeScale = dpiScale * (clone.strokeWidth > 0 ? 1.2 : 1); 
        clone.set({
          fontSize: clone.fontSize * dpiScale,
          strokeWidth: clone.strokeWidth * strokeScale, 
          scaleX: 1,
          scaleY: 1,
          paintFirst: 'stroke',
          left: clone.left - (clone.strokeWidth * strokeScale / 2),
          top: clone.top - (clone.strokeWidth * strokeScale / 2)
        });

        clone.width = clone.width + (clone.strokeWidth * strokeScale);
        clone.height = clone.height + (clone.strokeWidth * strokeScale);
      }

      return clone;
    });

  exportCanvas.add(...objectsToExport);
  exportCanvas.renderAll();

  const link = document.createElement('a');
  link.download = `CloudAppJPG_${TARGET_DPI}dpi.jpg`;
  link.href = exportCanvas.toDataURL({
    format: 'jpeg',
    quality: 1.0,
    enableRetinaScaling: true
  });
  link.click();

  canvas.clear();
  canvas.loadFromJSON(originalState, () => {
    canvas.setDimensions({
      width: originalWidth,
      height: originalHeight
    });
    canvas.setViewportTransform(originalViewportTransform);
    canvas.setZoom(originalZoom);

    const restoredCloudFolha = canvas.getObjects().find(obj => obj.type === 'rect' && (!obj.name || obj.name === 'CloudFolha'));
    if (restoredCloudFolha) {
      restoredCloudFolha.set({
        ...cloudFolhaBackup,
        id: cloudFolhaBackup.id,
        name: 'CloudFolha',
        selectable: false,
        hoverCursor: 'default',
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true
      });
      canvas.sendToBack(restoredCloudFolha);
    }

    canvas.discardActiveObject();
    canvas.requestRenderAll();
    updateLayersList();
  });
});

document.getElementById('export-PDF').addEventListener('click', () => {
  if (typeof window.jspdf === 'undefined') {
    console.error('jsPDF não está carregado. Verifique se a biblioteca foi importada corretamente.');
	showCustomAlert('Erro: biblioteca PDF não encontrada');
    return;
  }

  const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
  if (!cloudFolhaObj) {
    console.error('CloudFolha não encontrado');
    return;
  }

  try {
    const cloudFolhaBackup = {
      id: cloudFolhaObj.id,
      name: cloudFolhaObj.name,
      selectable: cloudFolhaObj.selectable,
      hoverCursor: cloudFolhaObj.hoverCursor,
      hasControls: cloudFolhaObj.hasControls,
      hasBorders: cloudFolhaObj.hasBorders,
      lockMovementX: cloudFolhaObj.lockMovementX,
      lockMovementY: cloudFolhaObj.lockMovementY
    };

    const originalState = canvas.toJSON();
    const originalZoom = canvas.getZoom();
    const originalViewportTransform = [...canvas.viewportTransform];
    const originalWidth = canvas.getWidth();
    const originalHeight = canvas.getHeight();

    canvas.setZoom(1);
    canvas.requestRenderAll();

    const TARGET_DPI = parseInt(document.getElementById('dpipdf-input').value) || 300;
    const BROWSER_DPI = 96;
    const dpiScale = TARGET_DPI / BROWSER_DPI;
    const marginCompensation = 0.1 * cmToPx * dpiScale;

    const pdfWidth = cloudFolhaObj.width;
    const pdfHeight = cloudFolhaObj.height;

    console.log('Dimensões PDF:', { pdfWidth, pdfHeight, dpiScale });

    const exportCanvas = new fabric.Canvas(null, {
      width: pdfWidth * dpiScale + marginCompensation,
      height: pdfHeight * dpiScale + marginCompensation,
      backgroundColor: null
    });

    const clipPath = new fabric.Rect({
      left: marginCompensation / 2,
      top: marginCompensation / 2,
      width: cloudFolhaObj.width * dpiScale,
      height: cloudFolhaObj.height * dpiScale,
      absolutePositioned: true
    });

    const objectsToExport = canvas.getObjects()
      .filter(obj => obj !== cloudFolhaObj && !obj.name?.includes('Guia'))
      .map(obj => {
        const clone = fabric.util.object.clone(obj);
        const relativeLeft = obj.left - cloudFolhaObj.left;
        const relativeTop = obj.top - cloudFolhaObj.top;

        clone.set({
          left: (relativeLeft * dpiScale) + (marginCompensation / 2),
          top: (relativeTop * dpiScale) + (marginCompensation / 2),
          scaleX: obj.scaleX * dpiScale,
          scaleY: obj.scaleY * dpiScale,
          clipPath: clipPath,
          selectable: false
        });

        if (clone.type === 'i-text') {
          const strokeScale = dpiScale * (clone.strokeWidth > 0 ? 1.2 : 1); 
          clone.set({
            fontSize: clone.fontSize * dpiScale,
            strokeWidth: clone.strokeWidth * strokeScale, 
            scaleX: 1,
            scaleY: 1,
            paintFirst: 'stroke',
            left: clone.left - (clone.strokeWidth * strokeScale / 2),
            top: clone.top - (clone.strokeWidth * strokeScale / 2)
          });

          clone.width = clone.width + (clone.strokeWidth * strokeScale);
          clone.height = clone.height + (clone.strokeWidth * strokeScale);
        }

        return clone;
      });

    exportCanvas.add(...objectsToExport);
    exportCanvas.renderAll();

    const imgData = exportCanvas.toDataURL({
      format: 'png',
      quality: 1.0,
      enableRetinaScaling: true
    });

    console.log('Imagem gerada com sucesso');

    const pdfWidth_mm = pdfWidth * 0.264583;
    const pdfHeight_mm = pdfHeight * 0.264583;

    console.log('Dimensões em mm:', { pdfWidth_mm, pdfHeight_mm });

    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({
      orientation: pdfWidth > pdfHeight ? 'landscape' : 'portrait',
      unit: 'mm',
      format: [pdfWidth_mm, pdfHeight_mm]
    });

    pdf.addImage(
      imgData,
      'PNG',
      0,
      0,
      pdfWidth_mm,
      pdfHeight_mm,
      undefined,
      'FAST'
    );

    console.log('Imagem adicionada ao PDF');
    pdf.save(`CloudAppPDF_${TARGET_DPI}dpi.pdf`);
    console.log('PDF salvo com sucesso');

    canvas.clear();
    canvas.loadFromJSON(originalState, () => {
      canvas.setDimensions({
        width: originalWidth,
        height: originalHeight
      });
      canvas.setViewportTransform(originalViewportTransform);
      canvas.setZoom(originalZoom);

      const restoredCloudFolha = canvas.getObjects().find(obj => obj.type === 'rect' && (!obj.name || obj.name === 'CloudFolha'));
      if (restoredCloudFolha) {
        restoredCloudFolha.set({
          ...cloudFolhaBackup,
          id: cloudFolhaBackup.id,
          name: 'CloudFolha',
          selectable: false,
          hoverCursor: 'default',
          hasControls: false,
          hasBorders: false,
          lockMovementX: true,
          lockMovementY: true
        });
        canvas.sendToBack(restoredCloudFolha);
      }

      canvas.discardActiveObject();
      canvas.requestRenderAll();
      updateLayersList();
    });

  } catch (error) {
    console.error('Erro ao gerar PDF:', error);
	showCustomAlert('Erro ao gerar PDF');
  }
});


// ----------------- Opacidade e exportar png menu superior -----------------------------
 const generalControls = document.querySelector('.general-controls');
  const opacityInput = document.getElementById('opacity-input');
  const exportPngButton = document.getElementById('export-png-selected');

  function updateOpacity() {
    const activeObjects = canvas.getActiveObjects();
    if (activeObjects.length === 1) {
      const obj = activeObjects[0];
      opacityInput.value = Math.round(obj.opacity * 100);
      generalControls.style.display = 'block';
    } else if (activeObjects.length > 1) {
      opacityInput.value = '';
      generalControls.style.display = 'block';
    } else {
      generalControls.style.display = 'none';
    }
  }

  opacityInput.addEventListener('input', () => {
    const activeObjects = canvas.getActiveObjects();
    const newOpacity = parseFloat(opacityInput.value) / 100;
    activeObjects.forEach(obj => {
      obj.set('opacity', newOpacity);
      obj.dirty = true;
    });
    canvas.requestRenderAll();
  });

  function exportSelectedObjectsToPNG() {
    const activeObjects = canvas.getActiveObjects();
    if (activeObjects.length === 0) {
      showCustomAlert('Nenhum objeto selecionado para exportar.');
      return;
    }

    const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
    const cloudFolhaBackup = cloudFolhaObj ? {
      id: cloudFolhaObj.id,
      name: cloudFolhaObj.name,
      selectable: cloudFolhaObj.selectable,
      hoverCursor: cloudFolhaObj.hoverCursor,
      hasControls: cloudFolhaObj.hasControls,
      hasBorders: cloudFolhaObj.hasBorders,
      lockMovementX: cloudFolhaObj.lockMovementX,
      lockMovementY: cloudFolhaObj.lockMovementY
    } : {};

    const originalState = canvas.toJSON();
    const originalZoom = canvas.getZoom();
    const originalViewportTransform = [...canvas.viewportTransform];
    const originalWidth = canvas.getWidth();
    const originalHeight = canvas.getHeight();

    const tempCanvas = new fabric.StaticCanvas(null, {
      backgroundColor: 'transparent'
    });

    const clonedObjects = activeObjects.map(obj => fabric.util.object.clone(obj));
    clonedObjects.forEach(obj => {
      tempCanvas.add(obj);
    });

    const group = new fabric.Group(clonedObjects, {
      left: 0,
      top: 0,
      originX: 'left',
      originY: 'top'
    });
    tempCanvas.add(group);
    tempCanvas.requestRenderAll();

    const groupBounds = group.getBoundingRect();
    const width = groupBounds.width;
    const height = groupBounds.height;

    tempCanvas.setDimensions({ width, height });

    const dataUrl = tempCanvas.toDataURL({
      format: 'png',
      quality: 1.0,
      enableRetinaScaling: true
    });

    const downloadLink = document.createElement('a');
    downloadLink.href = dataUrl;
    downloadLink.download = 'CloudApp_Objetos.png';
    downloadLink.click();

    tempCanvas.dispose();

    canvas.clear();
    canvas.loadFromJSON(originalState, () => {
      canvas.setDimensions({
        width: originalWidth,
        height: originalHeight
      });
      canvas.setViewportTransform(originalViewportTransform);
      canvas.setZoom(originalZoom);

      if (cloudFolhaObj) {
        const restoredCloudFolha = canvas.getObjects().find(obj => obj.type === 'rect' && (!obj.name || obj.name === 'CloudFolha'));
        if (restoredCloudFolha) {
          restoredCloudFolha.set({
            ...cloudFolhaBackup,
            id: cloudFolhaBackup.id,
            name: 'CloudFolha',
            selectable: false,
            hoverCursor: 'default',
            hasControls: false,
            hasBorders: false,
            lockMovementX: true,
            lockMovementY: true
          });
          canvas.sendToBack(restoredCloudFolha);
        }
      }

      canvas.discardActiveObject();
      canvas.requestRenderAll();
      updateLayersList();
    });
  }

  exportPngButton.addEventListener('click', exportSelectedObjectsToPNG);

  canvas.on('selection:created', () => {
    updateDimensionInputs();
    updateLayersList();
    updateTextStylingControls();
    updateOpacity();
  });

  canvas.on('selection:updated', () => {
    updateDimensionInputs();
    updateLayersList();
    updateTextStylingControls();
    updateOpacity();
  });

  canvas.on('selection:cleared', () => {
    updateDimensionInputs();
    updateLayersList();
    const textStylingControls = document.querySelector('.text-styling-controls');
    textStylingControls.style.display = 'none';
    updateOpacity();
  });

  updateOpacity();
  
  
  // ------------- importar em svg ------------------------------

document.getElementById('import-svg').addEventListener('click', () => {
  const fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = '.svg';
  fileInput.style.display = 'none';
  document.body.appendChild(fileInput);
  fileInput.click();

  fileInput.addEventListener('change', handleSVGImport);

  document.body.removeChild(fileInput);
});

function handleSVGImport(event) {
  const file = event.target.files[0];
  if (file && file.type === 'image/svg+xml') {
    const reader = new FileReader();
    reader.onload = function(e) {
      const svgContent = e.target.result;

      fabric.loadSVGFromString(svgContent, function(objects, options) {
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        objects.forEach((obj) => {
          const objBounds = obj.getBoundingRect();
          minX = Math.min(minX, objBounds.left);
          minY = Math.min(minY, objBounds.top);
          maxX = Math.max(maxX, objBounds.left + objBounds.width);
          maxY = Math.max(maxY, objBounds.top + objBounds.height);
        });

        const originalWidth = maxX - minX;
        const originalHeight = maxY - minY;

        const scaleX = cloudFolha.width / originalWidth;
        const scaleY = cloudFolha.height / originalHeight;
        const scale = Math.min(scaleX, scaleY);

        objects.forEach((obj) => {
          const originalFill = obj.fill;
          const originalStroke = obj.stroke;

          const normalizedLeft = (obj.left - minX) * scale;
          const normalizedTop = (obj.top - minY) * scale;

          obj.set({
            left: normalizedLeft + (cloudFolha.left + cloudFolha.width / 2),
            top: normalizedTop + (cloudFolha.top + cloudFolha.height / 2),
            scaleX: obj.scaleX * scale,
            scaleY: obj.scaleY * scale,
            strokeWidth: obj.strokeWidth || 1,
            stroke: originalStroke || '#000000',
            fill: originalFill || 'transparent',
            objectCaching: false,
            perPixelTargetFind: true,
            strokeUniform: true,
            cornerColor: '#0066ff',
            cornerSize: 12,
            cornerStyle: 'circle',
            transparentCorners: false,
            hasBorders: true,
            hasControls: true,
            selectable: true
          });

          canvas.add(obj);
          obj.setCoords();
        });

        const allObjects = canvas.getObjects().filter(obj => obj !== cloudFolha);
        if (allObjects.length > 0) {
          const selection = new fabric.ActiveSelection(allObjects, { canvas: canvas });
          selection.center();
          canvas.discardActiveObject();
          canvas.setActiveObject(selection);
        }

        canvas.requestRenderAll();
        updateLayersList();
      });
    };
    reader.readAsText(file);
  } else {
    showCustomAlert('Por favor, selecione um arquivo SVG válido.');
  }
}
    });
  </script>
</body>
</html>
