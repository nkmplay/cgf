<html><head><base href="https://nkmplay.github.io/cgf/">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CloudPhoto Editor</title>
    <script src="https://nkmplay.github.io/cgf/scripts/fabric.min.js"></script>
    <script src="https://nkmplay.github.io/cgf/scripts/html2canvas.min.js"></script>
    <script src="https://nkmplay.github.io/cgf/scripts/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://nkmplay.github.io/cgf/scripts/pdf.worker.min.js';</script>
    <link rel="stylesheet" href="https://nkmplay.github.io/cgf/scripts/cropper.min.css">
    <script src="https://nkmplay.github.io/cgf/scripts/cropper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.4.0/dist/pdf-lib.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #categories-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 60px;
            bottom: 0;
            background-color: #0f3460;
            z-index: 95;
            display: flex;
            flex-direction: column;
            color: white;
            font-size: 17px;
            letter-spacing: 2px;
        }

        .category-item {
            flex: 1;
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 10px 0;
            transition: background-color 0.3s;
            font-family: Arial, sans-serif;
            font-weight: bold;
        }

        .category-item:hover {
            background-color: #1a4b8c;
        }

        .category-item.active {
            background-color: #1a4b8c;
        }

        #left-menu {
            position: fixed;
            top: 0;
            left: 63px;
            width: 300px;
            bottom: 0;
            background-color: #0f3460;
            z-index: 90;
            padding: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        #left-menu::-webkit-scrollbar {
            width: 8px;
        }

        #left-menu::-webkit-scrollbar-track {
            background: #0f3460;
        }

        #left-menu::-webkit-scrollbar-thumb {
            background: #1a4b8c;
            border-radius: 4px;
        }

        #left-menu::-webkit-scrollbar-thumb:hover {
            background: #235ab4;
        }

#canvas-container {
    position: fixed;
    top: 0;
    left: 366px;
    right: 230px; /* Adicionar esta linha */
    bottom: 0;
    background-color: transparent;
    overflow: hidden;
}

        .separator-vertical {
            width: 2px;
            height: 30px;
            background-color: #92c1ff;
            margin: 0 5px;
        }

        .separator {
            height: 2px;
            background-color: #92c1ff;
            margin: 10px 0;
        }

        button, .menu-item {
            background-color: #1a4b8c;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 4px 0;
            border-radius: 4px;
            width: 100%;
            cursor: pointer;
            font-size: 15px;
        }

        button:hover, .menu-item:hover {
            background-color: #235ab4;
        }

        #fileInput {
            display: none;
        }

        .menu-content {
            display: none;
        }

        .menu-content.active {
            display: block;
        }

        #menu-separator {
            position: fixed;
            top: 0;
            left: 60px;
            width: 3px;
            bottom: 0;
            background-color: #235ab4;
            z-index: 92;
        }

        h3 {
            font-size: 20px !important;
            text-align: center;
            font-weight: bold;
        }

        .dimension-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .dimension-input {
            width: 60px;
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #235ab4;
            background: #1a4b8c;
            color: white;
            font-size: 12px;
        }

        .dimension-label {
            font-size: 12px;
        }

        .export-options {
            display: none;
            padding: 10px 0;
        }

        .export-options.active {
            display: block;
        }

        .resolution-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .resolution-control input {
            width: 80px;
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #235ab4;
            background: #1a4b8c;
            color: white;
            font-size: 12px;
        }

        .export-btn {
            margin: 5px 0;
        }

        .image-dimension-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px 0;
            gap: 10px;
        }

        .image-dimension-input {
            width: 60px;
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #235ab4;
            background: #1a4b8c;
            color: white;
            font-size: 12px;
        }

        .image-dimension-label {
            font-size: 12px;
        }

        .duplicate-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .duplicate-input {
            width: 50px;
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #235ab4;
            background: #1a4b8c;
            color: white;
            font-size: 12px;
        }

        .highlight-button {
            background-color: #ffd700 !important;
            height: 50px !important;
            font-weight: bold;
            margin: 10px 0 !important;
            color: black !important;
        }

        .guides-menu {
            display: none;
            margin-top: 10px;
        }

        .guides-menu.active {
            display: block;
        }

        .guides-options {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .guides-options .menu-item.active {
            background-color: #235ab4 !important;
        }

        .guides-options .menu-item {
            flex: 1;
            margin-right: 5px;
        }

        .guides-options .menu-item:last-child {
            margin-right: 0;
        }

        .guides-position {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
        }

        .guides-position span {
            margin-right: 10px;
        }
.version-badge {
    position: fixed;
    bottom: 5px; /* Mudando de 'top' para 'bottom' */
    left: 400px;
    right: 250px;
    background-color: #ffd700;
    color: Black;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 20px;
    font-family: Arial, sans-serif;
    z-index: 100;
    pointer-events: none;
    text-align: center;
}
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: #0f3460;
            height: 600px;
            max-width: 90%;
            display: flex;
            flex-direction: column;
            border-radius: 8px;
            overflow: hidden;
        }

        .modal-body {
            height: 550px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .modal-footer {
            height: 50px;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 0 10px;
            background: #1a4b8c;
        }

        .modal-footer button {
            margin: 0 5px;
            padding: 5px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .modal-footer .save-btn {
            background: #ffd700;
            color: black;
        }

        .modal-footer .cancel-btn {
            background: #ff4444;
            color: white;
        }

        .crop-container {
            max-height: 550px;
            max-width: 100%;
        }

        .crop-container img {
            max-width: 100%;
            max-height: 550px;
        }

        .text-controls {
            padding: 10px;
        }

        .control-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .text-input {
            width: 100%;
            padding: 4px;
            background: #1a4b8c;
            color: white;
            border: 1px solid #235ab4;
            border-radius: 4px;
        }

        .gradient-stops {
            margin-bottom: 10px;
        }

        .gradient-stop {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 5px;
        }

        .gradient-color {
            width: 50px;
        }

        .gradient-position {
            width: 60px;
            padding: 4px;
            background: #1a4b8c;
            color: white;
            border: 1px solid #235ab4;
            border-radius: 4px;
        }

        .remove-stop {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            cursor: pointer;
        }

        .gradient-angle {
            margin-top: 10px;
        }

        input[type="color"] {
            width: 100%;
            height: 30px;
            padding: 0;
            border: none;
            border-radius: 4px;
            background: #1a4b8c;
        }
        .font-label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .font-select {
            width: 100%;
            height: 40px;
            font-size: 20px;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #235ab4;
            background: #1a4b8c;
            color: white;
        }
        /* Add to the existing <style> section */
        #removeColorModal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: none;
            justify-content: center;
            align-items: center;
        }

#removeColorModal .modal-content {
    width: 95%;
    height: 95%;
    max-width: none;
    max-height: none;
    display: flex;
    flex-direction: column;
    background-color: #0f3460;
    border-radius: 8px;
    overflow: hidden;
}

#removeColorModal .modal-body {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    padding: 10px;
}

#removeColorModal .modal-footer {
    height: 60px;
    background-color: #1a4b8c;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 10px;
}

#removeColorCanvas {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
}

        #sensitivityRange {
            width: 100px;
        }

        .menu-item.active {
            background-color: #ffd700 !important;
            color: black !important;
        }
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.modal-content {
    background: #0f3460;
    border-radius: 8px;
    padding: 10px; /* Padding interno */
    max-width: 400px;
    width: auto; /* Ajusta a largura ao conteúdo */
    min-width: 250px; /* Largura mínima */
    height: auto; /* Altura ajustada ao conteúdo */
	max-height: 100px;
    color: white;
    text-align: center;
    position: relative;
    box-sizing: border-box; /* Garante que o padding não aumente o tamanho total */
}

.modal-body {
    margin: 0; /* Remove margens desnecessárias */
    padding: 0; /* Remove padding interno */
    word-wrap: break-word; /* Quebra de texto para não ultrapassar o modal */
    line-height: 1.5; /* Espaçamento entre linhas */
}
#cropperModal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    z-index: 9999;
    display: none;
    justify-content: center;
    align-items: center;
}

#cropperModal .modal-content {
    width: 95%;
    height: 95%;
    max-width: none;
    max-height: none;
    display: flex;
    flex-direction: column;
    background-color: #0f3460;
    border-radius: 8px;
    overflow: hidden;
}

#cropperModal .modal-body {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    padding: 10px;
}

#cropperModal .modal-footer {
    height: 50px;
    display: flex;
    justify-content: flex-end;
    align-items: center;
    padding: 0 10px;
    background: #1a4b8c;
}
.menu-right {
    position: fixed;
    right: 0;
    top: 0;
    width: 200px;
    background-color: #0f3460;
    height: 100%;
    padding: 20px;
    color: white;
    box-shadow: -2px 0 5px rgba(0,0,0,0.2);
    z-index: 90;
}

.layers-container {
    display: flex;
    flex-direction: column;
    height: calc(100% - 30px);
    margin-bottom: 30px;
}

.layers-list-wrapper {
    flex: 1;
    overflow-y: auto;
    margin-bottom: 10px;
}

.layers-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.layers-list li {
    padding: 10px;
    border-bottom: 1px solid #2861b3;
    cursor: pointer;
    user-select: none;
}

.layers-list li:hover {
    background-color: #1a4b8c;
}

.layers-list li.selected {
    color: yellow;
}

.layers-list li.over {
    border-top: 2px solid yellow;
}

.layers-list li.dragging {
    opacity: 0.5;
    background-color: #1a4b8c;
}

.layers-buttons {
    display: flex;
    gap: 10px;
    margin-top: auto;
    padding-bottom: 5px;
}

.layer-btn {
    flex: 1;
    background-color: #1a4b8c;
    color: white;
    padding: 8px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 13px;
}

.layer-btn:hover {
    background-color: #2861b3;
}
.mini-highlight-button {
    background-color: #ffd700 !important;
    color: black !important;
    font-weight: bold;
    padding: 2px 6px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    height: 25px;
    width: auto;
    min-width: 25px;
    margin: 0 5px;
}

.mini-highlight-button:hover {
    background-color: #ffed4a !important;
}

    </style>
</head>
<body>
    <div id="categories-menu">
        <div class="category-item" data-category="documento">DOCUMENTO</div>
        <div class="category-item active" data-category="editar">EDITAR</div>
        <div class="category-item" data-category="texto">TEXTO</div>
        <div class="category-item" data-category="formas">FORMAS</div>
        <div class="category-item" data-category="filtros">FILTROS</div>
    </div>
    <div id="menu-separator"></div>
    <div id="left-menu">
        <div id="menu-documento" class="menu-content">
            <h3>Tamanho da Folha:</h3>
<div class="dimension-controls">
    <span class="dimension-label">&#x2194;</span>
    <input type="number" id="width-input" class="dimension-input" value="21" min="1" step="0.1">
    <button id="invertDimensionsBtn" class="mini-highlight-button">⇅</button>
    <span class="dimension-label">&#x2195;</span>
    <input type="number" id="height-input" class="dimension-input" value="29.7" min="1" step="0.1">
</div>
            <div class="separator"></div>
            <button id="openDocumentBtn" class="menu-item">Abrir Documento</button>
            <button id="saveDocumentBtn" class="menu-item">Salvar Documento</button>
            <div class="separator"></div>
            <button id="addGuidesBtn" class="menu-item">Adicionar Guias</button>
            <div id="guidesMenu" class="guides-menu">
                <div class="guides-options">
                    <button id="horizontalGuideBtn" class="menu-item active">Horizontal</button>
                    <button id="verticalGuideBtn" class="menu-item">Vertical</button>
                </div>
                <div class="guides-options">
                    <button id="singleGuideBtn" class="menu-item active">Uma Guia</button>
                    <button id="multipleGuidesBtn" class="menu-item">Várias Guias</button>
                </div>
                <div class="guides-position">
                    <span>Posição (cm):</span>
                    <input type="number" id="guidePositionInput" class="dimension-input" value="1" min="1" step="0.1">
                </div>
                <button id="addGuideBtn" class="menu-item">Adicionar</button>
            </div>
            <div class="separator"></div>
            <button id="addDefaultGuidesBtn" class="menu-item">Adicionar Guias Padrão</button>
            <button id="removeGuidesBtn" class="menu-item">Apagar Guias</button>
            <div class="separator"></div>
            <button id="exportButton" class="menu-item">Exportar</button>
            <div id="exportOptions" class="export-options">
                <div class="resolution-control">
                    <span>Resolução:</span>
                    <input type="number" id="resolutionInput" value="150" min="72" max="2400">
                </div>
                <button class="menu-item export-btn" data-format="png">PNG</button>
                <button class="menu-item export-btn" data-format="jpg">JPG</button>
                <button class="menu-item export-btn" id="exportPdfBtn" data-format="pdf">PDF</button>
            </div>
        </div>
        <div id="menu-editar" class="menu-content active">
            <button id="loadImageBtn2" class="highlight-button">Carregar Imagem</button>
            <input type="file" id="fileInput" accept="image/*">
			<div class="image-dimension-controls">
				<span class="image-dimension-label">&#x2194;</span>
				<input type="number" id="image-width-input" class="image-dimension-input" value="0" min="0.1" step="0.1">
				<button id="invertObjectDimensionsBtn" class="mini-highlight-button">⇅</button>
				<span class="image-dimension-label">&#x2195;</span>
				<input type="number" id="image-height-input" class="image-dimension-input" value="0" min="0.1" step="0.1">
			</div>
            <div class="separator"></div>
            <button id="cropImageBtn" class="menu-item">Recortar</button>
            <div class="separator"></div>
            <div class="duplicate-control">
                <button id="btnPincel" class="menu-item" style="width: 100%;">Pincel, Borracha e Balde</button>
            </div>
            <div class="separator"></div>
            <button id="removeColorBtn" class="menu-item">Remover Cor</button>
            <div class="separator"></div>
            <button id="aiRemoverBtn" class="menu-item" style="color: red;">Removedor IA</button>
			<button id="vectorizePBBtn" class="menu-item" style="color: red;">Vetorizar PB</button>
            <div class="separator"></div>
            <div class="duplicate-control">
                <button id="duplicateImageBtn" class="menu-item" style="margin-right: 5px;">Duplicar</button>
                <input type="number" id="duplicateInput" class="duplicate-input" value="1" min="1" step="1">
            </div>
            <div class="duplicate-control">
                <button id="organizeBtn" class="menu-item" style="margin-right: 5px;">Organizar</button>
                <input type="number" id="organizeInput" class="duplicate-input" value="0" min="1" step="0.1">
            </div>
            <div class="duplicate-control">
                <button id="alignHorizontalBtn" class="menu-item" style="width: 48%; margin-right: 4%;">Alinhar &#x2194;</button>
                <button id="alignVerticalBtn" class="menu-item" style="width: 48%;">Alinhar &#x2195;</button>
            </div>
            <div class="duplicate-control">
                <button id="mirrorHorizontalBtn" class="menu-item" style="width: 48%; margin-right: 4%;">Espelhar &#x2194;</button>
                <button id="mirrorVerticalBtn" class="menu-item" style="width: 48%;">Espelhar &#x2195;</button>
            </div>
            <div class="duplicate-control">
                <button id="rotateBtn" class="menu-item" style="margin-right: 5px;">Girar</button>
                <input type="number" id="rotateInput" class="duplicate-input" value="90" min="0" step="1">
            </div>
            <div class="separator"></div>
            <button id="exportSelectedImageBtn" class="menu-item">Exportar Imagem Selecionada</button>
        </div>
        <div id="menu-texto" class="menu-content">
            <button id="addTextBtn" class="highlight-button">Adicionar Texto</button>
            <div class="separator"></div>
            <div class="text-controls">
                <div class="control-group">
                    <label for="fontSelect" class="font-label">Fonte:</label>
                    <select id="fontSelect" class="text-input font-select">
                    <option value="Arial" style="font-family: Arial;">Arial</option>
                      <option value="Arial Black" style="font-family: 'Arial Black';">Arial Black</option>
                      <option value="Brush Script MT" style="font-family: 'Brush Script MT';">Brush Script MT</option>
                      <option value="Bookman Old Style" style="font-family: 'Bookman Old Style';">Bookman Old Style</option>
                      <option value="Comic Sans MS" style="font-family: 'Comic Sans MS';">Comic Sans MS</option>
                      <option value="Courier" style="font-family: Courier;">Courier</option>
                      <option value="Dancing Script" style="font-family: 'Dancing Script';">Dancing Script</option>
                      <option value="Impact" style="font-family: Impact;">Impact</option>
                      <option value="Lucida Handwriting" style="font-family: 'Lucida Handwriting';">Lucida Handwriting</option>
                      <option value="Lucida Sans Unicode" style="font-family: 'Lucida Sans Unicode';">Lucida Sans Unicode</option>
                      <option value="Papyrus" style="font-family: Papyrus;">Papyrus</option>
                      <option value="Segoe Print" style="font-family: 'Segoe Print';">Segoe Print</option>
                      <option value="Segoe Script" style="font-family: 'Segoe Script';">Segoe Script</option>
                      <option value="Segoe UI" style="font-family: 'Segoe UI';">Segoe UI</option>
                      <option value="Times New Roman" style="font-family: 'Times New Roman';">Times New Roman</option>
                      <option value="Trebuchet MS" style="font-family: 'Trebuchet MS';">Trebuchet MS</option>
                      <option value="Verdana" style="font-family: Verdana;">Verdana</option>
                      <option value="Monotype Corsiva" style="font-family: 'Monotype Corsiva';">Monotype Corsiva</option>
                      <option value="Mistral" style="font-family: Mistral;">Mistral</option>
                      <option value="Freestyle Script" style="font-family: 'Freestyle Script';">Freestyle Script</option>
                      <option value="Bradley Hand ITC" style="font-family: 'Bradley Hand ITC';">Bradley Hand ITC</option>
                      <option value="Edwardian Script ITC" style="font-family: 'Edwardian Script ITC';">Edwardian Script ITC</option>
                      <option value="Vivaldi" style="font-family: Vivaldi;">Vivaldi</option>
                      <option value="Rage Italic" style="font-family: 'Rage Italic';">Rage Italic</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Tamanho:</label>
                    <input type="number" id="fontSizeInput" class="text-input" value="20" min="1">
                </div>

                <div class="control-group">
                    <button id="solidColorBtn" class="menu-item active">Cor Padrão</button>
                    <button id="gradientColorBtn" class="menu-item">Gradiente</button>
                </div>

                <div id="solidColorPicker" class="control-group">
                    <input type="color" id="textColorInput" value="#000000">
                </div>

                <div id="gradientPicker" class="control-group" style="display: none;">
                    <div class="gradient-stops">
                        <div class="gradient-stop">
                            <input type="color" class="gradient-color" value="#000000">
                            <input type="number" class="gradient-position" value="100" min="0" max="100">
                            <button class="remove-stop">&times;</button>
                        </div>
                        <div class="gradient-stop">
                            <input type="color" class="gradient-color" value="#ff0000">
                            <input type="number" class="gradient-position" value="20" min="0" max="100">
                            <button class="remove-stop">&times;</button>
                        </div>
                    </div>
                    <button id="addGradientStop" class="menu-item">Adicionar Cor</button>
                </div>
                <div class="separator"></div>
                <div class="control-group">
                    <input type="checkbox" id="stroke1Enable">
                    <label>Contorno</label>
                    <input type="number" id="stroke1Width" class="text-input" value="1" min="0" disabled>
                    <input type="color" id="stroke1Color" value="#000000">
                </div>
            </div>
        </div>
        <div id="menu-formas" class="menu-content">
            <button class="menu-item" id="squareBtn">Quadrado</button>
            <button class="menu-item" id="circleBtn">Circulo</button>
            <button class="menu-item" id="triangleBtn">Triângulo</button>
            <button class="menu-item" id="lineBtn">Linha</button>
            <button class="menu-item" id="ellipseBtn">Elipse</button>
            <button class="menu-item" id="polygonBtn">Polígono</button>
            <button class="menu-item" id="polylineBtn">Polilinha</button>
            <button class="menu-item" id="rectangleBtn">Retângulo</button>
            <button class="menu-item" id="cakeBtn">Bolo</button>
        </div>
        <div id="menu-filtros" class="menu-content">
            <!-- Conteúdo do menu Filtros -->
        </div>
    </div>
    <input type="file" id="openFileInput" accept=".cloudapp" style="display: none;">
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    <div id="cropperModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-body">
                <div class="crop-container">
                    <img id="cropperImage" src="">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel-btn" id="cancelCropBtn">Cancelar</button>
                <button class="save-btn" id="saveCropBtn">Salvar</button>
            </div>
        </div>
    </div>
<div id="removeColorModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <div class="modal-body">
            <canvas id="removeColorCanvas"></canvas>
        </div>
        <div class="modal-footer">
            <button id="removeRegionBtn" class="menu-item" style="width: auto; margin: 0 5px; background-color: #ffd700; color: black;">Remover Região Clicada</button>
            <button id="removeTotalBtn" class="menu-item" style="width: auto; margin: 0 5px;">Remover Cor Total</button>
            <input type="range" id="sensitivityRange" min="0" max="100" value="30" style="margin: 0 10px;">
            <button id="undoRemoveColor" class="menu-item" style="width: auto; margin: 0 5px;">Voltar</button>
            <div style="flex: 1;"></div>
            <button id="closeRemoveColorModal" class="menu-item" style="width: auto; margin: 0 5px;">Fechar</button>
            <button id="saveRemoveColor" class="menu-item" style="width: auto; margin: 0 5px; background-color: #ffd700; color: black;">Salvar</button>
        </div>
    </div>
</div>
<div id="customAlertModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <div class="modal-body">
            <p id="customAlertMessage"></p>
        </div>
    </div>
</div>
<div class="menu-right">
    <div class="layers-container">
        <h3>Camadas</h3>
        <div class="layers-list-wrapper">
            <ul class="layers-list" id="layersList">
                <!-- Layers will be added here dynamically -->
            </ul>
        </div>
        <div class="layers-buttons">
            <button id="newLayerBtn" class="layer-btn">Novo</button>
            <button id="deleteLayerBtn" class="layer-btn">Excluir</button>
            <button id="centerLayerBtn" class="layer-btn">Centro</button>
        </div>
    </div>
</div>

    <div class="version-badge">EM DESENVOLVIMENTO - CloudPhoto Alfa V0.24 - 26/12/2024</div>
	

 <script>
const container = document.getElementById('canvas-container');
if (!container) {
  console.error('Canvas container not found');
  throw new Error('Canvas container not found');
}

const canvas = new fabric.Canvas('canvas', {
  preserveObjectStacking: true,
  selection: true
});

if (!canvas || !canvas.add) {
  console.error('Failed to initialize fabric.Canvas');
  throw new Error('Canvas initialization failed');
}

const IMAGE_MAX_SIZE = 4096;
const CM_TO_PX = 37.795275591;

// ---------- Inicio Seção Configuração do Canvas ----------
const patternCanvas = document.createElement('canvas');
patternCanvas.width = 20;
patternCanvas.height = 20;
const ctx = patternCanvas.getContext('2d');

ctx.fillStyle = '#16213e';
ctx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);

ctx.fillStyle = '#1f2b4c';
ctx.beginPath();
ctx.arc(10, 10, 3, 0, Math.PI * 2);
ctx.fill();

const pattern = new fabric.Pattern({
    source: patternCanvas,
    repeat: 'repeat'
});

canvas.setBackgroundColor(pattern, canvas.renderAll.bind(canvas));
// ---------- Final Seção Configuração do Canvas ----------

// ---------- Inicio Seção Variáveis Globais ----------
const fileInput = document.getElementById('fileInput');
const loadImageBtn2 = document.getElementById('loadImageBtn2');
const categoryItems = document.querySelectorAll('.category-item');
const menuContents = document.querySelectorAll('.menu-content');
const widthInput = document.getElementById('width-input');
const heightInput = document.getElementById('height-input');
const imageWidthInput = document.getElementById('image-width-input');
const imageHeightInput = document.getElementById('image-height-input');
let selectedObjectIds = [];
let a4Page;
let MAX_HISTORY = 10;
let history = [];
let currentHistoryIndex = -1;
let previewRect = null;
let guides = [];
let textIdCounter = 0;
const textSettings = {};
let isTextEditing = false;

// Add these variables at the top of your script with other global variables
let removeColorHistory = [];
let currentRemoveColorIndex = -1;
let currentRemoveMode = 'region';
let removeColorCtx = null;
let removeColorHistoryIndex = -1;

// ---------- Final Seção Variáveis Globais ----------

// ---------- Inicio Seção Eventos de Categoria ----------
categoryItems.forEach(item => {
  item.addEventListener('click', () => {
    categoryItems.forEach(i => i.classList.remove('active'));
    menuContents.forEach(m => m.classList.remove('active'));
    item.classList.add('active');
    const category = item.dataset.category;
    document.getElementById(`menu-${category}`).classList.add('active');
  });
});

loadImageBtn2.addEventListener('click', () => {
  fileInput.click();
});
// ---------- Final Seção Eventos de Categoria ----------

// ---------- Inicio Seção Dimensões da Página ----------
function updatePageDimensions() {
  const width = parseFloat(widthInput.value) * CM_TO_PX;
  const height = parseFloat(heightInput.value) * CM_TO_PX;

  const existingFolha = canvas.getObjects().filter(obj => obj.id === 'CloudFolha');
  existingFolha.forEach(obj => canvas.remove(obj));

  a4Page = new fabric.Rect({
    id: 'CloudFolha',
    left: (canvas.width - width) / 2,
    top: (canvas.height - height) / 2,
    width: width,
    height: height,
    fill: 'white',
    selectable: false,
    evented: false,
    scaleX: 1,
    scaleY: 1
  });

  canvas.add(a4Page);
  canvas.sendToBack(a4Page);
  canvas.renderAll();
  saveState();
}

widthInput.addEventListener('input', updatePageDimensions);
widthInput.addEventListener('change', updatePageDimensions);
heightInput.addEventListener('input', updatePageDimensions);
heightInput.addEventListener('change', updatePageDimensions);

document.getElementById('invertDimensionsBtn').addEventListener('click', function() {
    const widthInput = document.getElementById('width-input');
    const heightInput = document.getElementById('height-input');
    
    const tempWidth = widthInput.value;
    
    widthInput.value = heightInput.value;
    heightInput.value = tempWidth;
    
    widthInput.dispatchEvent(new Event('change'));
    heightInput.dispatchEvent(new Event('change'));
});

document.getElementById('invertObjectDimensionsBtn').addEventListener('click', function() {
    const widthInput = document.getElementById('image-width-input');
    const heightInput = document.getElementById('image-height-input');
    
    const tempWidth = widthInput.value;
    
    widthInput.value = heightInput.value;
    heightInput.value = tempWidth;
    
    widthInput.dispatchEvent(new Event('change'));
    heightInput.dispatchEvent(new Event('change'));
});
// ---------- Final Seção Dimensões da Página ----------

// ---------- Inicio Seção Redimensionamento do Canvas ----------
function resizeCanvas() {
    canvas.setWidth(container.offsetWidth);
    canvas.setHeight(container.offsetHeight);

    canvas.setBackgroundColor(pattern, canvas.renderAll.bind(canvas));

    const pageHeight = parseFloat(heightInput.value) * CM_TO_PX;
    const containerHeight = container.offsetHeight;

    const zoom = (containerHeight / pageHeight) * 0.7;

    canvas.setZoom(zoom);

    const leftMenuWidth = 0;
    const marginLeft = 10;
    const topMargin = 150;

    canvas.absolutePan({ x: -(leftMenuWidth + marginLeft), y: -topMargin });

    updatePageDimensions();
    canvas.renderAll();
}

let isPanning = false;
let lastPosX;
let lastPosY;
let isSpacePressed = false;

function updateCursor() {
  if (isSpacePressed) {
    canvas.defaultCursor = 'grab';
    canvas.hoverCursor = 'grab';
    if (isPanning) {
      canvas.defaultCursor = 'grabbing';
      canvas.hoverCursor = 'grabbing';
    }
  } else {
    canvas.defaultCursor = 'default';
    canvas.hoverCursor = 'move';
  }
  canvas.requestRenderAll();
}

canvas.on('mouse:wheel', function(opt) {
  var delta = opt.e.deltaY;
  var zoom = canvas.getZoom();
  var point = {
    x: opt.e.offsetX,
    y: opt.e.offsetY
  };

  var factor = 1.1;
  if (delta > 0) {
    zoom = zoom / factor;
  } else {
    zoom = zoom * factor;
  }

  if (zoom > 20) zoom = 20;
  if (zoom < 0.01) zoom = 0.01;

  canvas.zoomToPoint(point, zoom);

  opt.e.preventDefault();
  opt.e.stopPropagation();
});

canvas.on('mouse:down', function(opt) {
  if (isSpacePressed && opt.e.buttons === 1) {
    isPanning = true;
    lastPosX = opt.e.clientX;
    lastPosY = opt.e.clientY;
    updateCursor();
  }
});

canvas.on('mouse:move', function(opt) {
  if (isPanning && opt.e.buttons === 1) {
    const deltaX = opt.e.clientX - lastPosX;
    const deltaY = opt.e.clientY - lastPosY;

    const vpt = canvas.viewportTransform;
    vpt[4] += deltaX;
    vpt[5] += deltaY;

    canvas.requestRenderAll();

    lastPosX = opt.e.clientX;
    lastPosY = opt.e.clientY;
  }
});

canvas.on('mouse:up', function() {
  isPanning = false;
  updateCursor();
});

document.addEventListener('keydown', function(e) {
  if (e.code === 'Space' && !isSpacePressed) {
    e.preventDefault();
    isSpacePressed = true;
    updateCursor();
  }
});

document.addEventListener('keyup', function(e) {
  if (e.code === 'Space') {
    e.preventDefault();
    isSpacePressed = false;
    isPanning = false;
    updateCursor();
  }
});

window.addEventListener('keydown', function(e) {
  if (e.code === 'Space') {
    e.preventDefault();
  }
});

window.addEventListener('load', resizeCanvas);
// ---------- Final Seção Redimensionamento do Canvas ----------

// ---------- Inicio Seção Histórico ----------
let canvasHistory = [];
let historyIndex = -1;
const maxHistory = 20; // Limite de 20 estados

function saveState() {
  const json = canvas.toJSON(['id', 'selectable', 'evented']); // Save these properties

  // Limit history size
  if (canvasHistory.length >= maxHistory) {
    canvasHistory.shift();
    historyIndex--;
  }

  canvasHistory = canvasHistory.slice(0, historyIndex + 1);
  canvasHistory.push(json);
  historyIndex++;
}

function undo() {
  if (historyIndex > 0) {
    historyIndex--;
    canvas.loadFromJSON(canvasHistory[historyIndex], () => {
      // Find and fix CloudFolha properties
      const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
      if (cloudFolha) {
        cloudFolha.set({
          selectable: false,
          evented: false,
          hasControls: false,
          hasBorders: false,
          lockMovementX: true,
          lockMovementY: true
        });
      } else {
        // If CloudFolha is missing, recreate it
        updatePageDimensions();
      }

      canvas.discardActiveObject();
      canvas.renderAll();
    });
  }
}

function redo() {
  if (historyIndex < canvasHistory.length - 1) {
    historyIndex++;
    canvas.loadFromJSON(canvasHistory[historyIndex], () => {
      // Find and fix CloudFolha properties
      const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
      if (cloudFolha) {
        cloudFolha.set({
          selectable: false,
          evented: false,
          hasControls: false,
          hasBorders: false,
          lockMovementX: true,
          lockMovementY: true
        });
      } else {
        // If CloudFolha is missing, recreate it
        updatePageDimensions();
      }

      canvas.discardActiveObject();
      canvas.renderAll();
    });
  }
}

// Salvar estado inicial
saveState();

// Eventos do Fabric.js para salvar estados
canvas.on('object:modified', saveState);
canvas.on('object:added', saveState);
canvas.on('object:removed', saveState);
canvas.on('selection:created', saveState);
canvas.on('selection:updated', saveState);
canvas.on('selection:cleared', saveState);

// ---------- Final Seção Histórico ----------

document.addEventListener('keydown', function(e) {
    if (e.key === 'Delete' || e.key === 'Backspace') {
        const activeObjects = canvas.getActiveObjects();
        const activeObject = canvas.getActiveObject();

        if (activeObject && activeObject.type.includes('text') && activeObject.isEditing) {
            return;
        }

        e.preventDefault();

        if (activeObjects.length > 1) {
            activeObjects.forEach(obj => {
                if (!(obj.type.includes('text') && obj.isEditing)) {
                    canvas.remove(obj);
                }
            });
        }
        else if (activeObject) {
            canvas.remove(activeObject);
        }

        canvas.discardActiveObject();
        canvas.requestRenderAll();
        saveState();
    }
});

document.addEventListener('paste', function(e) {
  const items = e.clipboardData.items;
  for (let i = 0; i < items.length; i++) {
    const item = items[i];

    if (item.type.indexOf('image') !== -1) {
      const blob = item.getAsFile();
      const reader = new FileReader();
      reader.onload = function(event) {
        fabric.Image.fromURL(event.target.result, function(img) {
          const canvasCenter = getCanvasCenter();
          img.set({
            left: canvasCenter.left,
            top: canvasCenter.top,
            originX: 'center',
            originY: 'center',
            perPixelTargetFind: true,
            lockMovementX: false,
            lockMovementY: false
          });
          resizeImageToMaxSize(img);
          canvas.add(img);
          canvas.setActiveObject(img);
          canvas.renderAll();
          saveState();
        }, { crossOrigin: 'anonymous' });
      };
      reader.readAsDataURL(blob);
    }

    else if (item.type.indexOf('text/plain') !== -1) {
      item.getAsString(function(text) {
        const canvasCenter = getCanvasCenter();

        const newText = new fabric.IText(text, {
          left: canvasCenter.left,
          top: canvasCenter.top,
          fontSize: 20,
          fontFamily: DEFAULT_TEXT_SETTINGS.fontFamily,
          fill: DEFAULT_TEXT_SETTINGS.fill,
          originX: 'center',
          originY: 'center',
          editable: true,
          selectable: true
        });

        newText.textId = generateUniqueId();

        canvas.add(newText);
        canvas.setActiveObject(newText);
        canvas.renderAll();
        saveState();

        activateTextCategory();
      });
    }
  }
});

document.addEventListener('keydown', function(e) {
  if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
    e.preventDefault();
    const activeObject = canvas.getActiveObject();
    if (activeObject) {
      activeObject.clone(function (cloned) {
        cloned.set({
          left: cloned.left + 20,
          top: cloned.top + 20
        });
        canvas.add(cloned);
        canvas.setActiveObject(cloned);
        canvas.renderAll();
        saveState();
      });
    }
  }
});

document.addEventListener('keydown', function(e) {
  if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
    e.preventDefault();
    const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
    if (objects.length > 0) {
      const selection = new fabric.ActiveSelection(objects, { canvas: canvas });
      canvas.setActiveObject(selection);
      canvas.renderAll();
      saveState();
    }
  }
});

document.addEventListener('keydown', function(e) {
    const activeObject = canvas.getActiveObject();
    const isEditingText = activeObject && activeObject.isEditing;

    if (isEditingText) {
        return;
    }

    if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z') {
        e.preventDefault();
        undo();
    }

    if ((e.ctrlKey || e.metaKey) &&
        (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) {
        e.preventDefault();
        redo();
    }
});

canvas.on('history:append', function() {
    const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
    if (cloudFolha) {
        cloudFolha.set({
            selectable: false,
            evented: false,
            hasControls: false,
            hasBorders: false,
            lockMovementX: true,
            lockMovementY: true
        });
    }
    canvas.renderAll();
});

document.addEventListener('keydown', function(e) {
  if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
    e.preventDefault();
    const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
    if (cloudFolha) {
      const printCanvas = document.createElement('canvas');
      const ctx = printCanvas.getContext('2d');
      printCanvas.width = cloudFolha.width;
      printCanvas.height = cloudFolha.height;

      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, printCanvas.width, printCanvas.height);

      const tempCanvas = new fabric.Canvas(printCanvas);
      tempCanvas.setWidth(cloudFolha.width);
      tempCanvas.setHeight(cloudFolha.height);

      const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
      objects.forEach(obj => {
        const clonedObj = fabric.util.object.clone(obj);

        const relativeLeft = (obj.left - cloudFolha.left) / cloudFolha.scaleX;
        const relativeTop = (obj.top - cloudFolha.top) / cloudFolha.scaleY;

        clonedObj.set({
          left: relativeLeft,
          top: relativeTop,
          scaleX: obj.scaleX / cloudFolha.scaleX,
          scaleY: obj.scaleY / cloudFolha.scaleY
        });

        tempCanvas.add(clonedObj);
      });

      tempCanvas.renderAll();

      const dataUrl = tempCanvas.toDataURL('image/png');
      const printWindow = window.open('', '_blank');
      printWindow.document.write(`
        <html>
          <head>
            <title>Print</title>
            <style>
              @media print {
                img { max-width: 100%; }
              }
            </style>
          </head>
          <body>
            <img src="\${dataUrl}" onload="window.print();window.close()">
          </body>
        </html>
      `);
      printWindow.document.close();

      tempCanvas.dispose();
    }
  }
});

canvas.on('selection:created', function(e) {
    if (e.selected[0] && e.selected[0].type === 'text') {
        activateTextCategory();
    } else {
        const editarCategory = document.querySelector('.category-item[data-category="editar"]');
        if (!editarCategory.classList.contains('active')) {
            categoryItems.forEach(i => i.classList.remove('active'));
            menuContents.forEach(m => m.classList.remove('active'));
            editarCategory.classList.add('active');
            document.getElementById('menu-editar').classList.add('active');
        }
    }
    if (e.selected && e.selected[0]) {
        updateImageDimensionInputs(e.selected[0]);
    }
});

canvas.on('selection:updated', function(e) {
  const editarCategory = document.querySelector('.category-item[data-category="editar"]');
  if (!editarCategory.classList.contains('active')) {
    categoryItems.forEach(i => i.classList.remove('active'));
    menuContents.forEach(m => m.classList.remove('active'));
    editarCategory.classList.add('active');
    document.getElementById('menu-editar').classList.add('active');
  }
  if (e.selected && e.selected[0]) {
    updateImageDimensionInputs(e.selected[0]);
  }
});

canvas.on('selection:cleared', function() {
  imageWidthInput.value = "0";
  imageHeightInput.value = "0";
});

canvas.on('object:modified', function (e) {
    const activeObject = e.target;

    if (activeObject) {
        updateImageDimensionInputs(activeObject);

        if (activeObject.type === 'text') {
            const newFontSize = activeObject.fontSize * activeObject.scaleX;
            activeObject.set('fontSize', newFontSize);
            activeObject.set('scaleX', 1);
            activeObject.set('scaleY', 1);
            canvas.renderAll();

            document.getElementById('fontSizeInput').value = Math.round(newFontSize);
        }
    }
});

canvas.on('object:scaling', function(e) {
  const obj = e.target;
  if (obj) {
    updateImageDimensionInputs(obj);

    if (obj.type === 'text') {
      const newFontSize = obj.fontSize * obj.scaleX;
      obj.set('fontSize', newFontSize);
      obj.set('scaleX', 1);
      obj.set('scaleY', 1);
      canvas.renderAll();

      activeTextSettings.fontSize = newFontSize;
      saveTextSettings(obj);
    }
  }
});

function updateImageDimensionInputs(obj) {
  if (!obj || !obj.type === 'image') {
    imageWidthInput.value = "0";
    imageHeightInput.value = "0";
    return;
  }

  const widthInCm = (obj.width * obj.scaleX) / CM_TO_PX;
  const heightInCm = (obj.height * obj.scaleY) / CM_TO_PX;

  imageWidthInput.value = widthInCm.toFixed(1);
  imageHeightInput.value = heightInCm.toFixed(1);
}

function resizeImageToMaxSize(img) {
  const maxWidthInCm = 21;
  const maxHeightInCm = 29.7;

  const maxWidthPx = maxWidthInCm * CM_TO_PX;
  const maxHeightPx = maxHeightInCm * CM_TO_PX;

  let scaleX = 1;
  let scaleY = 1;

  if (img.width > maxWidthPx || img.height > maxHeightPx) {
    const scaleW = maxWidthPx / img.width;
    const scaleH = maxHeightPx / img.height;
    const scale = Math.min(scaleW, scaleH);

    scaleX = scale;
    scaleY = scale;
  }

  img.set({
    scaleX: scaleX,
    scaleY: scaleY,
    perPixelTargetFind: true,
    lockMovementX: false,
    lockMovementY: false
  });
}

fileInput.addEventListener('change', function (e) {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function (event) {
      fabric.Image.fromURL(event.target.result, function (img) {
        const canvasCenter = getCanvasCenter();

        img.set({
          left: canvasCenter.left,
          top: canvasCenter.top,
          name: file.name,
          originX: 'center',
          originY: 'center',
          perPixelTargetFind: true,
          lockMovementX: false,
          lockMovementY: false
        });

        resizeImageToMaxSize(img);

        canvas.add(img);
        canvas.setActiveObject(img);
        canvas.renderAll();

        updateImageDimensionInputs(img);
        saveState();
      }, { crossOrigin: 'anonymous' });
    };
    reader.readAsDataURL(file);
  }
  fileInput.value = '';
});

// ---------- Final Seção Manipulação de Objetos ----------

// ---------- Inicio Seção Formas ----------
function addShape(shapeName) {
  let shape;
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  const center = {
    left: cloudFolha.left + (cloudFolha.width * cloudFolha.scaleX) / 2,
    top: cloudFolha.top + (cloudFolha.height * cloudFolha.scaleY) / 2
  };

  switch(shapeName) {
    case 'square':
      shape = new fabric.Rect({
        left: center.left,
        top: center.top,
        width: 100,
        height: 100,
        fill: '#fff',
        stroke: '#000',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center'
      });
      break;

    case 'circle':
      shape = new fabric.Circle({
        left: center.left,
        top: center.top,
        radius: 50,
        fill: '#fff',
        stroke: '#000',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center'
      });
      break;

    case 'triangle':
      shape = new fabric.Triangle({
        left: center.left,
        top: center.top,
        width: 100,
        height: 100,
        fill: '#fff',
        stroke: '#000',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center'
      });
      break;

    case 'line':
      shape = new fabric.Line([50, 50, 150, 50], {
        left: center.left - 50,
        top: center.top,
        stroke: '#000',
        strokeWidth: 2
      });
      break;

    case 'ellipse':
      shape = new fabric.Ellipse({
        left: center.left,
        top: center.top,
        rx: 80,
        ry: 40,
        fill: '#fff',
        stroke: '#000',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center'
      });
      break;

    case 'polygon':
      shape = new fabric.Polygon([
        {x: 0, y: 0},
        {x: 100, y: 0},
        {x: 100, y: 100},
        {x: 50, y: 150},
        {x: 0, y: 100}
      ], {
        left: center.left - 50,
        top: center.top - 75,
        fill: '#fff',
        stroke: '#000',
        strokeWidth: 2
      });
      break;

    case 'polyline':
      shape = new fabric.Polyline([
        {x: 0, y: 0},
        {x: 50, y: 50},
        {x: 100, y: 0},
        {x: 150, y: 50}
      ], {
        left: center.left - 75,
        top: center.top - 25,
        fill: '',
        stroke: '#000',
        strokeWidth: 2
      });
      break;

    case 'rectangle':
      shape = new fabric.Rect({
        left: center.left,
        top: center.top,
        width: 150,
        height: 100,
        fill: '#fff',
        stroke: '#000',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center'
      });
      break;
  }

  if (shape) {
    canvas.add(shape);
    canvas.setActiveObject(shape);
    canvas.renderAll();
    saveState();
  }
}

document.getElementById('squareBtn').addEventListener('click', () => addShape('square'));
document.getElementById('circleBtn').addEventListener('click', () => addShape('circle'));
document.getElementById('triangleBtn').addEventListener('click', () => addShape('triangle'));
document.getElementById('lineBtn').addEventListener('click', () => addShape('line'));
document.getElementById('ellipseBtn').addEventListener('click', () => addShape('ellipse'));
document.getElementById('polygonBtn').addEventListener('click', () => addShape('polygon'));
document.getElementById('polylineBtn').addEventListener('click', () => addShape('polyline'));
document.getElementById('rectangleBtn').addEventListener('click', () => addShape('rectangle'));
// ---------- Final Seção Formas ----------

// ---------- Inicio Seção Guias ----------
const addGuidesBtn = document.getElementById('addGuidesBtn');
const guidesMenu = document.getElementById('guidesMenu');
const addGuideBtn = document.getElementById('addGuideBtn');
const guidePositionInput = document.getElementById('guidePositionInput');
const horizontalGuideBtn = document.getElementById('horizontalGuideBtn');
const verticalGuideBtn = document.getElementById('verticalGuideBtn');
const singleGuideBtn = document.getElementById('singleGuideBtn');
const multipleGuidesBtn = document.getElementById('multipleGuidesBtn');

addGuidesBtn.addEventListener('click', () => {
  guidesMenu.classList.toggle('active');
});

addGuideBtn.addEventListener('click', () => {
  const position = parseFloat(guidePositionInput.value) * CM_TO_PX;
  const isHorizontal = horizontalGuideBtn.classList.contains('active');
  const isSingle = singleGuideBtn.classList.contains('active');

  if (isHorizontal) {
    if (isSingle) {
      addHorizontalGuide(position);
    } else {
      addMultipleHorizontalGuides(position);
    }
  } else {
    if (isSingle) {
      addVerticalGuide(position);
    } else {
      addMultipleVerticalGuides(position);
    }
  }

  guidesMenu.classList.remove('active');
});

function addHorizontalGuide(position) {
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (cloudFolha) {
    const guide = new fabric.Line([cloudFolha.left, cloudFolha.top + position, cloudFolha.left + cloudFolha.width * cloudFolha.scaleX, cloudFolha.top + position], {
      stroke: 'red',
      strokeDashArray: [5, 5],
      selectable: false,
      evented: false,
      id: 'guide'
    });
    guides.push(guide);
    canvas.add(guide);
    canvas.renderAll();
  }
}

function addVerticalGuide(position) {
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (cloudFolha) {
    const guide = new fabric.Line([cloudFolha.left + position, cloudFolha.top, cloudFolha.left + position, cloudFolha.top + cloudFolha.height * cloudFolha.scaleY], {
      stroke: 'red',
      strokeDashArray: [5, 5],
      selectable: false,
      evented: false,
      id: 'guide'
    });
    guides.push(guide);
    canvas.add(guide);
    canvas.renderAll();
  }
}

function addMultipleHorizontalGuides(position) {
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (cloudFolha) {
    const numGuides = Math.floor(cloudFolha.height / position);
    for (let i = 1; i <= numGuides; i++) {
      addHorizontalGuide(i * position);
    }
  }
}

function addMultipleVerticalGuides(position) {
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (cloudFolha) {
    const numGuides = Math.floor(cloudFolha.width / position);
    for (let i = 1; i <= numGuides; i++) {
      addVerticalGuide(i * position);
    }
  }
}

const addDefaultGuidesBtn = document.getElementById('addDefaultGuidesBtn');
addDefaultGuidesBtn.addEventListener('click', addDefaultGuides);

function addDefaultGuides() {
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (cloudFolha) {
    const margin = 0.5 * CM_TO_PX;
    addHorizontalGuide(margin);
    addHorizontalGuide(cloudFolha.height - margin);
    addVerticalGuide(margin);
    addVerticalGuide(cloudFolha.width - margin);
  }
}

const removeGuidesBtn = document.getElementById('removeGuidesBtn');
removeGuidesBtn.addEventListener('click', removeGuides);

function removeGuides() {
  guides.forEach(guide => canvas.remove(guide));
  guides = [];
  canvas.renderAll();
}

canvas.on('object:moving', function(e) {
  const obj = e.target;
  guides.forEach(guide => {
    if (guide.type === 'line') {
      if (guide.x1 === guide.x2) {
        if (Math.abs(obj.left - guide.x1) < 5) {
          obj.set('left', guide.x1);
        }
      } else {
        if (Math.abs(obj.top - guide.y1) < 5) {
          obj.set('top', guide.y1);
        }
      }
    }
  });
});

horizontalGuideBtn.addEventListener('click', () => {
  horizontalGuideBtn.classList.add('active');
  verticalGuideBtn.classList.remove('active');
});

verticalGuideBtn.addEventListener('click', () => {
  verticalGuideBtn.classList.add('active');
  horizontalGuideBtn.classList.remove('active');
});

singleGuideBtn.addEventListener('click', () => {
  singleGuideBtn.classList.add('active');
  multipleGuidesBtn.classList.remove('active');
});

multipleGuidesBtn.addEventListener('click', () => {
  multipleGuidesBtn.classList.add('active');
  singleGuideBtn.classList.remove('active');
});

addGuideBtn.addEventListener('click', () => {
  const position = parseFloat(guidePositionInput.value) * CM_TO_PX;
  const isHorizontal = horizontalGuideBtn.classList.contains('active');
  const isSingle = singleGuideBtn.classList.contains('active');

  if (isHorizontal) {
    if (isSingle) {
      addHorizontalGuide(position);
    } else {
      addMultipleHorizontalGuides(position);
    }
  } else {
    if (isSingle) {
      addVerticalGuide(position);
    } else {
      addMultipleVerticalGuides(position);
    }
  }

  guidesMenu.classList.remove('active');
});
// ---------- Final Seção Guias ----------

// ---------- Inicio Seção Exportação ----------
const exportButton = document.getElementById('exportButton');
const exportOptions = document.getElementById('exportOptions');
const resolutionInput = document.getElementById('resolutionInput');

exportButton.addEventListener('click', () => {
  if (previewRect) {
    canvas.remove(previewRect);
    previewRect = null;
    canvas.renderAll();
  }
  exportOptions.classList.toggle('active');
});

async function exportCanvas(format) {
  const dpi = parseInt(resolutionInput.value) || 300; // Reduzido para 300 DPI padrão
  const scale = dpi / 96;

  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (!cloudFolha) return;

  // Criar um canvas temporário com dimensões otimizadas
  const tempContainer = document.createElement('div');
  document.body.appendChild(tempContainer);

  const exportCanvas = document.createElement('canvas');
  // Calcular dimensões ideais mantendo a proporção
  const maxDimension = 4096; // Limite máximo para garantir performance
  const aspectRatio = cloudFolha.width / cloudFolha.height;
  let targetWidth = cloudFolha.width * scale;
  let targetHeight = cloudFolha.height * scale;

  // Ajustar dimensões se excederem o máximo
  if (targetWidth > maxDimension || targetHeight > maxDimension) {
    if (aspectRatio > 1) {
      targetWidth = maxDimension;
      targetHeight = maxDimension / aspectRatio;
    } else {
      targetHeight = maxDimension;
      targetWidth = maxDimension * aspectRatio;
    }
  }

  exportCanvas.width = targetWidth;
  exportCanvas.height = targetHeight;
  tempContainer.appendChild(exportCanvas);

  const exportFabricCanvas = new fabric.Canvas(exportCanvas, {
    enableRetinaScaling: true,
    imageSmoothingQuality: 'high'
  });

  // Configurar canvas de exportação
  exportFabricCanvas.setWidth(targetWidth);
  exportFabricCanvas.setHeight(targetHeight);

  // Clonar e ajustar objetos
  const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
  const promises = objects.map(async (obj) => {
    const clonedObj = await cloneObjectWithQuality(obj);
    
    const relativeLeft = (obj.left - cloudFolha.left) / cloudFolha.scaleX;
    const relativeTop = (obj.top - cloudFolha.top) / cloudFolha.scaleY;

    const scaleFactor = targetWidth / cloudFolha.width;
    
    clonedObj.set({
      left: relativeLeft * scaleFactor,
      top: relativeTop * scaleFactor,
      scaleX: (obj.scaleX / cloudFolha.scaleX) * scaleFactor,
      scaleY: (obj.scaleY / cloudFolha.scaleY) * scaleFactor
    });

    return clonedObj;
  });

  // Aguardar todos os objetos serem processados
  const clonedObjects = await Promise.all(promises);
  clonedObjects.forEach(obj => exportFabricCanvas.add(obj));

  exportFabricCanvas.renderAll();

  // Configurações específicas por formato
  const exportOptions = {
    format: format,
    quality: 1.0,
    enableRetinaScaling: true,
    multiplier: 1,
    imageSmoothingEnabled: true,
    imageSmoothingQuality: 'high'
  };

  if (format === 'jpg') {
    exportOptions.backgroundColor = '#ffffff';
  }

  // Exportar com qualidade otimizada
  const dataUrl = exportFabricCanvas.toDataURL(exportOptions);
  
  const link = document.createElement('a');
  const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');
  link.href = dataUrl;
  link.download = `CloudApp_${timestamp}.${format}`;
  link.click();

  // Limpar recursos
  tempContainer.remove();
  exportFabricCanvas.dispose();
}

// Função auxiliar para clonar objetos mantendo qualidade
async function cloneObjectWithQuality(obj) {
  return new Promise(async (resolve) => {
    const clonedObj = fabric.util.object.clone(obj);
    
    // Se for uma imagem, recarregá-la em alta qualidade
    if (obj.type === 'image' && obj.getSrc) {
      const imgSrc = obj.getSrc();
      fabric.Image.fromURL(imgSrc, function(img) {
        img.set(clonedObj);
        resolve(img);
      }, {
        crossOrigin: 'anonymous',
        quality: 1.0
      });
    } else {
      resolve(clonedObj);
    }
  });
}

function cmToPoints(cm) {
  return cm * 28.3465;
}

// Função para exportar PDF com qualidade otimizada
async function exportPdf() {
  const dpi = parseInt(resolutionInput.value) || 300;
  const scale = dpi / 96;

  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (!cloudFolha) return;

  const pageWidth = cmToPoints(cloudFolha.width / CM_TO_PX);
  const pageHeight = cmToPoints(cloudFolha.height / CM_TO_PX);

  // Criar canvas temporário com dimensões otimizadas
  const tempCanvas = document.createElement('canvas');
  const targetWidth = Math.min(cloudFolha.width * scale, 4096);
  const targetHeight = Math.min(cloudFolha.height * scale, 4096);
  
  tempCanvas.width = targetWidth;
  tempCanvas.height = targetHeight;
  
  const tempFabricCanvas = new fabric.StaticCanvas(tempCanvas, {
    enableRetinaScaling: true,
    imageSmoothingQuality: 'high'
  });

  // Clonar e processar objetos com alta qualidade
  const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
  const clonedObjects = await Promise.all(
    objects.map(obj => cloneObjectWithQuality(obj))
  );

  clonedObjects.forEach(obj => {
    const relativeLeft = (obj.left - cloudFolha.left) / cloudFolha.scaleX;
    const relativeTop = (obj.top - cloudFolha.top) / cloudFolha.scaleY;
    
    const scaleFactor = targetWidth / cloudFolha.width;
    
    obj.set({
      left: relativeLeft * scaleFactor,
      top: relativeTop * scaleFactor,
      scaleX: (obj.scaleX / cloudFolha.scaleX) * scaleFactor,
      scaleY: (obj.scaleY / cloudFolha.scaleY) * scaleFactor
    });
    
    tempFabricCanvas.add(obj);
  });

  tempFabricCanvas.renderAll();

  // Criar PDF com qualidade otimizada
  const pdfDoc = await PDFLib.PDFDocument.create();
  const page = pdfDoc.addPage([pageWidth, pageHeight]);
  
  const pngImage = await pdfDoc.embedPng(
    tempCanvas.toDataURL('image/png', 1.0)
  );
  
  page.drawImage(pngImage, {
    x: 0,
    y: 0,
    width: pageWidth,
    height: pageHeight
  });

  const pdfBytes = await pdfDoc.save({
    useObjectStreams: true,
    addDefaultPage: false,
    compress: true
  });

  // Download do PDF
  const blob = new Blob([pdfBytes], { type: 'application/pdf' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');
  link.download = `CloudApp_${timestamp}.pdf`;
  link.click();
  URL.revokeObjectURL(url);
  
  tempFabricCanvas.dispose();
}

// Event Listeners para exportação
document.querySelectorAll('.export-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const format = btn.dataset.format;
    if (format === 'pdf') {
      exportPdf();
    } else if (format !== 'vector-pdf') {
      exportCanvas(format);
    }
  });
});

// Event Listeners para inputs de dimensões
imageWidthInput.addEventListener('change', () => {
  const activeObj = canvas.getActiveObject();
  if (!activeObj) return;

  const widthInPx = parseFloat(imageWidthInput.value) * CM_TO_PX;
  const heightInPx = parseFloat(imageHeightInput.value) * CM_TO_PX;

  const scaleX = widthInPx / activeObj.width;
  const scaleY = heightInPx / activeObj.height;

  activeObj.set({
    scaleX: scaleX,
    scaleY: scaleY
  });

  canvas.renderAll();
  saveState();
});

imageHeightInput.addEventListener('change', () => {
  const activeObj = canvas.getActiveObject();
  if (!activeObj) return;

  const widthInPx = parseFloat(imageWidthInput.value) * CM_TO_PX;
  const heightInPx = parseFloat(imageHeightInput.value) * CM_TO_PX;

  const scaleX = widthInPx / activeObj.width;
  const scaleY = heightInPx / activeObj.height;

  activeObj.set({
    scaleX: scaleX,
    scaleY: scaleY
  });

  canvas.renderAll();
  saveState();
});

// ---------- Final Seção Exportação ----------

// ---------- Inicio Seção Manipulação de Objetos Novos ----------
function alignObjectsHorizontal() {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length < 2) return;

  const group = canvas.getActiveObject();
  const groupCenter = group.getCenterPoint();

  activeObjects.forEach(obj => {
    obj.set('left', obj.left + (groupCenter.x - obj.getCenterPoint().x));
  });

  canvas.renderAll();
  saveState();
}

function alignObjectsVertical() {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length < 2) return;

  const group = canvas.getActiveObject();
  const groupCenter = group.getCenterPoint();

  activeObjects.forEach(obj => {
    obj.set('top', obj.top + (groupCenter.y - obj.getCenterPoint().y));
  });

  canvas.renderAll();
  saveState();
}

function mirrorObjectsHorizontal() {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length === 0) return;

  activeObjects.forEach(obj => {
    obj.set('flipX', !obj.flipX);
  });

  canvas.renderAll();
  saveState();
}

function mirrorObjectsVertical() {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length === 0) return;

  activeObjects.forEach(obj => {
    obj.set('flipY', !obj.flipY);
  });

  canvas.renderAll();
  saveState();
}

function rotateObjects(angle) {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length === 0) return;

  activeObjects.forEach(obj => {
    obj.rotate(parseFloat(angle));
  });

  canvas.renderAll();
  saveState();
}

function exportSelectedObjects() {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length === 0) return;

  const tempCanvas = document.createElement('canvas');
  const tempFabricCanvas = new fabric.Canvas(tempCanvas);

  const bounds = {
    left: Number.POSITIVE_INFINITY,
    top: Number.POSITIVE_INFINITY,
    right: Number.NEGATIVE_INFINITY,
    bottom: Number.NEGATIVE_INFINITY
  };

  activeObjects.forEach(obj => {
    const objBounds = obj.getBoundingRect(true, true);
    bounds.left = Math.min(bounds.left, objBounds.left);
    bounds.top = Math.min(bounds.top, objBounds.top);
    bounds.right = Math.max(bounds.right, objBounds.left + objBounds.width);
    bounds.bottom = Math.max(bounds.bottom, objBounds.top + objBounds.height);
  });

  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;

  tempFabricCanvas.setWidth(width);
  tempFabricCanvas.setHeight(height);

  activeObjects.forEach(obj => {
    obj.clone(function(cloned) {
      cloned.set({
        left: cloned.left - bounds.left,
        top: cloned.top - bounds.top
      });
      tempFabricCanvas.add(cloned);
    });
  });

  setTimeout(() => {
    tempFabricCanvas.renderAll();

    const scaleFactor = 300 / 96;
    const scaledCanvas = document.createElement('canvas');
    scaledCanvas.width = width * scaleFactor;
    scaledCanvas.height = height * scaleFactor;
    const ctx = scaledCanvas.getContext('2d');
    ctx.scale(scaleFactor, scaleFactor);
    ctx.drawImage(tempCanvas, 0, 0);

    const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');
    const link = document.createElement('a');
    link.download = `CloudAppImagem_${timestamp}.png`;
    link.href = scaledCanvas.toDataURL('image/png');
    link.click();

    tempFabricCanvas.dispose();
  }, 100);
}

// Função para obter o centro do canvas
function getCanvasCenter() {
  return {
    left: canvas.getWidth() / 2,
    top: canvas.getHeight() / 2
  };
}

// ---------- Final Seção Manipulação de Objetos Novos ----------

// ---------- Inicio Seção Eventos Novos ----------
document.getElementById('alignHorizontalBtn').addEventListener('click', alignObjectsHorizontal);
document.getElementById('alignVerticalBtn').addEventListener('click', alignObjectsVertical);
document.getElementById('mirrorHorizontalBtn').addEventListener('click', mirrorObjectsHorizontal);
document.getElementById('mirrorVerticalBtn').addEventListener('click', mirrorObjectsVertical);
document.getElementById('rotateBtn').addEventListener('click', function() {
  const angle = document.getElementById('rotateInput').value;
  rotateObjects(angle);
});
document.getElementById('exportSelectedImageBtn').addEventListener('click', exportSelectedObjects);
// ---------- Final Seção Eventos Novos ----------

// ---------- Inicio Seção Documentos ----------
function saveDocument() {
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (!cloudFolha) return;

  const documentData = {
    version: '1.0',
    pageWidth: widthInput.value,
    pageHeight: heightInput.value,
    objects: []
  };

  canvas.getObjects().forEach(obj => {
    if (obj.id !== 'CloudFolha' && obj.id !== 'guide') {
      // Base object data with essential properties
      const objData = obj.toObject([
        'id', 'name', 'type', 'left', 'top', 'width', 'height',
        'scaleX', 'scaleY', 'angle', 'flipX', 'flipY', 'opacity',
        'originX', 'originY', 'textId'
      ]);

      // Additional properties for text objects
      if (obj.type.includes('text')) {
        Object.assign(objData, {
          text: obj.text,
          fontFamily: obj.fontFamily,
          fontSize: obj.fontSize,
          fontWeight: obj.fontWeight,
          fontStyle: obj.fontStyle,
          underline: obj.underline,
          linethrough: obj.linethrough,
          textAlign: obj.textAlign,
          charSpacing: obj.charSpacing,
          lineHeight: obj.lineHeight,
          editable: true,
          selectable: true,
          // Save text settings from the settings map
          textSettings: textSettingsMap.get(obj.textId)
        });

        // Handle gradient fill
        if (obj.fill instanceof fabric.Gradient) {
          objData.fillType = 'gradient';
          objData.gradientFill = {
            type: obj.fill.type,
            coords: obj.fill.coords,
            colorStops: obj.fill.colorStops
          };
        } else {
          objData.fillType = 'solid';
          objData.fill = obj.fill;
        }

        // Save stroke properties
        if (obj.stroke) {
          objData.stroke = obj.stroke;
          objData.strokeWidth = obj.strokeWidth;
          objData.paintFirst = obj.paintFirst;
        }
      }

      // Handle image objects
      if (obj.type === 'image' && obj._element) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = obj._element.width;
        tempCanvas.height = obj._element.height;
        const ctx = tempCanvas.getContext('2d');
        ctx.drawImage(obj._element, 0, 0);
        objData.src = tempCanvas.toDataURL('image/png');
      }

      documentData.objects.push(objData);
    }
  });

  const jsonString = JSON.stringify(documentData);
  const blob = new Blob([jsonString], { type: 'application/json' });
  const url = URL.createObjectURL(blob);

  const link = document.createElement('a');
  link.href = url;
  const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');
  link.download = `documento_${timestamp}.cloudapp`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

function loadDocumentFile(file) {
  const reader = new FileReader();
  reader.onload = function(event) {
    try {
      const documentData = JSON.parse(event.target.result);

      widthInput.value = documentData.pageWidth;
      heightInput.value = documentData.pageHeight;
      updatePageDimensions();

      const objectsToRemove = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
      canvas.remove(...objectsToRemove);

      documentData.objects.forEach(objData => {
        if (objData.type.includes('text')) {
          const textOptions = {
            ...objData,
            editable: true,
            selectable: true
          };

          if (objData.fillType === 'gradient' && objData.gradientFill) {
            textOptions.fill = new fabric.Gradient({
              type: objData.gradientFill.type,
              coords: objData.gradientFill.coords,
              colorStops: objData.gradientFill.colorStops
            });
          }

          const fabricText = new fabric.IText(objData.text, textOptions);

          if (objData.textSettings) {
            textSettingsMap.set(objData.textId, objData.textSettings);
            activeTextSettings = JSON.parse(JSON.stringify(objData.textSettings));
          }

          canvas.add(fabricText);
        } else if (objData.type === 'image') {
          fabric.Image.fromURL(objData.src, img => {
            img.set(objData);
            canvas.add(img);
            canvas.renderAll();
          }, { crossOrigin: 'anonymous' });
        } else {
          let fabricObj;
          switch(objData.type) {
            case 'rect':
              fabricObj = new fabric.Rect(objData);
              break;
            case 'circle':
              fabricObj = new fabric.Circle(objData);
              break;
            case 'triangle':
              fabricObj = new fabric.Triangle(objData);
              break;
            case 'line':
              fabricObj = new fabric.Line([objData.x1, objData.y1, objData.x2, objData.y2], objData);
              break;
            default:
              fabricObj = new fabric.Object(objData);
          }
          if (fabricObj) {
            canvas.add(fabricObj);
          }
        }
      });

      canvas.renderAll();
      saveState();

    } catch (error) {
      console.error('Erro ao carregar o documento:', error);
    }
  };
  reader.readAsText(file);
}

function openDocument() {
  const input = document.getElementById('openFileInput');
  input.click();
}

document.getElementById('openDocumentBtn').addEventListener('click', openDocument);
document.getElementById('saveDocumentBtn').addEventListener('click', saveDocument);
document.getElementById('openFileInput').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (file) {
    loadDocumentFile(file);
  }
  this.value = '';
});

// ---------- Final Seção Documentos ----------

// ---------- Inicio Seção Corte ----------
let cropper = null;
let activeObject = null;

document.getElementById('cropImageBtn').addEventListener('click', function() {
    activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') {
        showCustomAlert('Selecione uma imagem para cortar');
        return;
    }

    const modal = document.getElementById('cropperModal');
    const cropperImage = document.getElementById('cropperImage');

    if (activeObject._element) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = activeObject._element.width;
        tempCanvas.height = activeObject._element.height;
        const ctx = tempCanvas.getContext('2d');
        ctx.drawImage(activeObject._element, 0, 0);
        cropperImage.src = tempCanvas.toDataURL('image/png');
    }

    modal.style.display = 'flex';

    if (cropper) {
        cropper.destroy();
    }

    cropper = new Cropper(cropperImage, {
        viewMode: 1,
        dragMode: 'move',
        aspectRatio: NaN,
        autoCropArea: 1,
        restore: false,
        modal: true,
        guides: true,
        center: true,
        highlight: true,
        cropBoxMovable: true,
        cropBoxResizable: true,
        toggleDragModeOnDblclick: false,
    });
});

document.getElementById('cancelCropBtn').addEventListener('click', function() {
    const modal = document.getElementById('cropperModal');
    modal.style.display = 'none';
    if (cropper) {
        cropper.destroy();
        cropper = null;
    }
});

document.getElementById('saveCropBtn').addEventListener('click', function() {
    if (!cropper || !activeObject) return;

    const croppedCanvas = cropper.getCroppedCanvas();

    fabric.Image.fromURL(croppedCanvas.toDataURL(), function(img) {
        const originalLeft = activeObject.left;
        const originalTop = activeObject.top;
        const originalScaleX = activeObject.scaleX;
        const originalScaleY = activeObject.scaleY;
        const originalAngle = activeObject.angle;

        img.set({
            left: originalLeft,
            top: originalTop,
            scaleX: originalScaleX,
            scaleY: originalScaleY,
            angle: originalAngle
        });

        canvas.remove(activeObject);
        canvas.add(img);
        canvas.setActiveObject(img);
        canvas.renderAll();
        saveState();

        const modal = document.getElementById('cropperModal');
        modal.style.display = 'none';
        cropper.destroy();
        cropper = null;
    });
});

document.getElementById('cropperModal').addEventListener('click', function(e) {
    if (e.target === this) {
        this.style.display = 'none';
        if (cropper) {
            cropper.destroy();
            cropper = null;
        }
    }
});

// ---------- Final Seção Corte ----------

// ---------- Inicio Seção Duplicar e organizar ----------

function duplicateObjects(numDuplicates) {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length === 0) {
	showCustomAlert('Por favor, selecione uma ou mais imagens para duplicar.');
    return;
  }

  let newObjects = [];
  activeObjects.forEach(obj => {
    for (let i = 0; i < numDuplicates; i++) {
      obj.clone(function(cloned) {
        cloned.set({
          left: cloned.left + 20 * (i + 1),
          top: cloned.top + 20 * (i + 1)
        });
        canvas.add(cloned);
        newObjects.push(cloned);
      });
    }
  });

  setTimeout(() => {
    if (newObjects.length > 0) {
      const selection = new fabric.ActiveSelection(newObjects, { canvas });
      canvas.setActiveObject(selection);
      canvas.renderAll();
      saveState();
    }
  }, 100);
}

function organizeObjects(marginCm) {
  const marginPx = marginCm * CM_TO_PX;
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length === 0) {
	showCustomAlert('Por favor, selecione uma ou mais imagens para organizar.');
    return;
  }

  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (!cloudFolha) {
    return;
  }

  const folhaLeft = cloudFolha.left;
  const folhaTop = cloudFolha.top;
  const folhaWidth = cloudFolha.width * cloudFolha.scaleX;
  const folhaRight = folhaLeft + folhaWidth;

  let currentX = folhaLeft + marginPx;
  let currentY = folhaTop + marginPx;
  let rowHeight = 0;

  activeObjects.forEach(obj => {
    const objWidth = obj.width * obj.scaleX;
    const objHeight = obj.height * obj.scaleY;

    if (currentX + objWidth + marginPx > folhaRight) {
      currentX = folhaLeft + marginPx;
      currentY += rowHeight + marginPx;
      rowHeight = 0;
    }

    obj.set({
      left: currentX,
      top: currentY
    });

    currentX += objWidth + marginPx;
    rowHeight = Math.max(rowHeight, objHeight);
  });

  canvas.renderAll();
  saveState();
}

document.getElementById('duplicateImageBtn').addEventListener('click', function() {
  const numDuplicates = parseInt(document.getElementById('duplicateInput').value) || 1;
  duplicateObjects(numDuplicates);
});

document.getElementById('organizeBtn').addEventListener('click', function() {
  const marginCm = parseFloat(document.getElementById('organizeInput').value) || 1;
  organizeObjects(marginCm);
});

// ---------- Final Seção Duplicar e organizar ---------- 

// ---------- Inicio Seção Drag and Drop ----------
function handleDrop(e) {
    e.preventDefault();
    e.stopPropagation();

    const files = e.dataTransfer.files;
    if (!files || files.length === 0) {
        showCustomAlert('Nenhum arquivo foi detectado. Por favor, tente novamente.');
        return;
    }

    handleFiles(files);
}

function handleFiles(files) {
    Array.from(files).forEach(file => {
        if (file.type.startsWith('image/')) {
            handleImageFile(file);
        } else if (file.type === 'application/pdf') {
            handlePdfFile(file);
        } else if (file.name.endsWith('.cloudapp')) {
            loadDocumentFile(file);
        } else {
            showCustomAlert('Arquivo não suportado. Por favor, insira imagens, PDFs ou arquivos .cloudapp.');
        }
    });
}

function handleImageFile(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
        if (!canvas || !canvas.add) {
            showCustomAlert('Erro ao carregar a área de trabalho. Por favor, feche e abra o app..');
            return;
        }

        // Criar uma imagem temporária para obter dimensões originais
        const tempImg = new Image();
        tempImg.onload = function() {
            const originalWidth = this.width;
            const originalHeight = this.height;

            fabric.Image.fromURL(e.target.result, function(img) {
                if (!img) {
                    showCustomAlert('Falha ao carregar a imagem.');
                    return;
                }

                const canvasCenter = getCanvasCenter();
                
                // Configurar a imagem com alta qualidade
                img.set({
                    left: canvasCenter.left,
                    top: canvasCenter.top,
                    originX: 'center',
                    originY: 'center',
                    perPixelTargetFind: true,
                    lockMovementX: false,
                    lockMovementY: false,
                    scaleX: 1,
                    scaleY: 1,
                    width: originalWidth,
                    height: originalHeight
                });

                // Definir DPI para 300
                img.set('dpi', 300);

                try {
                    canvas.add(img);
                    canvas.setActiveObject(img);
                    canvas.renderAll();
                    saveState();
                } catch (error) {
                    showCustomAlert('Erro ao adicionar a imagem ao canvas.');
                }
            }, { crossOrigin: 'Anonymous' });
        };
        tempImg.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function handlePdfFile(file) {
    const modalHtml = `
        <div id="pdfModal" class="modal-overlay" style="display: flex;">
            <div class="modal-content" style="width: 600px; height: auto; padding: 20px; min-width: 300px; max-height: 80%; overflow-y: auto; display: flex;">
                <div id="pdfImageContainer" style="flex: 1; display: flex; justify-content: center; align-items: center; margin-right: 20px;">
                    <img id="pdfPageImage" src="" alt="PDF Page" style="max-width: 100%; max-height: 400px; border: 1px solid #ccc;">
                </div>
                <div style="flex: 1;">
                    <h3 style="color: white; margin-bottom: 20px;">Selecionar Página do PDF</h3>
                    <div style="margin-bottom: 20px;">
                        <input type="number" id="pdfPageInput" value="1" min="1"
                               style="width: 100%; padding: 8px; background: #1a4b8c; color: white; border: 1px solid #235ab4;">
                    </div>
                    <div style="display: flex; justify-content: flex-end; gap: 10px;">
                        <button id="pdfCancelBtn" class="menu-item" style="width: auto;">Cancelar</button>
                        <button id="pdfConfirmBtn" class="menu-item" style="width: auto; background: #ffd700; color: black;">Importar</button>
                    </div>
                </div>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', modalHtml);

    const modal = document.getElementById('pdfModal');
    const cancelBtn = document.getElementById('pdfCancelBtn');
    const confirmBtn = document.getElementById('pdfConfirmBtn');
    const pageInput = document.getElementById('pdfPageInput');
    const pdfPageImage = document.getElementById('pdfPageImage');

    // Evento para mudar a página
    pageInput.addEventListener('input', () => {
        const pageNumber = parseInt(pageInput.value) || 1;
        loadPdfPageImage(file, pageNumber - 1);
    });

    // Função para carregar a imagem da página do PDF
    async function loadPdfPageImage(file, pageNumber) {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        
        // Atualizar o máximo de páginas no input
        pageInput.max = pdf.numPages;

        if (pageNumber >= pdf.numPages) {
            showCustomAlert('Página não existente no PDF.');
            return;
        }

        const page = await pdf.getPage(pageNumber + 1);
        // Escala para preview
        const scale = 2;
        const viewport = page.getViewport({ scale });

        const tempCanvas = document.createElement('canvas');
        const context = tempCanvas.getContext('2d');
        tempCanvas.height = viewport.height;
        tempCanvas.width = viewport.width;

        // Configurar contexto para melhor qualidade mesmo no preview
        context.imageSmoothingEnabled = true;
        context.imageSmoothingQuality = 'high';

        await page.render({
            canvasContext: context,
            viewport: viewport
        }).promise;

        pdfPageImage.src = tempCanvas.toDataURL('image/png', 1.0);
    }

    // Carrega a primeira página ao abrir o modal
    loadPdfPageImage(file, 0);

    cancelBtn.addEventListener('click', () => {
        modal.remove();
    });

    confirmBtn.addEventListener('click', () => {
        const selectedPage = parseInt(pageInput.value) || 1;
        convertPdfToImage(file, selectedPage - 1).then(() => {
            modal.remove();
        });
    });
}

async function convertPdfToImage(file, pageNumber) {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;

    if (pageNumber >= pdf.numPages) {
        showCustomAlert('Página não existente no PDF.');
        return;
    }

    const page = await pdf.getPage(pageNumber + 1);
    // Aumentar a escala para 300 DPI (300/72 = 4.17)
    const scale = 4.17;
    const viewport = page.getViewport({ scale });

    const tempCanvas = document.createElement('canvas');
    const context = tempCanvas.getContext('2d');
    
    // Configurar o canvas com dimensões maiores para maior qualidade
    tempCanvas.height = viewport.height;
    tempCanvas.width = viewport.width;
    
    // Configurar contexto para melhor qualidade
    context.imageSmoothingEnabled = true;
    context.imageSmoothingQuality = 'high';

    await page.render({
        canvasContext: context,
        viewport: viewport
    }).promise;

    if (!canvas || !canvas.add) {
        showCustomAlert('Erro ao carregar a área de trabalho. Por favor, feche e abra o app..');
        return;
    }

    fabric.Image.fromURL(tempCanvas.toDataURL('image/png', 1.0), function(img) {
        if (!img) {
            showCustomAlert('Erro ao carregar páginas do PDF.');
            return;
        }

        const canvasCenter = getCanvasCenter();
        img.set({
            left: canvasCenter.left,
            top: canvasCenter.top,
            originX: 'center',
            originY: 'center',
            perPixelTargetFind: true,
            lockMovementX: false,
            lockMovementY: false,
            scaleX: 1,
            scaleY: 1
        });

        // Definir DPI para 300
        img.set('dpi', 300);

        try {
            canvas.add(img);
            canvas.setActiveObject(img);
            canvas.renderAll();
            saveState();
        } catch (error) {
            showCustomAlert('Erro ao adicionar a página do PDF na área de trabalho.');
        }
    });
}

function getCanvasCenter() {
    return {
        left: canvas.getWidth() / 2,
        top: canvas.getHeight() / 2
    };
}

// Prevenção de eventos padrão de drag and drop
document.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.stopPropagation();
});

document.addEventListener('drop', handleDrop);
// ---------- Fim Seção Drag and Drop ----------

// ---------- Inicio Seção Texto ----------
const DEFAULT_TEXT_SETTINGS = {
    fontSize: 20,
    fontFamily: 'Arial',
    fill: '#000000',
    gradientMode: false,
    gradientType: 'linear',
    gradientStops: [
        { color: '#000000', position: 100 },
        { color: '#ff0000', position: 50 }
    ],
    gradientAngle: 0,
    stroke1: {
        enabled: false,
        width: 1,
        color: '#000000'
    }
};

// Mapa para armazenar configurações de texto por textId
const textSettingsMap = new Map();

// Configurações ativas do texto
let activeTextSettings = {
    gradientMode: false,
    gradientType: 'linear',
    gradientStops: [
        { color: '#000000', position: 100 },
        { color: '#ff0000', position: 50 }
    ],
    gradientAngle: 0,
    stroke1: {
        enabled: false,
        width: 1,
        color: '#000000'
    }
};

// Função para gerar um ID único para cada texto
function generateUniqueId() {
    return '_' + Math.random().toString(36).substr(2, 9);
}

// Função para salvar as configurações de um texto
function saveTextSettings(textObject) {
    if (!textObject.textId) {
        textObject.textId = generateUniqueId();
    }

    const settings = {
        gradientMode: activeTextSettings.gradientMode,
        gradientType: activeTextSettings.gradientType,
        gradientStops: JSON.parse(JSON.stringify(activeTextSettings.gradientStops)),
        gradientAngle: activeTextSettings.gradientAngle,
        stroke1: { ...activeTextSettings.stroke1 },
        fontFamily: textObject.fontFamily,
        fontSize: textObject.fontSize,
        fill: textObject.fill
    };

    textSettingsMap.set(textObject.textId, settings);
}

// Função para carregar as configurações de um texto
function loadTextSettings(textObject) {
    if (!textObject.textId || !textSettingsMap.has(textObject.textId)) {
        return false;
    }

    const settings = textSettingsMap.get(textObject.textId);

    // Atualizar as configurações ativas
    activeTextSettings = JSON.parse(JSON.stringify(settings));

    // Atualizar a interface
    document.getElementById('fontSelect').value = settings.fontFamily;
    document.getElementById('fontSizeInput').value = settings.fontSize;

    // Configurar o modo de cor (sólida ou gradiente)
    document.getElementById('solidColorBtn').classList.toggle('active', !settings.gradientMode);
    document.getElementById('gradientColorBtn').classList.toggle('active', settings.gradientMode);
    document.getElementById('solidColorPicker').style.display = settings.gradientMode ? 'none' : 'block';
    document.getElementById('gradientPicker').style.display = settings.gradientMode ? 'block' : 'none';

    if (!settings.gradientMode) {
        document.getElementById('textColorInput').value = textObject.fill;
    }

    // Atualizar configurações de contorno
    document.getElementById('stroke1Enable').checked = settings.stroke1.enabled;
    document.getElementById('stroke1Width').value = settings.stroke1.width;
    document.getElementById('stroke1Color').value = settings.stroke1.color;
    document.getElementById('stroke1Width').disabled = !settings.stroke1.enabled;
    document.getElementById('stroke1Color').disabled = !settings.stroke1.enabled;

    if (settings.gradientMode) {
        activeTextSettings.gradientStops = [...settings.gradientStops];
        updateGradientStopsUI();
    }
}

function updateActiveText() {
    return debugTextOperation('updateActiveText', () => {
        const activeObject = canvas.getActiveObject();
        if (!activeObject || !activeObject.type.includes('text')) {
            console.log('No active text object found');
            return;
        }

        console.log('Current text object settings:', {
            id: activeObject.textId,
            font: activeObject.fontFamily,
            size: activeObject.fontSize,
            fill: activeObject.fill
        });

        const newSettings = {
            fontFamily: document.getElementById('fontSelect').value,
            fontSize: parseInt(document.getElementById('fontSizeInput').value),
            selectable: true,
            editable: true
        };

        if (activeTextSettings.gradientMode) {
            newSettings.fill = createGradientFromStops(activeObject);
        } else {
            newSettings.fill = document.getElementById('textColorInput').value;
        }

        if (activeTextSettings.stroke1.enabled) {
            newSettings.stroke = activeTextSettings.stroke1.color;
            newSettings.strokeWidth = parseInt(activeTextSettings.stroke1.width);
            newSettings.paintFirst = 'stroke';
        } else {
            newSettings.stroke = null;
            newSettings.strokeWidth = 0;
        }

        console.log('Applying new settings:', newSettings);

        Object.entries(newSettings).forEach(([key, value]) => {
            try {
                activeObject.set(key, value);
                console.log(`Successfully set ${key} to:`, value);
            } catch (error) {
                console.error(`Error setting ${key}:`, error);
            }
        });

        activeObject.dirty = true;
        saveTextSettings(activeObject);
        canvas.requestRenderAll();
        saveState();
    });
}

function createGradientFromStops(obj) {
    const stops = activeTextSettings.gradientStops.sort((a, b) => a.position - b.position);
    const coords = calculateGradientCoords(obj, activeTextSettings.gradientAngle);

    return new fabric.Gradient({
        type: 'linear',
        coords: coords,
        colorStops: stops.map(stop => ({
            offset: stop.position / 100,
            color: stop.color
        }))
    });
}

function calculateGradientCoords(obj, angle) {
    const angleRad = angle * Math.PI / 180;
    const cos = Math.cos(angleRad);
    const sin = Math.sin(angleRad);

    return {
        x1: -obj.width / 2 * cos,
        y1: -obj.width / 2 * sin,
        x2: obj.width / 2 * cos,
        y2: obj.width / 2 * sin
    };
}

function updateTextStrokes(obj) {
    const stroke1 = activeTextSettings.stroke1;

    if (stroke1.enabled) {
        obj.set({
            strokeWidth: stroke1.width,
            stroke: stroke1.color,
            paintFirst: 'stroke',
            strokeUniform: true
        });
    } else {
        obj.set({
            strokeWidth: 0,
            stroke: null,
            paintFirst: 'fill',
            strokeUniform: true
        });
    }
}

function activateTextCategory() {
    categoryItems.forEach(i => i.classList.remove('active'));
    menuContents.forEach(m => m.classList.remove('active'));
    const textoCategory = document.querySelector('.category-item[data-category="texto"]');
    textoCategory.classList.add('active');
    document.getElementById('menu-texto').classList.add('active');
}

document.getElementById('addTextBtn').addEventListener('click', function() {
    debugTextOperation('addTextBtn click', () => {
        const text = new fabric.IText('CloudApp', {
            left: canvas.getWidth() / 2,
            top: canvas.getHeight() / 2,
            fontSize: DEFAULT_TEXT_SETTINGS.fontSize,
            fill: DEFAULT_TEXT_SETTINGS.fill,
            fontFamily: DEFAULT_TEXT_SETTINGS.fontFamily,
            originX: 'center',
            originY: 'center',
            editable: true,
            selectable: true
        });

        text.textId = generateUniqueId();
        console.log('Created new text object with ID:', text.textId);

        document.getElementById('fontSizeInput').value = DEFAULT_TEXT_SETTINGS.fontSize;
        document.getElementById('textColorInput').value = DEFAULT_TEXT_SETTINGS.fill;
        document.getElementById('fontSelect').value = DEFAULT_TEXT_SETTINGS.fontFamily;

        activeTextSettings = JSON.parse(JSON.stringify(DEFAULT_TEXT_SETTINGS));
        saveTextSettings(text);

        canvas.add(text);
        canvas.setActiveObject(text);
        canvas.requestRenderAll();
        saveState();

        activateTextCategory();
        updateTextControlsUI(text);
    });
});

canvas.off('mouse:dblclick');
canvas.off('text:editing:exited');

canvas.on('mouse:dblclick', function(options) {
    if (options.target && options.target.type.includes('text')) {
        const textObject = options.target;

        textObject.set({
            editable: true,
            selectable: true
        });

        canvas.setActiveObject(textObject);

        if(typeof textObject.enterEditing === 'function') {
            textObject.enterEditing();
            textObject.selectAll();
            return true;
        }
    }
    return false;
});

canvas.on('text:editing:entered', function(e) {
    if (e.target) {
        e.target.set({
            editable: true,
            selectable: true,
            isEditing: true
        });
        isTextEditing = true;
        isSpacePressed = false;
        isPanning = false;
        updateCursor();

        if (e.target.hiddenTextarea) {
            e.target.hiddenTextarea.onkeydown = function(ke) {
                if (ke.code === 'Space') {
                    ke.stopPropagation();
                }
            };
        }
    }
});

canvas.on('text:editing:exited', function(e) {
    if (e.target) {
        e.target.set({
            isEditing: false
        });
        isTextEditing = false;
        saveTextSettings(e.target);
        canvas.requestRenderAll();
        saveState();
    }
});

function updateTextControlsUI(textObject) {
    if (!textObject) return;

    const settings = textSettingsMap.get(textObject.textId);
    if (!settings) return;

    document.getElementById('fontSizeInput').value = textObject.fontSize;
    document.getElementById('fontSelect').value = textObject.fontFamily;

    document.getElementById('gradientColorBtn').classList.toggle('active', settings.gradientMode);
    document.getElementById('solidColorBtn').classList.toggle('active', !settings.gradientMode);
    document.getElementById('gradientPicker').style.display = settings.gradientMode ? 'block' : 'none';
    document.getElementById('solidColorPicker').style.display = settings.gradientMode ? 'none' : 'block';

    if (!settings.gradientMode) {
        document.getElementById('textColorInput').value = textObject.fill;
    }

    document.getElementById('stroke1Enable').checked = settings.stroke1.enabled;
    document.getElementById('stroke1Width').value = settings.stroke1.width;
    document.getElementById('stroke1Color').value = settings.stroke1.color;
    document.getElementById('stroke1Width').disabled = !settings.stroke1.enabled;
    document.getElementById('stroke1Color').disabled = !settings.stroke1.enabled;

    if (settings.gradientMode) {
        activeTextSettings.gradientStops = [...settings.gradientStops];
        updateGradientStopsUI();
    }
}

document.getElementById('fontSelect').addEventListener('input', updateActiveText);
document.getElementById('fontSizeInput').addEventListener('input', updateActiveText);
document.getElementById('textColorInput').addEventListener('input', updateActiveText);
document.getElementById('stroke1Color').addEventListener('input', updateActiveText);
document.getElementById('stroke1Width').addEventListener('input', updateActiveText);

document.getElementById('solidColorBtn').addEventListener('click', () => {
    activeTextSettings.gradientMode = false;
    document.getElementById('solidColorPicker').style.display = 'block';
    document.getElementById('gradientPicker').style.display = 'none';
    document.getElementById('solidColorBtn').classList.add('active');
    document.getElementById('gradientColorBtn').classList.remove('active');
    updateActiveText();
});

document.getElementById('gradientColorBtn').addEventListener('click', () => {
    activeTextSettings.gradientMode = true;
    document.getElementById('solidColorPicker').style.display = 'none';
    document.getElementById('gradientPicker').style.display = 'block';
    document.getElementById('gradientColorBtn').classList.add('active');
    document.getElementById('solidColorBtn').classList.remove('active');
    updateGradientStopsUI();
    updateActiveText();
});

document.getElementById('addGradientStop').addEventListener('click', () => {
    const stop = { color: '#000000', position: 50 };
    activeTextSettings.gradientStops.push(stop);
    updateGradientStopsUI();
    updateActiveText();
});

document.getElementById('stroke1Enable').addEventListener('change', function () {
    activeTextSettings.stroke1.enabled = this.checked;
    document.getElementById('stroke1Width').disabled = !this.checked;
    document.getElementById('stroke1Color').disabled = !this.checked;
    updateActiveText();
});

document.getElementById('stroke1Width').addEventListener('input', function () {
    activeTextSettings.stroke1.width = parseInt(this.value);
    updateActiveText();
});

document.getElementById('stroke1Color').addEventListener('input', function () {
    activeTextSettings.stroke1.color = this.value;
    updateActiveText();
});

function updateGradientStopsUI() {
    const container = document.querySelector('.gradient-stops');
    container.innerHTML = '';

    activeTextSettings.gradientStops.forEach((stop, index) => {
        const stopEl = document.createElement('div');
        stopEl.className = 'gradient-stop';
        stopEl.innerHTML = `
            <input type="color" class="gradient-color" value="\${stop.color}">
            <input type="number" class="gradient-position" value="\${stop.position}" min="0" max="100">
            <button class="remove-stop">&times;</button>
        `;

        stopEl.querySelector('.gradient-color').addEventListener('input', (e) => {
            stop.color = e.target.value;
            updateActiveText();
        });

        stopEl.querySelector('.gradient-position').addEventListener('input', (e) => {
            stop.position = parseInt(e.target.value);
            updateActiveText();
        });

        if (index >= 2) {
            stopEl.querySelector('.remove-stop').addEventListener('click', () => {
                activeTextSettings.gradientStops.splice(index, 1);
                updateGradientStopsUI();
                updateActiveText();
            });
        }

        container.appendChild(stopEl);
    });
}

canvas.on('selection:created', function (e) {
    if (e.selected[0].type.includes('text')) {
        activateTextCategory();
        const textObject = e.selected[0];

        if (!textObject.textId) {
            textObject.textId = generateUniqueId();
            saveTextSettings(textObject);
        }

        const settings = textSettingsMap.get(textObject.textId);
        if (settings) {
            activeTextSettings = JSON.parse(JSON.stringify(settings));
        }

        updateTextControlsUI(textObject);
        updateGradientStopsUI();
        updateActiveText();
    } else if (e.selected[0].type === 'image') {
        categoryItems.forEach(i => i.classList.remove('active'));
        menuContents.forEach(m => m.classList.remove('active'));
        const editCategory = document.querySelector('.category-item[data-category="editar"]');
        editCategory.classList.add('active');
        document.getElementById('menu-editar').classList.add('active');
    }
});

canvas.on('selection:updated', function (e) {
    if (e.selected[0].type.includes('text')) {
        activateTextCategory();
        const textObject = e.selected[0];

        if (!textObject.textId) {
            textObject.textId = generateUniqueId();
            saveTextSettings(textObject);
        }

        const settings = textSettingsMap.get(textObject.textId);
        if (settings) {
            activeTextSettings = JSON.parse(JSON.stringify(settings));
        }

        updateTextControlsUI(textObject);
        updateGradientStopsUI();
        updateActiveText();
    } else if (e.selected[0].type === 'image') {
        categoryItems.forEach(i => i.classList.remove('active'));
        menuContents.forEach(m => m.classList.remove('active'));
        const editCategory = document.querySelector('.category-item[data-category="editar"]');
        editCategory.classList.add('active');
        document.getElementById('menu-editar').classList.add('active');
    }
});

canvas.on('object:modified', function(e) {
    if (e.target && e.target.type.includes('text')) {
        textObject = e.target;

        textObject.set({
            editable: true,
            selectable: true
        });

        if (textObject.scaleX !== 1 || textObject.scaleY !== 1) {
            const newFontSize = Math.round(textObject.fontSize * textObject.scaleX);
            textObject.set({
                fontSize: newFontSize,
                scaleX: 1,
                scaleY: 1
            });

            const settings = textSettingsMap.get(textObject.textId);
            if (settings) {
                settings.fontSize = newFontSize;
                textSettingsMap.set(textObject.textId, settings);
            }

            document.getElementById('fontSizeInput').value = newFontSize;
        }
        canvas.renderAll();
        saveState();
    }
});

canvas.on('selection:cleared', function () {
    const textInput = document.getElementById('textInput');
    if (textInput) {
        textInput.value = '';
    }
});

document.getElementById('fontSizeInput').addEventListener('input', function () {
    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type.includes('text')) {
        const newFontSize = parseInt(this.value);
        activeObject.set({
            fontSize: newFontSize,
            scaleX: 1,
            scaleY: 1
        });
        canvas.renderAll();
        saveState();
    }
});

fabric.IText.prototype.dblClickHandler = function() {
    if (this.selectable && this.editable) {
        this.enterEditing();
        this.selectAll();
        return true;
    }
    return false;
};

function calculateGradientAngle(coords) {
    if (!coords) return 0;
    const dx = coords.x2 - coords.x1;
    const dy = coords.y2 - coords.y1;
    return Math.round(Math.atan2(dy, dx) * 180 / Math.PI);
}

// ---------- Final Seção Texto ----------

// ---------- Inicio Seção Eventos de Texto ----------
function processText(text) {
    return text
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n');
}

const textInput = document.getElementById('textInput');
if (textInput) {
    textInput.addEventListener('input', function(e) {
        const activeObjects = canvas.getActiveObjects();
        if (activeObjects.length === 0) return;

        const newText = processText(this.value);

        activeObjects.forEach(obj => {
            if (obj.type.includes('text')) {
                obj.set({
                    text: newText,
                    splitByGrapheme: true
                });

                obj.dirty = true;
            }
        });

        canvas.requestRenderAll();
        saveState();
    });
}

canvas.on('selection:created', function(e) {
    if (e.selected[0] && e.selected[0].type.includes('text')) {
        const textObject = e.selected[0];
        const textInput = document.getElementById('textInput');
        if (textInput) {
            textInput.value = textObject.text || '';
            textInput.style.whiteSpace = 'pre-wrap';
        }
    }
});

canvas.on('selection:updated', function(e) {
    if (e.selected[0] && e.selected[0].type.includes('text')) {
        const textObject = e.selected[0];
        const textInput = document.getElementById('textInput');
        if (textInput) {
            textInput.value = textObject.text || '';
            textInput.style.whiteSpace = 'pre-wrap';
        }
    }
});

const style = document.createElement('style');
style.textContent = `
#textInput {
    white-space: pre-wrap;
    min-height: 50px;
    resize: vertical;
    font-family: inherit;
}
`;
document.head.appendChild(style);

function debugTextOperation(operation, callback) {
    console.log(`Starting ${operation}`);
    try {
        const result = callback();
        console.log(`${operation} completed successfully`);
        return result;
    } catch (error) {
        console.error(`Error in ${operation}:`, error);
        return null;
    }
}

['fontSelect', 'fontSizeInput', 'textColorInput'].forEach(id => {
    const element = document.getElementById(id);
    if (element) {
        element.addEventListener('change', function(e) {
            debugTextOperation(`${id} change`, () => {
                console.log(`${id} changed to:`, e.target.value);
                updateActiveText();
            });
        });

        element.addEventListener('input', function(e) {
            debugTextOperation(`${id} input`, () => {
                console.log(`${id} input value:`, e.target.value);
                updateActiveText();
            });
        });
    }
});

document.addEventListener('DOMContentLoaded', () => {
    debugTextOperation('DOMContentLoaded', () => {
        const textControls = document.querySelector('.text-controls');
        if (textControls) {
            textControls.style.display = 'block';
            console.log('Text controls initialized and displayed');
        } else {
            console.warn('Text controls container not found');
        }
    });
});

// ---------- Final Seção Eventos de Texto ----------

// ----------------------------------------- Seção Inicio Alerta Personalizado ----------------------------------------------------
// Função para exibir o modal personalizado
function showCustomAlert(message) {
    const modal = document.getElementById('customAlertModal');
    const messageElement = document.getElementById('customAlertMessage');

    messageElement.textContent = message;
    modal.style.display = 'flex';
}

// Função para fechar o modal personalizado
function closeCustomAlert() {
    const modal = document.getElementById('customAlertModal');
    modal.style.display = 'none';
}

// Evento para fechar o modal ao clicar fora da área do modal
document.getElementById('customAlertModal').addEventListener('click', function(e) {
    if (e.target === this) {
        closeCustomAlert();
    }
});
// ----------------------------------------- Seção Final Alerta Personalizado ----------------------------------------------------

// ---------- Seção Inicio Edição de imagem ---------

document.getElementById('btnPincel').addEventListener('click', function () {
    const activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') {
		showCustomAlert('Selecione uma imagem primeiro');
        return;
    }

    const modal = document.createElement('div');
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    modal.style.zIndex = '1000';
    modal.style.display = 'flex';
    modal.style.flexDirection = 'column';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';

    const modalContent = document.createElement('div');
    modalContent.style.width = '100%';
    modalContent.style.height = 'calc(100% - 80px)';
    modalContent.style.backgroundColor = '#16213e';
    modalContent.style.display = 'flex';
    modalContent.style.alignItems = 'center';
    modalContent.style.justifyContent = 'center';

    const paintingCanvas = document.createElement('canvas');
    paintingCanvas.style.maxWidth = '100%';
    paintingCanvas.style.maxHeight = '100%';
    paintingCanvas.style.border = '1px solid #ccc';
    modalContent.appendChild(paintingCanvas);

    const paintingCtx = paintingCanvas.getContext('2d');
    const imageElement = activeObject.getElement();

    const originalWidth = imageElement.naturalWidth;
    const originalHeight = imageElement.naturalHeight;

    paintingCanvas.width = originalWidth;
    paintingCanvas.height = originalHeight;

    paintingCtx.drawImage(imageElement, 0, 0, originalWidth, originalHeight);

    let history = [];
    let historyIndex = -1;
    saveHistory();

    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let currentTool = 'brush';

    const modalMenu = document.createElement('div');
    modalMenu.style.width = '100%';
    modalMenu.style.height = '80px';
    modalMenu.style.backgroundColor = '#0f3460';
    modalMenu.style.display = 'flex';
    modalMenu.style.alignItems = 'center';
    modalMenu.style.justifyContent = 'center';
    modalMenu.style.gap = '10px';

    const createButton = (text, id) => {
        const button = document.createElement('button');
        button.textContent = text;
        button.id = id;
        button.style.padding = '10px 20px';
        button.style.border = 'none';
        button.style.borderRadius = '5px';
        button.style.backgroundColor = '#1a4b8c';
        button.style.color = '#fff';
        button.style.cursor = 'pointer';
        button.style.fontSize = '14px';
        button.style.transition = 'all 0.3s ease';
        return button;
    };

    const brushButton = createButton('Pincel', 'brushBtn');
    const eraserButton = createButton('Borracha', 'eraserBtn');
    const bucketButton = createButton('Balde de Tinta', 'bucketBtn');
    const closeButton = createButton('Fechar', 'closeBrushModal');
    const saveButton = createButton('Salvar', 'saveBrushModal');
    const undoButton = createButton('Voltar', 'undoBrushModal');

    brushButton.style.backgroundColor = '#ffd700';
    brushButton.style.color = '#000';

    const sizeSlider = document.createElement('input');
    sizeSlider.type = 'range';
    sizeSlider.min = '1';
    sizeSlider.max = '200';
    sizeSlider.value = '50';
    sizeSlider.style.width = '200px';

    const colorPicker = document.createElement('input');
    colorPicker.type = 'color';
    colorPicker.value = '#000000';

    modalMenu.appendChild(brushButton);
    modalMenu.appendChild(eraserButton);
    modalMenu.appendChild(bucketButton);
    modalMenu.appendChild(sizeSlider);
    modalMenu.appendChild(colorPicker);
    modalMenu.appendChild(undoButton);
    modalMenu.appendChild(closeButton);
    modalMenu.appendChild(saveButton);

    function resetButtonStyles() {
        [brushButton, eraserButton, bucketButton].forEach(btn => {
            btn.style.backgroundColor = '#1a4b8c';
            btn.style.color = '#fff';
        });
    }

    brushButton.addEventListener('click', () => {
        resetButtonStyles();
        brushButton.style.backgroundColor = '#ffd700';
        brushButton.style.color = '#000';
        currentTool = 'brush';
    });

    eraserButton.addEventListener('click', () => {
        resetButtonStyles();
        eraserButton.style.backgroundColor = '#ffd700';
        eraserButton.style.color = '#000';
        currentTool = 'eraser';
    });

    bucketButton.addEventListener('click', () => {
        resetButtonStyles();
        bucketButton.style.backgroundColor = '#ffd700';
        bucketButton.style.color = '#000';
        currentTool = 'bucket';
    });

    function getMousePos(canvas, e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }

    function draw(e) {
        if (!isDrawing) return;
        if (currentTool === 'bucket') return;

        const pos = getMousePos(paintingCanvas, e);
        const brushSizeValue = parseInt(sizeSlider.value);

        paintingCtx.lineWidth = brushSizeValue;
        paintingCtx.lineCap = 'round';
        paintingCtx.lineJoin = 'round';

        if (currentTool === 'eraser') {
            paintingCtx.globalCompositeOperation = 'destination-out';
            paintingCtx.strokeStyle = 'rgba(0,0,0,1)';
        } else {
            paintingCtx.globalCompositeOperation = 'source-over';
            paintingCtx.strokeStyle = colorPicker.value;
        }

        paintingCtx.beginPath();
        paintingCtx.moveTo(lastX, lastY);
        paintingCtx.lineTo(pos.x, pos.y);
        paintingCtx.stroke();

        [lastX, lastY] = [pos.x, pos.y];
    }

    function getPixel(imageData, x, y) {
        const index = (y * imageData.width + x) * 4;
        return {
            r: imageData.data[index],
            g: imageData.data[index + 1],
            b: imageData.data[index + 2],
            a: imageData.data[index + 3]
        };
    }

    function setPixel(imageData, x, y, color) {
        const index = (y * imageData.width + x) * 4;
        imageData.data[index] = color.r;
        imageData.data[index + 1] = color.g;
        imageData.data[index + 2] = color.b;
        imageData.data[index + 3] = color.a;
    }

    function colorMatch(c1, c2, tolerance) {
        return Math.abs(c1.r - c2.r) <= tolerance &&
               Math.abs(c1.g - c2.g) <= tolerance &&
               Math.abs(c1.b - c2.b) <= tolerance &&
               Math.abs(c1.a - c2.a) <= tolerance;
    }

    function floodFill(imageData, startX, startY, fillColor, tolerance) {
        const width = imageData.width;
        const height = imageData.height;
        const visited = new Uint8Array(width * height);
        const queue = [];

        const targetColor = getPixel(imageData, startX, startY);
        const fillColorRGB = {
            r: parseInt(fillColor.slice(1,3), 16),
            g: parseInt(fillColor.slice(3,5), 16),
            b: parseInt(fillColor.slice(5,7), 16),
            a: 255
        };

        if (colorMatch(targetColor, fillColorRGB, 0)) {
            return;
        }

        queue.push([startX, startY]);
        visited[startY * width + startX] = 1;

        const processChunk = () => {
            let processCount = 0;
            const chunkSize = 1000;

            while (queue.length > 0 && processCount < chunkSize) {
                const [x, y] = queue.shift();
                const currentPixel = getPixel(imageData, x, y);

                if (colorMatch(currentPixel, targetColor, tolerance)) {
                    setPixel(imageData, x, y, fillColorRGB);

                    const neighbors = [
                        [x - 1, y], [x + 1, y],
                        [x, y - 1], [x, y + 1]
                    ];

                    for (const [nx, ny] of neighbors) {
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const index = ny * width + nx;
                            if (!visited[index]) {
                                visited[index] = 1;
                                queue.push([nx, ny]);
                            }
                        }
                    }
                }
                processCount++;
            }

            paintingCtx.putImageData(imageData, 0, 0);

            if (queue.length > 0) {
                requestAnimationFrame(processChunk);
            }
        };

        requestAnimationFrame(processChunk);
    }

    paintingCanvas.addEventListener('mousedown', (e) => {
        isDrawing = true;
        const pos = getMousePos(paintingCanvas, e);
        [lastX, lastY] = [pos.x, pos.y];

        saveHistory();

        if (currentTool === 'bucket') {
            const imageData = paintingCtx.getImageData(0, 0, paintingCanvas.width, paintingCanvas.height);
            floodFill(imageData, Math.floor(pos.x), Math.floor(pos.y), colorPicker.value, parseInt(sizeSlider.value));
        }
    });

    paintingCanvas.addEventListener('mousemove', draw);
    paintingCanvas.addEventListener('mouseup', () => {
        isDrawing = false;
    });
    paintingCanvas.addEventListener('mouseout', () => {
        isDrawing = false;
    });

    saveButton.addEventListener('click', () => {
        const imageURL = paintingCanvas.toDataURL('image/png', 1.0);
        fabric.Image.fromURL(imageURL, (img) => {
            const scaleX = activeObject.getScaledWidth() / img.width;
            const scaleY = activeObject.getScaledHeight() / img.height;

            img.set({
                left: activeObject.left,
                top: activeObject.top,
                scaleX: scaleX,
                scaleY: scaleY,
                angle: activeObject.angle
            });
            canvas.remove(activeObject);
            canvas.add(img);
            canvas.renderAll();
            document.body.removeChild(modal);
        });
    });

    closeButton.addEventListener('click', () => {
        document.body.removeChild(modal);
    });

    function saveHistory() {
        history = history.slice(0, historyIndex + 1);
        history.push(paintingCtx.getImageData(0, 0, paintingCanvas.width, paintingCanvas.height));
        historyIndex++;
    }

    undoButton.addEventListener('click', () => {
        if (historyIndex > 0) {
            historyIndex--;
            const previousState = history[historyIndex];
            paintingCtx.putImageData(previousState, 0, 0);
        }
    });

    modal.appendChild(modalContent);
    modal.appendChild(modalMenu);
    document.body.appendChild(modal);
});

// ----------------------------------------- Seção Final Edição de imagem ----------------------------------------------------

// ----------------------------------------- Seção Inicio Remover Cor ----------------------------------------------------

document.getElementById('removeColorBtn').addEventListener('click', function() {
    const activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') {
        showCustomAlert('Selecione uma imagem para remover a cor');
        return;
    }

    const removeColorModal = document.getElementById('removeColorModal');
    const removeColorCanvas = document.getElementById('removeColorCanvas');

    const originalImage = activeObject._element;
    removeColorCanvas.width = originalImage.width;
    removeColorCanvas.height = originalImage.height;

    const ctx = removeColorCanvas.getContext('2d');
    ctx.drawImage(originalImage, 0, 0, originalImage.width, originalImage.height);

    removeColorHistory = [];
    currentRemoveColorIndex = -1;
    saveRemoveColorHistory(ctx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height));

    removeColorModal.style.display = 'flex';
});

function saveRemoveColorHistory(imageData) {
    removeColorHistory = removeColorHistory.slice(0, currentRemoveColorIndex + 1);

    removeColorHistory.push(imageData);
    currentRemoveColorIndex++;

    if (removeColorHistory.length > 10) {
        removeColorHistory.shift();
        currentRemoveColorIndex--;
    }
}

document.getElementById('closeRemoveColorModal').addEventListener('click', function() {
    document.getElementById('removeColorModal').style.display = 'none';
});

document.getElementById('undoRemoveColor').addEventListener('click', function() {
    if (currentRemoveColorIndex > 0) {
        currentRemoveColorIndex--;
        const previousState = removeColorHistory[currentRemoveColorIndex];
        const ctx = removeColorCanvas.getContext('2d');
        ctx.putImageData(previousState, 0, 0);
    }
});

const saveRemoveColor = document.getElementById('saveRemoveColor');
const oldSaveElement = saveRemoveColor.cloneNode(true);
saveRemoveColor.parentNode.replaceChild(oldSaveElement, saveRemoveColor);

document.getElementById('saveRemoveColor').addEventListener('click', function () {
    const removeColorCanvas = document.getElementById('removeColorCanvas');
    const activeObject = canvas.getActiveObject();
    const removeColorModal = document.getElementById('removeColorModal');

    if (!activeObject || activeObject.type !== 'image') {
        removeColorModal.style.display = 'none';
        return;
    }

    const dataURL = removeColorCanvas.toDataURL('image/png', 1.0);

    const originalProps = {
        left: activeObject.left,
        top: activeObject.top,
        scaleX: activeObject.scaleX,
        scaleY: activeObject.scaleY,
        angle: activeObject.angle,
        flipX: activeObject.flipX,
        flipY: activeObject.flipY,
        width: activeObject.width,
        height: activeObject.height,
        originX: activeObject.originX,
        originY: activeObject.originY,
        centeredScaling: activeObject.centeredScaling,
        centeredRotation: activeObject.centeredRotation
    };

    canvas.remove(activeObject);

    fabric.Image.fromURL(dataURL, function (newImage) {
        newImage.set(originalProps);
        
        newImage.setCoords();
        
        canvas.add(newImage);
        canvas.setActiveObject(newImage);
        canvas.renderAll();
        saveState();

        removeColorModal.style.display = 'none';
    });
});

removeColorBtn.addEventListener('click', () => {
    const activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') {
        showCustomAlert('Selecione uma imagem para remover a cor');
        return;
    }
    activeImage = activeObject;
    prepareRemoveColorCanvas(activeImage);
});

removeRegionBtn.addEventListener('click', () => {
    currentRemoveMode = 'region';
    removeRegionBtn.classList.add('active');
    removeTotalBtn.classList.remove('active');
});

removeTotalBtn.addEventListener('click', () => {
    currentRemoveMode = 'total';
    removeTotalBtn.classList.add('active');
    removeRegionBtn.classList.remove('active');
});

removeColorCanvas.addEventListener('click', (e) => {
    if (currentRemoveMode === 'region') {
        handleRemoveColorRegion(e);
    } else {
        handleRemoveColorTotal(e);
    }
});

closeRemoveColorModal.addEventListener('click', () => {
    removeColorModal.style.display = 'none';
});

undoRemoveColor.addEventListener('click', () => {
    if (removeColorHistoryIndex > 0) {
        removeColorHistoryIndex--;
        const previousState = removeColorHistory[removeColorHistoryIndex];
        const ctx = removeColorCanvas.getContext('2d');
        ctx.putImageData(previousState, 0, 0);
    }
});

function handleRemoveColorRegion(e) {
    if (!removeColorCtx) return;

    const currentState = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    saveRemoveColorHistory(currentState);

    const rect = removeColorCanvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) * (removeColorCanvas.width / rect.width));
    const y = Math.floor((e.clientY - rect.top) * (removeColorCanvas.height / rect.height));

    const imageData = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    const tolerance = parseInt(sensitivityRange.value);

    const processedImageData = floodFillAtPoint(
        imageData,
        x,
        y,
        { r: 0, g: 0, b: 0, a: 0 },
        tolerance
    );

    removeColorCtx.putImageData(processedImageData, 0, 0);
}

function handleRemoveColorTotal(e) {
    if (!removeColorCtx) return;

    // Save state before making changes
    const currentState = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    saveRemoveColorHistory(currentState);

    const rect = removeColorCanvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) * (removeColorCanvas.width / rect.width));
    const y = Math.floor((e.clientY - rect.top) * (removeColorCanvas.height / rect.height));

    const imageData = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    const tolerance = parseInt(sensitivityRange.value);
    const targetColor = getPixel(imageData, x, y);

    const processedImageData = floodFillEntireImage(
        imageData,
        targetColor,
        { r: 0, g: 0, b: 0, a: 0 },
        tolerance
    );

    removeColorCtx.putImageData(processedImageData, 0, 0);
}

function prepareRemoveColorCanvas(activeImage) {
    const removeColorCanvas = document.getElementById('removeColorCanvas');
    const removeColorModal = document.getElementById('removeColorModal');
    
    removeColorCtx = removeColorCanvas.getContext('2d');
    
    // Usar as dimensões originais da imagem
    const originalWidth = activeImage.getElement().naturalWidth;
    const originalHeight = activeImage.getElement().naturalHeight;
    
    // Definir as dimensões do canvas para a resolução original
    removeColorCanvas.width = originalWidth;
    removeColorCanvas.height = originalHeight;
    
    // Desenhar a imagem em resolução original
    removeColorCtx.drawImage(activeImage.getElement(), 0, 0, originalWidth, originalHeight);
    
    // Ajustar apenas o CSS para exibição (não afeta a resolução real)
    const modalWidth = removeColorModal.clientWidth;
    const modalHeight = removeColorModal.clientHeight;
    const imageRatio = originalWidth / originalHeight;
    const modalRatio = modalWidth / modalHeight;
    
    if (imageRatio > modalRatio) {
        removeColorCanvas.style.width = '90%';
        removeColorCanvas.style.height = 'auto';
    } else {
        removeColorCanvas.style.width = 'auto';
        removeColorCanvas.style.height = '90%';
    }
    
    // Limpa o histórico e salva o estado inicial
    removeColorHistory = [];
    removeColorHistoryIndex = -1;
    saveRemoveColorHistory();
    
    removeColorModal.style.display = 'flex';
}

function saveRemoveColorHistory() {
    if (!removeColorCtx) return;
    const imageData = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    removeColorHistory = removeColorHistory.slice(0, removeColorHistoryIndex + 1);
    removeColorHistory.push(imageData);
    removeColorHistoryIndex = removeColorHistory.length - 1;
}

function floodFillAtPoint(imageData, startX, startY, fillColor, tolerance) {
    const width = imageData.width;
    const height = imageData.height;
    const visited = new Uint8Array(width * height);
    const queue = [];

    const targetColor = getPixel(imageData, startX, startY);
    if (!targetColor) return imageData;

    queue.push([startX, startY]);
    visited[startY * width + startX] = 1;

    while (queue.length > 0) {
        const [x, y] = queue.shift();
        const currentPixel = getPixel(imageData, x, y);

        if (colorMatch(currentPixel, targetColor, tolerance)) {
            setPixel(imageData, x, y, fillColor);

            [[x-1,y], [x+1,y], [x,y-1], [x,y+1]].forEach(([nx,ny]) => {
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const index = ny * width + nx;
                    if (!visited[index]) {
                        visited[index] = 1;
                        queue.push([nx,ny]);
                    }
                }
            });
        }
    }

    return imageData;
}

function handleRemoveColorTotal(e) {
    if (!removeColorCtx) return;

    // Save state before making changes
    const currentState = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    saveRemoveColorHistory(currentState);

    const rect = removeColorCanvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) * (removeColorCanvas.width / rect.width));
    const y = Math.floor((e.clientY - rect.top) * (removeColorCanvas.height / rect.height));

    const imageData = removeColorCtx.getImageData(0, 0, removeColorCanvas.width, removeColorCanvas.height);
    const tolerance = parseInt(sensitivityRange.value);
    const targetColor = getPixel(imageData, x, y);

    const processedImageData = floodFillEntireImage(
        imageData,
        targetColor,
        { r: 0, g: 0, b: 0, a: 0 },
        tolerance
    );

    removeColorCtx.putImageData(processedImageData, 0, 0);
}

function floodFillEntireImage(imageData, targetColor, fillColor, tolerance) {
    const width = imageData.width;
    const height = imageData.height;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const currentPixel = getPixel(imageData, x, y);
            if (colorMatch(currentPixel, targetColor, tolerance)) {
                setPixel(imageData, x, y, fillColor);
            }
        }
    }

    return imageData;
}

function getPixel(imageData, x, y) {
    const index = (y * imageData.width + x) * 4;
    if (index >= imageData.data.length) return null;
    return {
        r: imageData.data[index],
        g: imageData.data[index + 1],
        b: imageData.data[index + 2],
        a: imageData.data[index + 3]
    };
}

function setPixel(imageData, x, y, color) {
    const index = (y * imageData.width + x) * 4;
    if (index >= imageData.data.length) return;
    imageData.data[index] = color.r;
    imageData.data[index + 1] = color.g;
    imageData.data[index + 2] = color.b;
    imageData.data[index + 3] = color.a;
}

function colorMatch(c1, c2, tolerance) {
    if (!c1 || !c2) return false;
    return Math.abs(c1.r - c2.r) <= tolerance &&
           Math.abs(c1.g - c2.g) <= tolerance &&
           Math.abs(c1.b - c2.b) <= tolerance;
}
document.getElementById('removeRegionBtn').addEventListener('click', () => {
    currentRemoveMode = 'region';
    removeRegionBtn.classList.add('active');
    removeTotalBtn.classList.remove('active');
    updateButtonStyles();
});

function updateButtonStyles() {
    if (currentRemoveMode === 'region') {
        removeRegionBtn.style.backgroundColor = '#ffd700';
        removeRegionBtn.style.color = 'black';
        removeTotalBtn.style.backgroundColor = '#1a4b8c';
        removeTotalBtn.style.color = 'white';
    } else {
        removeTotalBtn.style.backgroundColor = '#ffd700';
        removeTotalBtn.style.color = 'black';
        removeRegionBtn.style.backgroundColor = '#1a4b8c';
        removeRegionBtn.style.color = 'white';
    }
}

document.getElementById('removeTotalBtn').addEventListener('click', () => {
    currentRemoveMode = 'total';
    removeTotalBtn.classList.add('active');
    removeRegionBtn.classList.remove('active');
    updateButtonStyles();
});
document.getElementById('removeColorModal').addEventListener('click', function(e) {
    if (e.target === this) {
        this.style.display = 'none';
    }
});
// ----------------------------------------- Seção Final Remover Cor ----------------------------------------------------

// Update layers list when canvas objects change
function updateLayersList() {
    const layersList = document.getElementById('layersList');
    layersList.innerHTML = '';
    
    // Get all objects except CloudFolha
    const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
    
    objects.reverse().forEach((obj, index) => {
        const li = document.createElement('li');
        li.setAttribute('data-index', canvas.getObjects().indexOf(obj));
        
        // Set layer name based on object type
        let layerName = obj.type;
        if (obj.name) {
            layerName = obj.name;
        } else if (obj.type === 'i-text' || obj.type === 'text') {
            layerName = `Text: ${obj.text.substring(0, 15)}${obj.text.length > 15 ? '...' : ''}`;
        } else if (obj.type === 'image') {
            layerName = `Image ${index + 1}`;
        } else {
            layerName = `${obj.type.charAt(0).toUpperCase() + obj.type.slice(1)} ${index + 1}`;
        }
        
        li.textContent = layerName;
        
        // Highlight selected objects
        if (obj === canvas.getActiveObject() || (canvas.getActiveObjects() && canvas.getActiveObjects().includes(obj))) {
            li.classList.add('selected');
        }
        
        // Make list items draggable
        li.draggable = true;
        
        // Add event listeners for drag and drop
        li.addEventListener('dragstart', handleDragStart);
        li.addEventListener('dragover', handleDragOver);
        li.addEventListener('drop', handleDrop);
        li.addEventListener('dragenter', handleDragEnter);
        li.addEventListener('dragleave', handleDragLeave);
        
        // Add click event to select object
        li.addEventListener('click', () => {
            canvas.discardActiveObject();
            canvas.setActiveObject(obj);
            canvas.requestRenderAll();
        });
        
        layersList.appendChild(li);
    });
}

// Drag and drop handlers
let draggedItem = null;

function handleDragStart(e) {
    draggedItem = this;
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', this.innerHTML);
    this.classList.add('dragging');
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
}

function handleDragEnter(e) {
    this.classList.add('over');
}

function handleDragLeave(e) {
    this.classList.remove('over');
}


// Add event listeners for canvas changes
canvas.on('object:added', updateLayersList);
canvas.on('object:removed', updateLayersList);
canvas.on('selection:created', updateLayersList);
canvas.on('selection:updated', updateLayersList);
canvas.on('selection:cleared', updateLayersList);

// Layer button handlers
document.getElementById('newLayerBtn').addEventListener('click', () => {
    const rect = new fabric.Rect({
        left: canvas.width / 2,
        top: canvas.height / 2,
        width: 100,
        height: 100,
        fill: '#ffffff',
        originX: 'center',
        originY: 'center'
    });
    canvas.add(rect);
    canvas.setActiveObject(rect);
    saveState();
});

document.getElementById('deleteLayerBtn').addEventListener('click', () => {
    const activeObject = canvas.getActiveObject();
    if (activeObject) {
        canvas.remove(activeObject);
        canvas.discardActiveObject();
        saveState();
    }
});

document.getElementById('centerLayerBtn').addEventListener('click', () => {
    const activeObject = canvas.getActiveObject();
    if (activeObject) {
        const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
        if (cloudFolha) {
            activeObject.set({
                left: cloudFolha.left + cloudFolha.width * cloudFolha.scaleX / 2,
                top: cloudFolha.top + cloudFolha.height * cloudFolha.scaleY / 2
            });
            canvas.renderAll();
            saveState();
        }
    }
});

// Initial update of layers list
updateLayersList();
</script>
</body>
</html>
