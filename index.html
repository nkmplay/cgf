<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CloudPhoto Editor</title>
<link rel="stylesheet" href="">
<script src="https://nkmplay.github.io/cgf/scripts/fabric_5.2.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://nkmplay.github.io/cgf/scripts/pdf.min.js"></script>
<script src="https://cloudgraficaweb.github.io/CGVendas/scripts/potrace.js"></script>
<link rel="stylesheet" href="https://nkmplay.github.io/cgf/scripts/cropper.min.css">
<script src="https://nkmplay.github.io/cgf/scripts/cropper.min.js"></script>
<style>
  body {
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    height: 100vh;
    font-family: Arial, sans-serif;
    background-color: #151f28;
  }

  .main-container {
    display: flex;
    flex-grow: 1;
    overflow: hidden;
    position: relative;
  }

  .top-menu {
    background-color: #2c3e50;
    padding: 5px 10px;
    display: flex;
    align-items: center;
    color: #ecf0f1;
  }

  .menu-buttons {
    display: flex;
    gap: 10px;
    margin-right: 20px;
  }

  .menu-button {
    background: none;
    border: none;
    color: #ecf0f1;
    padding: 5px 3px;
    cursor: pointer;
    border-radius: 3px;
    position: relative;
  }

  .menu-button:hover {
    background-color: #34495e;
  }

  .dropdown-toggle::after {
    content: " ▼";
    font-size: 0.6em;
  }

  .dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    background-color: #34495e;
    min-width: 150px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 1000;
  }

  .dropdown:hover .dropdown-menu {
    display: block;
  }

  .dropdown-menu button {
    width: 100%;
    text-align: left;
    background: none;
    border: none;
    color: #ecf0f1;
    padding: 10px;
    cursor: pointer;
    font-size: 14px;
  }

  .dropdown-menu button:hover {
    background-color: #3d566e;
  }

  .guide-option {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 5px 10px;
  }

  .guide-option button {
    flex: 1;
    padding: 5px;
    background: none;
    border: none;
    color: #ecf0f1;
    cursor: pointer;
    font-size: 14px;
  }

  .guide-option button:hover {
    background-color: #3d566e;
  }

  .guide-option input {
    flex: 1;
    padding: 3px;
    border: 1px solid #34495e;
    border-radius: 3px;
    background-color: #34495e;
    color: #ecf0f1;
  }

  .dimension-controls {
    display: flex;
    align-items: center;
    gap: 5px;
    background-color: #243442;
    padding: 5px 10px;
    border-radius: 4px;
  }

  .dimension-input {
    width: 60px;
    padding: 3px;
    border: 1px solid #34495e;
    border-radius: 3px;
    background-color: #34495e;
    color: #ecf0f1;
  }

  .dimension-input:focus {
    outline: none;
    background-color: #3d566e;
  }

  .sidebar {
    width: 60px;
    background-color: #2c3e50;
    color: #ecf0f1;
    padding: 10px;
    box-sizing: border-box;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
  }

  .sidebar ul {
    list-style: none;
    padding: 0;
    margin: 0;
    flex-grow: 1;
  }

  .sidebar li {
    margin-bottom: 15px;
  }

  .sidebar button {
    width: 100%;
    padding: 5px;
    background-color: #34495e;
    color: #ecf0f1;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: background-color 0.3s ease;
    font-size: 8px;
    text-align: center;
  }

  .sidebar button svg {
    margin-bottom: 4px;
  }

  .sidebar button:hover {
    background-color: #3d566e;
  }

  #container {
    background-color: #e0e0e0;
    flex-grow: 1;
  }

  .layers-panel {
    width: 200px;
    background-color: #2c3e50;
    color: #ecf0f1;
    padding: 10px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    border-left: 1px solid #34495e;
  }

  .layers-title {
    font-size: 12px;
    font-weight: bold;
    padding: 5px;
    margin-bottom: 10px;
    border-bottom: 1px solid #34495e;
  }

  .layers-list {
    list-style: none;
    padding: 0;
    margin: 0;
    flex-grow: 1;
    overflow-y: auto;
  }

  .layer-item {
    padding: 8px;
    margin: 2px 0;
    background-color: #34495e;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    font-size: 12px;
    position: relative;
    transition: transform 0.2s, background-color 0.3s;
  }

  .layer-item.selected {
    background-color: #3498db;
  }

  .layer-item.dragging {
    opacity: 0.5;
    background-color: #2c3e50;
  }

  .layer-item.drag-over {
    border-top: 2px solid #3498db;
    transform: translateY(2px);
  }

  .layer-item.drag-over-bottom {
    border-bottom: 2px solid #3498db;
    transform: translateY(-2px);
  }

  .selection-rect {
    position: absolute;
    border: 1px solid #0099ff;
    background: rgba(0, 153, 255, 0.1);
    pointer-events: none;
  }

  textarea.text-edit {
    position: absolute;
    border: none;
    padding: 0px;
    margin: 0px;
    overflow: hidden;
    background: none;
    outline: none;
    resize: none;
    line-height: 1;
    font-family: Arial, sans-serif;
    font-size: 20px;
    color: #000;
  }

  .dropdown {
    position: relative;
  }

  .dropdown-toggle {
    background: none;
    border: none;
    color: #ecf0f1;
    padding: 5px 10px;
    cursor: pointer;
    border-radius: 3px;
  }

  .dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    background-color: #34495e;
    min-width: 150px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 1000;
  }

  .dropdown:hover .dropdown-menu {
    display: block;
  }

  .dropdown-menu button {
    width: 100%;
    text-align: left;
    background: none;
    border: none;
    color: #ecf0f1;
    padding: 10px;
    cursor: pointer;
  }

  .dropdown-menu button:hover {
    background-color: #3d566e;
  }

.text-styling-controls {
  display: none;
  align-items: center;
  gap: 5px;
  flex-wrap: wrap; /* Permite que os elementos quebrem para a próxima linha se necessário */
  max-width: calc(100% - 20px); /* Deixa um pequeno espaço nas bordas */
}

.text-styling-controls select,
.text-styling-controls input {
  min-width: 0; /* Permite que os inputs encolham se necessário */
  flex-shrink: 1; /* Permite que os elementos diminuam proporcionalmente */
}

#font-select {
  max-width: 150px; /* Limita a largura máxima do select de fontes */
}


  select.dimension-input {
    padding: 3px;
    border: 1px solid #34495e;
    border-radius: 3px;
    background-color: #34495e;
    color: #ecf0f1;
  }

  input.dimension-input[type="color"] {
    padding: 3px;
    border: 1px solid #34495e;
    border-radius: 3px;
    background-color: #34495e;
    color: #ecf0f1;
  }

  /* New Styles for Guide Interval Options */
  .guide-interval {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 5px 10px;
  }

  .guide-interval label {
    flex: 1;
    font-size: 14px;
  }

  .guide-interval input {
    flex: 1;
    padding: 3px;
    border: 1px solid #34495e;
    border-radius: 3px;
    background-color: #34495e;
    color: #ecf0f1;
  }

  .guide-interval input:focus {
    outline: none;
    background-color: #3d566e;
  }

  #swap-dimensions {
    background-color: #5b738a;
    padding: 5px 10px;
    cursor: pointer;
    border-radius: 4px;
  }

  #swap-dimensions:hover {
    background-color: #1e2d3c;
  }

  .text-styling-controls span {
    white-space: nowrap;
    margin-left: 10px;
  }

  .text-styling-controls #font-select {
    width: 200px;
  }

  #customAlertModal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }

  .alert-content {
    background: #0f3460;
    padding: 20px;
    border-radius: 8px;
    min-width: 300px;
    border: 2px solid #4a90e2;
  }

  #customAlertMessage {
    color: white;
    text-align: center;
  }

  .tool-button {
    background-color: #0f3460;
    color: #fff;
    border: 2px solid #4a90e2;
    padding: 8px 8px;
    border-radius: 4px;
    width: 100%;
    cursor: pointer;
    font-size: 9px;
    font-weight: 700;
    height: 50px;
    margin: 5px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 10px;
  }

  .tool-button i {
    font-size: 12px;
  }

  .tool-button.selected {
    background-color: #4a90e2;
  }

  .dropdown-menu .dropdown-menu {
    left: 100%;
    top: 0;
    margin-left: 1px;
  }

  .dropdown-menu .dropdown-toggle::after {
    content: " ▶";
    font-size: 0.6em;
  }

  .hidden-canvas {
    display: none;
    position: absolute;
    left: -9999px;
  }

  .imagem-dropdown-menu {
    width: 200px;
  }

  .ajustes-dropdown-menu {
    width: 300px;
  }

  .guias-dropdown-menu {
    width: 300px;
  }

  .guide-input {
    width: 30px;
    padding: 3px;
    border: 1px solid #34495e;
    border-radius: 3px;
    background-color: #34495e;
    color: #ecf0f1;
  }

  .guide-option, .guide-interval {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 5px 10px;
  }

  .guide-option button, .guide-interval label {
    flex: 1;
    font-size: 14px;
  }

  .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    justify-content: center;
    align-items: center;
    z-index: 10000;
  }

  .modal-content {
    width: 800px;
    height: 600px;
    background-color: #2c3e50;
    border-radius: 8px;
    display: flex;
    overflow: hidden;
  }

  .modal-buttons {
    display: flex;
    justify-content: space-between;
    margin-top: auto;
    padding: 10px;
  }

  .image-container {
    width: 600px;
    height: 600px;
    background-color: #1e2d3c;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #previewCanvas {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
  }

  .controls-container {
    width: 200px;
    height: 600px;
    padding: 20px;
    background-color: #34495e;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }

  .control-group label {
    color: #ecf0f1;
    font-size: 14px;
  }

  .control-group input[type="number"] {
    width: 100%;
    padding: 5px;
    border: 1px solid #2c3e50;
    border-radius: 4px;
    background-color: #2c3e50;
    color: #ecf0f1;
  }

  .control-group input[type="range"] {
    width: 100%;
  }

  .buttons {
    display: flex;
    gap: 10px;
    margin-top: auto;
  }

  .buttons button {
    flex: 1;
    padding: 10px;
    border: none;
    border-radius: 4px;
    background-color: #3498db;
    color: #ecf0f1;
    cursor: pointer;
  }

  .buttons button:hover {
    background-color: #2980b9;
  }

  .dropdown-menu .dropdown-menu {
    left: 100%;
    top: 0;
    margin-left: 1px;
  }

  .dropdown-menu .dropdown-toggle::after {
    content: " ▶";
    font-size: 0.6em;
  }

  .dropdown-menu .dpi-option {
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .dropdown-menu .dpi-option label {
    font-size: 14px;
    color: #ecf0f1;
  }

  .dropdown-menu .dpi-option input {
    width: 60px;
    padding: 5px;
    border: 1px solid #34495e;
    border-radius: 3px;
    background-color: #34495e;
    color: #ecf0f1;
  }

  .dropdown-menu .dpi-option input:focus {
    outline: none;
    background-color: #3d566e;
  }

  .dropdown-menu .export-option {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
  }

  .dropdown-menu .export-option button {
    flex: 1;
    padding: 8px 12px;
    background-color: #34495e;
    border: none;
    color: #ecf0f1;
    cursor: pointer;
    border-radius: 3px;
    text-align: left;
    font-size: 14px;
  }

  .dropdown-menu .export-option button:hover {
    background-color: #3d566e;
  }

  .dropdown-menu .export-submenu {
    width: 300px;
    padding: 10px;
  }

  .dropdown-menu .dropdown .dropdown-menu {
    display: none;
    position: absolute;
    left: 100%;
    top: 0;
    margin-left: 1px;
    background-color: #34495e;
    border-radius: 3px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    z-index: 1000;
  }

  .dropdown-menu .dropdown:hover .dropdown-menu {
    display: block;
  }

.general-controls {
  display: none;
  align-items: center;
  gap: 5px;
}

  .general-controls label {
    margin-right: 5px;
  }

  .general-controls label[for="opacity-input"] {
    color: #ffffff;
  }

  .general-controls input {
    width: 50px;
  }

  .general-controls button {
    margin-left: 5px;
    padding: 5px 10px;
    border: none;
    border-radius: 4px;
    background-color: #007bff;
    color: white;
    cursor: pointer;
  }

  .general-controls button#export-png-selected {
    background-color: #2ecc71;
    color: #ffffff;
    padding: 7px 10px;
    border-radius: 5px;
    cursor: pointer;
  }

  .general-controls button#export-png-selected:hover {
    background-color: #27ae60;
  }

  .general-controls button:hover {
    background-color: #0056b3;
  }

  @media print {
    @page {
      margin: 0;
    }
    body {
      margin: 0;
      padding: 0;
    }
    #print-container img {
      width: 100vw;
      height: 100vh;
      object-fit: contain;
    }
  }

  .print-container {
    background-color: #151f28;
    padding: 20px;
  }

  @media print {
    .print-container {
      background-color: #151f28;
    }
  }

  .numerSemSeta::-webkit-outer-spin-button,
  .numerSemSeta::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .numerSemSeta[type=number] {
    -moz-appearance: textfield;
  }

  .version-number {
    margin-left: auto;
    color: yellow;
    font-size: 12px;
    padding: 5px 10px;
  }

.configferramentas {
  position: relative;
  height: 40px;
  background-color: #2c3e50;
  display: flex;
  align-items: center;
  padding: 0 10px;
  z-index: 100;
  border-top: 1px solid #34495e;
  margin-left: 0px;
  padding-left: 65px;
}

  #canvas {
    margin-bottom: 40px;
  }

  .configferramentas button {
    background: none;
    border: none;
    color: #ecf0f1;
    padding: 5px 10px;
    margin: 0 5px;
    cursor: pointer;
    border-radius: 3px;
  }

  .configferramentas button:hover {
    background-color: #34495e;
  }

  .configferramentas input {
    background-color: #34495e;
    border: 1px solid #455d7a;
    color: #ecf0f1;
    padding: 3px 6px;
    border-radius: 3px;
    margin: 0 5px;
  }

  #cloudphoto-image-details-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.4);
    justify-content: center;
    align-items: center;
  }

  .cloudphoto-modal-content {
    background-color: #fefefe;
    padding: 20px;
    border-radius: 10px;
    width: 400px;
    max-height: 80%;
    overflow-y: auto;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  }

  .cloudphoto-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #e0e0e0;
    padding-bottom: 10px;
    margin-bottom: 15px;
  }

  .cloudphoto-modal-close {
    color: #aaa;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
  }

  .cloudphoto-modal-close:hover {
    color: #000;
  }

  #cloudphoto-image-details-content {
    word-break: break-all;
    white-space: pre-wrap;
  }

  #bottom-buttons {
    display: none;
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
  }

  .hidden-canvas {
    display: none;
    position: absolute;
    left: -9999px;
  }
#export-svg-selected {
    background-color: #2ecc71;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 700;
    height: 30px;
}

#export-svg-selected:hover {
    background-color: #27ae60;
}


</style>
</head>
<body>
  <div class="top-menu">
    <div class="menu-buttons">
      <div class="menu-button dropdown">
        <button class="dropdown-toggle">Arquivo</button>
        <div class="dropdown-menu">
          <button id="openImagePDFBtn">Abrir Imagem | PDF </button>
          <button id="openDocumentBtn">Abrir Documento</button>
          <button id="separar">▬▬▬▬▬▬▬▬▬▬▬▬</button>
          <button id="saveDocumentBtn">Salvar Documento</button>
          <button id="separar">▬▬▬▬▬▬▬▬▬▬▬▬</button>
          <div class="dropdown">
            <button class="dropdown-toggle">⇱ Exportar</button>
            <div class="dropdown-menu export-submenu">
              <div class="export-option">
                <button id="export-png">Exportar como PNG</button>
                <div class="dpi-option">
                  <label for="dpi-input">DPI:</label>
                  <input type="number" id="dpi-input" value="300" min="72" max="1200">
                </div>
              </div>
              <div class="export-option">
                <button id="export-JPG">Exportar como JPG</button>
                <div class="dpi-option">
                  <label for="dpijpg-input">DPI:</label>
                  <input type="number" id="dpijpg-input" value="300" min="72" max="1200">
                </div>
              </div>
              <div class="export-option">
                <button id="export-PDF">Exportar como PDF</button>
                <div class="dpi-option">
                  <label for="dpipdf-input">DPI:</label>
                  <input type="number" id="dpipdf-input" value="300" min="72" max="1200">
                </div>
              </div>
            </div>
          </div>
          <div class="dropdown">
            <button class="dropdown-toggle">⇲ Importar</button>
            <div class="dropdown-menu export-submenu">
              <div class="export-option">
                <button id="import-svg">Importar SVG em Camadas</button>
              </div>
            </div>
          </div>
          <button id="separar">▬▬▬▬▬▬▬▬▬▬▬▬</button>
          <button id="print-button">⎙ Imprimir</button>
        </div>
      </div>
      <div class="menu-button dropdown">
        <button class="dropdown-toggle">Editar</button>
        <div class="dropdown-menu">
          <button id="duplicate-selected">Duplicar Objeto Selecionado</button>
          <button id="delete-selected">Excluir Objeto Selecionado</button>
          <button id="select-all">Selecionar Tudo</button>
          <button id="remove-selection">Remover Seleção</button>
          <button id="paste">Colar</button>
          <div class="guide-option">
            <button id="organize-objects">Organizar:</button>
            <input type="number" id="spacing-input" placeholder="cm" min="0" step="0.1" value="0.2">
          </div>
        </div>
      </div>

      <div class="menu-button dropdown">
        <button class="dropdown-toggle">Imagem</button>
        <div class="dropdown-menu imagem-dropdown-menu">
          <button class="dropdown-toggle">Ajustes </button>
          <div class="dropdown-menu ajustes-dropdown-menu">
            <button id="filtroscorBtn">Brilho | Contraste | Saturação | Matiz 2 </button>
            <button id="Btn-Nitidez">Adicionar Nitidez</button>
            <button id="Btn-InverterCor">Inverter Cor</button>
            <button id="Btn-PretoBranco">Preto e Branco</button>
          </div>
          <button id="separar">▬▬▬▬▬▬▬▬▬▬▬▬</button>
          <button id="BtnContrasteAutm">✦ Contraste Automático</button>
          <button id="BtnCorAutm">✦ Cor Automática</button>
          <button id="BtnTomAutm">✦Tom Automático</button>
          <button id="separar">▬▬▬▬▬▬▬▬▬▬▬▬</button>
          <button id="BtnDados">Dados Bruto</button>
        </div>
      </div>

      <div class="menu-button dropdown">
        <button class="dropdown-toggle">Guias</button>
        <div class="dropdown-menu guias-dropdown-menu">
          <button id="add-guides">Adicionar Guias Padrão</button>
          <div class="guide-option">
            <button id="add-vertical-guide">Guia Vertical</button>
            <input type="number" id="vertical-guide-cm" class="guide-input" placeholder="cm" min="0">
          </div>
          <div class="guide-option">
            <button id="add-horizontal-guide">Guia Horizontal</button>
            <input type="number" id="horizontal-guide-cm" class="guide-input" placeholder="cm" min="0">
          </div>
          <div class="guide-interval">
            <label for="horizontal-interval">Horizontal a cada:</label>
            <input type="number" id="horizontal-interval" class="guide-input" placeholder="cm" min="0">
          </div>
          <div class="guide-interval">
            <label for="vertical-interval">Vertical a cada:</label>
            <input type="number" id="vertical-interval" class="guide-input" placeholder="cm" min="0">
          </div>
          <button id="delete-all-guides">Apagar Todas as Guias</button>
        </div>
      </div>

      <div class="menu-button dropdown">
        <button class="dropdown-toggle">Texto</button>
        <div class="dropdown-menu">
          <button id="split-text">Dividir Texto em 2</button>
        </div>
      </div>

      <div class="menu-button dropdown">
        <button class="dropdown-toggle">Formas</button>
        <div class="dropdown-menu">
          <button class="dropdown-toggle">Inserir </button>
          <div class="dropdown-menu">
            <button id="insert-square">Quadrado</button>
            <button id="insert-circle">Circulo</button>
            <button id="insert-triangle">Triangulo</button>
            <button id="insert-line">Linha</button>
          </div>
        </div>
      </div>

      <div class="menu-button dropdown">
        <button class="dropdown-toggle">Extra</button>
        <div class="dropdown-menu">
          <button id="MesclarBtn">Mesclagem de Números</button>
        </div>
      </div>

    </div>
    <div class="dimension-controls">
      <button id="separar" class="menu-button">Tamanho:</button>
      <span>&#x2194;</span>
      <input type="number" id="width-input" class="dimension-input" step="0.1" placeholder="L (cm)">
      <button id="swap-dimensions" class="menu-button">&#x21c5;</button>
      <span>&#x2195;</span>
      <input type="number" id="height-input" class="dimension-input" step="0.1" placeholder="A (cm)">
      <button id="lock-ratio" class="menu-button">&#x1f513;</button>
      <div class="separar">┇</div>
    </div>

    <div class="version-number">1.5</div>
  </div>

  <div class="configferramentas">
    <div class="text-styling-controls">
      <select id="font-select" class="dimension-input">
        <option value="Arial" style="font-family: Arial;">Arial</option>
        <option value="Amarillo" style="font-family: Amarillo;">Amarillo</option>
        <option value="Catalish Huntera" style="font-family: 'Catalish Huntera';">Catalish Huntera</option>
        <option value="Cream Cake" style="font-family: 'Cream Cake';">Cream Cake</option>
        <option value="Daily" style="font-family: Daily;">Daily</option>
        <option value="GROBOLD" style="font-family: GROBOLD;">GROBOLD</option>
        <option value="Lobster 1.4" style="font-family: 'Lobster 1.4';">Lobster 1.4</option>
        <option value="Love" style="font-family: Love;">Love</option>
        <option value="josephsophia" style="font-family: josephsophia;">josephsophia</option>
        <option value="Arial Black" style="font-family: 'Arial Black';">Arial Black</option>
        <option value="Brush Script MT" style="font-family: 'Brush Script MT';">Brush Script MT</option>
        <option value="Bookman Old Style" style="font-family: 'Bookman Old Style';">Bookman Old Style</option>
        <option value="Comic Sans MS" style="font-family: 'Comic Sans MS';">Comic Sans MS</option>
        <option value="Courier" style="font-family: Courier;">Courier</option>
        <option value="Dancing Script" style="font-family: 'Dancing Script';">Dancing Script</option>
        <option value="Impact" style="font-family: Impact;">Impact</option>
        <option value="Lucida Handwriting" style="font-family: 'Lucida Handwriting';">Lucida Handwriting</option>
        <option value="Lucida Sans Unicode" style="font-family: 'Lucida Sans Unicode';">Lucida Sans Unicode</option>
        <option value="Papyrus" style="font-family: Papyrus;">Papyrus</option>
        <option value="Segoe Print" style="font-family: 'Segoe Print';">Segoe Print</option>
        <option value="Segoe Script" style="font-family: 'Segoe Script';">Segoe Script</option>
        <option value="Times New Roman" style="font-family: 'Times New Roman';">Times New Roman</option>
        <option value="Trebuchet MS" style="font-family: 'Trebuchet MS';">Trebuchet MS</option>
        <option value="Verdana" style="font-family: Verdana;">Verdana</option>
        <option value="Monotype Corsiva" style="font-family: 'Monotype Corsiva';">Monotype Corsiva</option>
        <option value="Mistral" style="font-family: Mistral;">Mistral</option>
        <option value="Freestyle Script" style="font-family: 'Freestyle Script';">Freestyle Script</option>
        <option value="Bradley Hand ITC" style="font-family: 'Bradley Hand ITC';">Bradley Hand ITC</option>
        <option value="Edwardian Script ITC" style="font-family: 'Edwardian Script ITC';">Edwardian Script ITC</option>
        <option value="Vivaldi" style="font-family: Vivaldi;">Vivaldi</option>
        <option value="Rage Italic" style="font-family: 'Rage Italic';">Rage Italic</option>
      </select>
      <input type="color" id="text-color-picker" class="dimension-input">
      <input type="number" id="font-size-input" class="dimension-input numerSemSeta" min="8" max="72" value="20">
      <span style="color: #ecf0f1; font-size: 14px;">Contorno:</span>
      <input type="number" id="stroke-width-input" class="dimension-input" min="0" value="0">
      <input type="color" id="stroke-color-picker" class="dimension-input" value="#000000">
    </div>
    <div class="general-controls" style="display: none;">
      <label for="opacity-input">Opacidade:</label>
      <input type="number" id="opacity-input" class="dimension-input" min="1" max="100" step="1">
      <button id="export-png-selected">PNG</button>
	  <button id="export-svg-selected">SVG</button>
    </div>
  </div>

  <div class="main-container">
    <div class="sidebar">
      <ul>
        <li>
          <button id="insert-image" title="Adicione uma imagem">
            <span style="font-size: 24px;">📷</span> Imagem
          </button>
          <input type="file" id="image-upload" accept="image/*" multiple style="display: none;">
        </li>
        <li>
          <button id="insert-text" title="Adiciona um texto para digitar e editar">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M4 4H20V20H4V4Z" stroke="currentColor" stroke-width="2" fill="none"/>
              <text x="12" y="16" text-anchor="middle" fill="currentColor" font-size="12">T</text>
            </svg>
            Texto
          </button>
        </li>
        <li>
          <button id="selectBtn" title="Seleciona e cria uma cópia de partes da imagem">
            <span style="font-size: 24px; color: #ADD8E6;">⿻</span> Seleção
          </button>
        </li>
        <li>
          <button id="crop-button" title="Recortar Imagens">
            <span style="font-size: 24px;">✂</span> Recortar
          </button>
        </li>
        <li>
          <button id="eraser-button" title="Apagar com uma esponja em imagens">
            <span style="font-size: 24px;">🧽</span> Borracha
          </button>
        </li>
        <li>
          <button id="paint-button" title="Pincel de pintura em imagens">
            <span style="font-size: 24px;">🖌️</span> Pincel
          </button>
        </li>
        <li>
          <button id="btnBalde" title="Pintar Regiões de uma imagem">
            <span style="font-size: 24px;">🪣️</span> Balde
          </button>
        </li>
        <li>
          <button id="removeCorCliqueBtn" title="Remover Cor igual ou Total a cor clicada">
            <span style="font-size: 24px;">✨</span> Remover Cor
          </button>
        </li>
        <li>
          <button id="extractRegionsBtn" title="Extrair partes da imagem separadas pela transparência">
            <span style="font-size: 24px;">⑆</span> Extrair
          </button>
        </li>
        <li>
          <button id="vectorizePBBtn" title="Vetorizar Imagem selecionada em Preto e Branco">
            <span style="font-size: 24px;">✑</span> Vetorizar
          </button>
        </li>
      </ul>
    </div>
    <canvas id="canvas"></canvas>
    <div class="layers-panel">
      <div class="layers-title">Camadas</div>
      <ul class="layers-list"></ul>
    </div>
  </div>

  <div id="customAlertModal" style="display: none;">
    <div class="alert-content">
      <div id="customAlertMessage"></div>
    </div>
  </div>

  <div id="cloudphoto-image-details-modal">
    <div class="cloudphoto-modal-content">
      <div class="cloudphoto-modal-header">
        <h3>Dados da Imagem</h3>
        <span class="cloudphoto-modal-close">&times;</span>
      </div>
      <pre id="cloudphoto-image-details-content"></pre>
    </div>
  </div>

  <div id="bottom-buttons" style="display: none; position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); z-index: 1000;">
    <button id="save-button">Salvar</button>
    <button id="finish-button">Finalizar</button>
  </div>

  <canvas id="hiddenCanvas" class="hidden-canvas"></canvas>

  <script src="https://nkmplay.github.io/cgf/ferramentas/modalselect.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // ---------- Configurações Iniciais -------------------------------------------
      const sidebarWidth = 60;
      const layersPanelWidth = 200;
      const topMenuHeight = document.querySelector('.top-menu').offsetHeight;
      const ROTATION_SNAP_ANGLE = 15;
      const canvasElement = document.getElementById('canvas');
      const canvas = new fabric.Canvas('canvas', {
        width: window.innerWidth - sidebarWidth - layersPanelWidth,
        height: window.innerHeight - topMenuHeight,
        selection: true,
        preserveObjectStacking: true,
        rotationCursor: 'crosshair',
        snapAngle: ROTATION_SNAP_ANGLE * (Math.PI / 180)
      });

      const cmToPx = 37.795275591;
      const a4Width = 21 * cmToPx;
      const a4Height = 29.7 * cmToPx;
      const initialScale = 0.7;

      let objectIdCounter = 0;
      let imageCounter = 1;
      let clipboardData = null;
	  
	  let isOrganizing = false;
	  
	  
      // ---------- Função para Adicionar Objetos com ID Único -------------------------------------------
      function addObject(obj) {
        obj.id = objectIdCounter++;
        canvas.add(obj);
      }

      // ---------- Criação do Objeto CloudFolha -------------------------------------------
      const cloudFolha = new fabric.Rect({
        width: a4Width,
        height: a4Height,
        left: (canvas.getWidth() / 2) - (a4Width / 2) - 250,
        top: (canvas.getHeight() / 2) - (a4Height / 2) + 100,
        fill: 'white',
        stroke: '#ccc',
        strokeWidth: 1,
        selectable: false,
        name: 'CloudFolha'
      });

      cloudFolha.set({
        hoverCursor: 'default'
      });

      addObject(cloudFolha);
      canvas.sendToBack(cloudFolha);

      canvas.setZoom(initialScale);
      canvas.absolutePan({
        x: -((canvas.getWidth() - a4Width * initialScale) / 2),
        y: -((canvas.getHeight() - a4Height * initialScale) / 2)
      });
	  
	  // ---------- evento da ferramenta de seleção -----------------------------------
document.getElementById('selectBtn').addEventListener('click', function () {
    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type === 'image') {
        initSelectModal(canvas);
    } else {
        showCustomAlert('Selecione uma imagem antes de usar a ferramenta de seleção.');
    }
});	  
	  
	  
      // ---------- Eventos de Zoom e Panning -------------------------------------------
      canvas.on('mouse:wheel', opt => {
		if (isOrganizing) {
			opt.e.preventDefault();
			opt.e.stopPropagation();
			return;
		}

		const delta = opt.e.deltaY;
		let zoom = canvas.getZoom();
		zoom *= 0.999 ** delta;
		zoom = Math.min(Math.max(0.1, zoom), 4);
		const point = new fabric.Point(opt.e.offsetX, opt.e.offsetY);
		canvas.zoomToPoint(point, zoom);
		opt.e.preventDefault();
		opt.e.stopPropagation();
	});

      canvas.on('mouse:down', opt => {
        const evt = opt.e;
        if (evt.altKey === true) {
          canvas.isDragging = true;
          canvas.selection = false;
          canvas.lastPosX = evt.clientX;
          canvas.lastPosY = evt.clientY;
        }
      });

      canvas.on('mouse:move', opt => {
        if (canvas.isDragging) {
          const e = opt.e;
          const vpt = canvas.viewportTransform;
          vpt[4] += e.clientX - canvas.lastPosX;
          vpt[5] += e.clientY - canvas.lastPosY;
          canvas.requestRenderAll();
          canvas.lastPosX = e.clientX;
          canvas.lastPosY = e.clientY;
        }
      });

      canvas.on('mouse:up', () => {
        canvas.setViewportTransform(canvas.viewportTransform);
        canvas.isDragging = false;
        canvas.selection = true;
      });

      // ---------- Eventos de Rotação e Escala -------------------------------------------
      canvas.on('object:rotating', opt => {
        const target = opt.target;
        target.set({
          angle: Math.round(target.angle / ROTATION_SNAP_ANGLE) * ROTATION_SNAP_ANGLE
        });
      });

      canvas.on('object:modified', opt => {
        updateDimensionInputs();
      });

      canvas.on('object:scaling', opt => {
        const obj = opt.target;
        if (obj.type === 'i-text') {
          const fontSizeInput = document.getElementById('font-size-input');
          const newFontSize = Math.round(obj.fontSize * obj.scaleX);
          fontSizeInput.value = newFontSize;
          obj.set({
            fontSize: newFontSize,
            scaleX: 1,
            scaleY: 1
          });
          const pxToCm = 1 / cmToPx;
          const widthInput = document.getElementById('width-input');
          const heightInput = document.getElementById('height-input');
          widthInput.value = (obj.width * pxToCm).toFixed(1);
          heightInput.value = (obj.height * pxToCm).toFixed(1);
        }
        const pxToCm = 1 / cmToPx;
        const widthInput = document.getElementById('width-input');
        const heightInput = document.getElementById('height-input');
        widthInput.value = (obj.width * obj.scaleX * pxToCm).toFixed(1);
        heightInput.value = (obj.height * obj.scaleY * pxToCm).toFixed(1);
      });

      // ---------- Eventos de Seleção -------------------------------------------
      canvas.on('selection:created', () => {
        updateDimensionInputs();
        updateLayersList();
        updateTextStylingControls();
      });

      canvas.on('selection:updated', () => {
        updateDimensionInputs();
        updateLayersList();
        updateTextStylingControls();
      });

      canvas.on('selection:cleared', () => {
        updateDimensionInputs();
        updateLayersList();
        const textStylingControls = document.querySelector('.text-styling-controls');
        textStylingControls.style.display = 'none';
      });

      // ---------- Inserção de Imagens -------------------------------------------
      document.getElementById('insert-image').addEventListener('click', () => {
        document.getElementById('image-upload').click();
      });

      document.getElementById('image-upload').addEventListener('change', e => {
        const files = e.target.files;
        for (let file of files) {
          const reader = new FileReader();
          reader.onload = f => {
            fabric.Image.fromURL(f.target.result, img => {
              img.set({
                left: cloudFolha.left + cloudFolha.width / 2,
                top: cloudFolha.top + cloudFolha.height / 2,
                originX: 'center',
                originY: 'center'
              });
              if (file.name) {
                img.fileName = file.name;
              } else {
                img.fileName = `Imagem - imagem${imageCounter++}`;
              }
              addObject(img);
              canvas.setActiveObject(img);
              updateLayersList();
            });
          };
          reader.readAsDataURL(file);
        }
      });

      // ---------- Atualização dos Inputs de Dimensão -------------------------------------------
      function updateDimensionInputs() {
        const pxToCm = 1 / cmToPx;
        const widthInput = document.getElementById('width-input');
        const heightInput = document.getElementById('height-input');

        const activeObjects = canvas.getActiveObjects();
        if (activeObjects.length === 0) {
          widthInput.value = (cloudFolha.width * pxToCm).toFixed(1);
          heightInput.value = (cloudFolha.height * pxToCm).toFixed(1);
          return;
        }

        if (activeObjects.length === 1) {
          const activeObj = activeObjects[0];
          let width = activeObj.width * activeObj.scaleX;
          let height = activeObj.height * activeObj.scaleY;

          if (activeObj.type === 'i-text') {
            const fontSizeInput = document.getElementById('font-size-input');
            widthInput.value = (activeObj.width * pxToCm).toFixed(1);
            heightInput.value = (activeObj.height * pxToCm).toFixed(1);
            fontSizeInput.value = Math.round(activeObj.fontSize * activeObj.scaleX) || 20;
          } else {
            widthInput.value = (width * pxToCm).toFixed(1);
            heightInput.value = (height * pxToCm).toFixed(1);
          }
        } else {
          widthInput.value = '';
          heightInput.value = '';
        }
      }

      // ---------- Eventos de Alteração de Dimensão -------------------------------------------
document.getElementById('width-input').addEventListener('change', e => {
    const newWidthCm = parseFloat(e.target.value);
    const activeObjects = canvas.getActiveObjects();

    if (activeObjects.length > 0) {
        activeObjects.forEach(obj => {
            if (obj.name && obj.name.startsWith('Guia')) {
                return;
            }
            const newWidth = newWidthCm * cmToPx;
            obj.scaleX = newWidth / obj.width;
            if (isRatioLocked) {
                obj.scaleY = obj.scaleX;
            }
            if (obj.type === 'i-text') {
                const fontSizeInput = document.getElementById('font-size-input');
                fontSizeInput.value = Math.round(obj.fontSize * obj.scaleX);
            }
            obj.setCoords();
        });
    } else {
        const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
        if (cloudFolha) {
            const newWidth = newWidthCm * cmToPx;
            cloudFolha.set('width', newWidth);
            cloudFolha.setCoords();
        }
    }

    canvas.requestRenderAll();
    updateLayersList();
});

document.getElementById('height-input').addEventListener('change', e => {
    const newHeightCm = parseFloat(e.target.value);
    const activeObjects = canvas.getActiveObjects();

    if (activeObjects.length > 0) {
        activeObjects.forEach(obj => {
            if (obj.name && obj.name.startsWith('Guia')) {
                return;
            }
            const newHeight = newHeightCm * cmToPx;
            obj.scaleY = newHeight / obj.height;
            if (isRatioLocked) {
                obj.scaleX = obj.scaleY;
            }
            if (obj.type === 'i-text') {
                const fontSizeInput = document.getElementById('font-size-input');
                fontSizeInput.value = Math.round(obj.fontSize * obj.scaleX);
            }
            obj.setCoords();
        });
    } else {
        const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
        if (cloudFolha) {
            const newHeight = newHeightCm * cmToPx;
            cloudFolha.set('height', newHeight);
            cloudFolha.setCoords();
        }
    }

    canvas.requestRenderAll();
    updateLayersList();
});
	  
	   // ---------- alerta personalizado -------------------------------------------
		function showCustomAlert(message) {
		  const modal = document.getElementById('customAlertModal');
		  const messageElement = document.getElementById('customAlertMessage');
		  messageElement.textContent = message;
		  modal.style.display = 'flex';
		}

		function closeCustomAlert() {
		  const modal = document.getElementById('customAlertModal');
		  modal.style.display = 'none';
		}

		document.getElementById('customAlertModal').addEventListener('click', function (e) {
		  if (e.target === this) {
			closeCustomAlert();
		  }
		});

      // ---------- Bloqueio de Proporção e troca de dimensão -------------------------------------------
      document.getElementById('swap-dimensions').addEventListener('click', () => {
  const widthInput = document.getElementById('width-input');
  const heightInput = document.getElementById('height-input');
  
  const tempWidth = widthInput.value;
  widthInput.value = heightInput.value;
  heightInput.value = tempWidth;
  
  const activeObjects = canvas.getActiveObjects();
  const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
  
  if (activeObjects.length > 0) {
    activeObjects.forEach(obj => {
      if (obj.name && obj.name.startsWith('Guia')) {
        return;
      }
      const newWidth = parseFloat(widthInput.value) * cmToPx;
      const newHeight = parseFloat(heightInput.value) * cmToPx;
      
      const currentWidth = obj.width * obj.scaleX;
      const currentHeight = obj.height * obj.scaleY;
      
      obj.set({
        width: obj.width,
        height: obj.height,
        scaleX: newWidth / obj.width,
        scaleY: newHeight / obj.height
      });
      obj.setCoords();
    });
  } else if (cloudFolha) {
    const newWidth = parseFloat(widthInput.value) * cmToPx;
    const newHeight = parseFloat(heightInput.value) * cmToPx;
    
    cloudFolha.set({
      width: newWidth,
      height: newHeight,
      scaleX: 1,
      scaleY: 1
    });
    
    cloudFolha.set({
      left: (canvas.getWidth() / 2) - (cloudFolha.width / 2) - 250,
      top: (canvas.getHeight() / 2) - (cloudFolha.height / 2) + 100
    });
    
    cloudFolha.setCoords();
  }
  
  canvas.requestRenderAll();
  updateLayersList();
});
      let isRatioLocked = false;
      document.getElementById('lock-ratio').addEventListener('click', () => {
        isRatioLocked = !isRatioLocked;
        document.getElementById('lock-ratio').textContent = isRatioLocked ? '🔒' : '🔓';
      });

      // ---------- Atualização da Lista de Camadas -------------------------------------------
      function updateLayersList() {
    const layersList = document.querySelector('.layers-list');
    layersList.innerHTML = '';
    const objects = canvas.getObjects().filter(obj => obj.name !== 'CloudFolha'); // Ignora o CloudFolha

    const orderedObjects = [...objects].reverse();

    orderedObjects.forEach((obj, index) => {
        const li = document.createElement('li');
        li.className = 'layer-item';
        li.setAttribute('data-id', obj.id);
        li.draggable = true;

        if (canvas.getActiveObjects().includes(obj)) {
            li.classList.add('selected');
        }

        if (obj.type === 'i-text') {
            const textSnippet = obj.text ? obj.text.substring(0, 10) : '';
            li.textContent = `Texto - ${textSnippet}`;
        } else if (obj.type === 'image') {
            const fileName = obj.fileName ? obj.fileName.substring(0, 10) : `Imagem - imagem${imageCounter++}`;
            li.textContent = `Imagem - ${fileName}`;
        } else if (obj.type === 'line' && obj.name && obj.name.includes('Guia')) {
            li.textContent = obj.name;
        } else {
            li.textContent = `Objeto - ${index + 1}`;
        }

        li.addEventListener('click', (e) => {
            const isShiftPressed = e.shiftKey;
            if (isShiftPressed) {
                const activeObjects = canvas.getActiveObjects();
                if (activeObjects.includes(obj)) {
                    const newActive = activeObjects.filter(o => o !== obj);
                    canvas.discardActiveObject();
                    if (newActive.length > 0) {
                        const activeSelection = new fabric.ActiveSelection(newActive, { canvas: canvas });
                        canvas.setActiveObject(activeSelection);
                    }
                } else {
                    const newActive = activeObjects.concat(obj);
                    const activeSelection = new fabric.ActiveSelection(newActive, { canvas: canvas });
                    canvas.setActiveObject(activeSelection);
                }
            } else {
                canvas.discardActiveObject();
                canvas.setActiveObject(obj);
            }
            canvas.requestRenderAll();
        });
        layersList.appendChild(li);
    });

    // Inicializa Sortable.js se ainda não estiver inicializado
    if (!layersList.sortable) {
        Sortable.create(layersList, {
            animation: 150,
            onEnd: function (evt) {
                const layers = layersList.querySelectorAll('.layer-item');
                const newOrder = Array.from(layers).map(li => parseInt(li.getAttribute('data-id')));

                newOrder.forEach((id, index) => {
                    const obj = canvas.getObjects().find(obj => obj.id === id);
                    if (obj) {
                        canvas.moveTo(obj, canvas.getObjects().length - index - 1);
                    }
                });

                canvas.requestRenderAll();
                updateLayersList();
            },
        });
        layersList.sortable = true;
    }
}

     // ---------- Inserção de Texto -------------------------------------------
document.getElementById('insert-text').addEventListener('click', () => {
  const text = new fabric.Textbox('Texto', {
    left: cloudFolha.left + cloudFolha.width / 2,
    top: cloudFolha.top + cloudFolha.height / 2,
    originX: 'left',
    originY: 'top',
    fontSize: 20,
    strokeWidth: 0,
    paintFirst: 'stroke',
    width: 200,
    editable: true,
    splitByGrapheme: false
  });
  addObject(text);
  canvas.setActiveObject(text);
  updateLayersList();
});

// ---------- Atualização do Estilo do Texto -------------------------------------------
function updateTextStylingControls() {
  const activeObjects = canvas.getActiveObjects();
  const textStylingControls = document.querySelector('.text-styling-controls');
  
  if (activeObjects.length === 1 && (activeObjects[0].type === 'textbox' || activeObjects[0].type === 'i-text')) {
    const activeObj = activeObjects[0];
    textStylingControls.style.display = 'flex';
    
    // Elementos existentes
    const fontSelect = document.getElementById('font-select');
    const textColorPicker = document.getElementById('text-color-picker');
    const fontSizeInput = document.getElementById('font-size-input');
    const strokeWidthInput = document.getElementById('stroke-width-input');
    const strokeColorPicker = document.getElementById('stroke-color-picker');

    // Atualizar valores dos controles sem substituir os elementos
    if (fontSelect) fontSelect.value = activeObj.fontFamily || 'Arial';
    if (textColorPicker) textColorPicker.value = activeObj.fill || '#000000';
    if (fontSizeInput) fontSizeInput.value = Math.round(activeObj.fontSize) || 20;
    if (strokeWidthInput) strokeWidthInput.value = activeObj.strokeWidth || 0;
    if (strokeColorPicker) strokeColorPicker.value = activeObj.stroke || '#000000';

    // Adicionar listeners apenas se ainda não existirem
    if (!fontSelect.hasListener) {
      fontSelect.addEventListener('change', updateFont);
      fontSelect.hasListener = true;
    }
    if (!textColorPicker.hasListener) {
      textColorPicker.addEventListener('input', updateTextColor);
      textColorPicker.hasListener = true;
    }
    if (!fontSizeInput.hasListener) {
      fontSizeInput.addEventListener('change', updateFontSize);
      fontSizeInput.hasListener = true;
    }
    if (!strokeWidthInput.hasListener) {
      strokeWidthInput.addEventListener('change', updateTextStroke);
      strokeWidthInput.hasListener = true;
    }
    if (!strokeColorPicker.hasListener) {
      strokeColorPicker.addEventListener('input', updateTextStroke);
      strokeColorPicker.hasListener = true;
    }
  } else {
    textStylingControls.style.display = 'none';
  }
}

// Funções separadas para cada propriedade
function updateFont() {
  const activeObjects = canvas.getActiveObjects();
  const fontSelect = document.getElementById('font-select');
  
  activeObjects.forEach(obj => {
    if (obj.type === 'textbox' || obj.type === 'i-text') {
      obj.set('fontFamily', fontSelect.value);
    }
  });
  canvas.requestRenderAll();
}

function updateTextColor() {
  const activeObjects = canvas.getActiveObjects();
  const textColorPicker = document.getElementById('text-color-picker');
  
  activeObjects.forEach(obj => {
    if (obj.type === 'textbox' || obj.type === 'i-text') {
      obj.set('fill', textColorPicker.value);
    }
  });
  canvas.requestRenderAll();
}

function updateFontSize() {
  const activeObjects = canvas.getActiveObjects();
  const fontSizeInput = document.getElementById('font-size-input');
  const newFontSize = parseInt(fontSizeInput.value);
  
  activeObjects.forEach(obj => {
    if (obj.type === 'textbox' || obj.type === 'i-text') {
      obj.set('fontSize', newFontSize);
      
      // Atualizar dimensões nos inputs
      const pxToCm = 1 / cmToPx;
      const widthInput = document.getElementById('width-input');
      const heightInput = document.getElementById('height-input');
      widthInput.value = (obj.width * pxToCm).toFixed(1);
      heightInput.value = (obj.height * pxToCm).toFixed(1);
    }
  });
  canvas.requestRenderAll();
}

function updateTextStroke() {
  const activeObjects = canvas.getActiveObjects();
  const strokeWidth = parseInt(document.getElementById('stroke-width-input').value) || 0;
  const strokeColor = document.getElementById('stroke-color-picker').value;

  activeObjects.forEach(obj => {
    if (obj.type === 'textbox' || obj.type === 'i-text') {
      obj.set({
        stroke: strokeWidth > 0 ? strokeColor : null,
        strokeWidth: strokeWidth,
        paintFirst: 'stroke'
      });
    }
  });
  canvas.requestRenderAll();
}

// Eventos de Seleção
canvas.on('selection:created', updateTextStylingControls);
canvas.on('selection:updated', updateTextStylingControls);
canvas.on('selection:cleared', () => {
  const textStylingControls = document.querySelector('.text-styling-controls');
  textStylingControls.style.display = 'none';
});

// Garantir que as mudanças no objeto sejam refletidas na interface
canvas.on('object:modified', (e) => {
  if (e.target && (e.target.type === 'textbox' || e.target.type === 'i-text')) {
    updateTextStylingControls();
  }
});

      // ---------- Eventos de Redimensionamento da Janela -------------------------------------------
      window.addEventListener('resize', () => {
        canvas.setWidth(window.innerWidth - sidebarWidth - layersPanelWidth);
        canvas.setHeight(window.innerHeight - topMenuHeight);
        canvas.requestRenderAll();
      });

     // ---------- Função de Impressão Corrigida (Contorno Ajustado) -------------------------------------------
document.getElementById('print-button').addEventListener('click', () => {
  const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
  if (!cloudFolhaObj) return;

  const originalZoom = canvas.getZoom();
  const originalViewportTransform = [...canvas.viewportTransform];
  const originalWidth = canvas.getWidth();
  const originalHeight = canvas.getHeight();

  canvas.forEachObject(obj => {
    obj.dirty = true;
    obj.setCoords(); 
  });
  canvas.requestRenderAll();

  canvas.setZoom(1);
  canvas.requestRenderAll();

  const TARGET_DPI = 300; 
  const BROWSER_DPI = 96;
  const dpiScale = TARGET_DPI / BROWSER_DPI;

  const printWidth = cloudFolhaObj.width * dpiScale;
  const printHeight = cloudFolhaObj.height * dpiScale;

  const printCanvas = new fabric.Canvas(null, {
    width: printWidth,
    height: printHeight,
    backgroundColor: 'white'
  });

  const objectsToPrint = canvas.getObjects()
    .filter(obj => obj !== cloudFolhaObj && !obj.name?.includes('Guia'))
    .map(obj => {
      const clone = fabric.util.object.clone(obj);
      const relativeLeft = obj.left - cloudFolhaObj.left;
      const relativeTop = obj.top - cloudFolhaObj.top;

      clone.set({
        left: relativeLeft * dpiScale,
        top: relativeTop * dpiScale,
        scaleX: obj.scaleX * dpiScale,
        scaleY: obj.scaleY * dpiScale,
        selectable: false
      });

      if (clone.type === 'i-text') {
        const strokeScale = dpiScale * (clone.strokeWidth > 0 ? 1.2 : 1); 
        clone.set({
          fontSize: clone.fontSize * dpiScale,
          strokeWidth: clone.strokeWidth * strokeScale, 
          scaleX: 1,
          scaleY: 1,
          paintFirst: 'stroke',
          left: clone.left,
          top: clone.top
        });
      }

      return clone;
    });

  printCanvas.add(...objectsToPrint);
  printCanvas.renderAll();

  const printContainer = document.createElement('div');
  printContainer.id = 'print-container';
  printContainer.style = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: white;
    z-index: 10000;
    display: flex;
    justify-content: center;
    align-items: center;
  `;

  const printImg = document.createElement('img');
  printImg.src = printCanvas.toDataURL({
    format: 'png',
    quality: 1.0,
    enableRetinaScaling: true,
    width: printWidth,
    height: printHeight 
  });
  printImg.style = `
    width: 100%;
    height: 100%;
    object-fit: contain;
    image-rendering: pixelated;
    margin: -1px; /* Tentativa de remover a possível margem invisível */
  `;

  printContainer.appendChild(printImg);

  document.body.appendChild(printContainer);

  window.setTimeout(() => {
    window.print();
    document.body.removeChild(printContainer);

    canvas.setDimensions({
      width: originalWidth,
      height: originalHeight
    });
    canvas.setViewportTransform(originalViewportTransform);
    canvas.setZoom(originalZoom);

    canvas.forEachObject(obj => {
      obj.dirty = true;
      obj.setCoords(); 
    });

    canvas.requestRenderAll();

    setTimeout(() => {
      canvas.calcViewportBoundaries();
      canvas.discardActiveObject();
      canvas.forEachObject(obj => {
        obj.set("dirty", true);
        obj.setCoords();
      });
      canvas.renderAll();
    }, 100);

  }, 500);
});


      // ---------- Função para Excluir Selecionados -------------------------------------------
      document.getElementById('delete-selected').addEventListener('click', () => {
        const activeObjects = canvas.getActiveObjects();
        if (activeObjects.length) {
          activeObjects.forEach(obj => {
            canvas.remove(obj);
          });
          canvas.discardActiveObject();
          canvas.requestRenderAll();
          updateLayersList();
        }
      });

      // ---------- Função para Duplicar Selecionados -------------------------------------------
document.getElementById('duplicate-selected').addEventListener('click', () => {
    const activeObjects = canvas.getActiveObjects();
    if (!activeObjects.length) return;
    
    const zoom = canvas.getZoom();
    const offset = {
        x: 20 / zoom,
        y: 20 / zoom
    };
    const clones = [];
    const vpt = canvas.viewportTransform;
    
    activeObjects.forEach(obj => {
        if (obj.name?.startsWith('Guia')) return;
        
        obj.clone((clonedObj) => {
            // Store original properties before any modifications
            const originalProps = {
                fontFamily: obj.fontFamily,
                fontSize: obj.fontSize,
                fontWeight: obj.fontWeight,
                fontStyle: obj.fontStyle,
                textAlign: obj.textAlign,
                lineHeight: obj.lineHeight,
                underline: obj.underline,
                overline: obj.overline,
                linethrough: obj.linethrough,
                textBackgroundColor: obj.textBackgroundColor,
                charSpacing: obj.charSpacing,
                fill: obj.fill,
                stroke: obj.stroke,
                strokeWidth: obj.strokeWidth
            };

            // Base position and transformation
            const objCenter = obj.getCenterPoint();
            const transformedPoint = fabric.util.transformPoint(objCenter, vpt);
            const newPosition = {
                x: transformedPoint.x + offset.x,
                y: transformedPoint.y + offset.y
            };
            const finalPosition = fabric.util.transformPoint(newPosition, fabric.util.invertTransform(vpt));
            
            // Set position and transformation properties
            clonedObj.set({
                left: finalPosition.x,
                top: finalPosition.y,
                angle: obj.angle,
                scaleX: obj.scaleX,
                scaleY: obj.scaleY,
                originX: 'center',
                originY: 'center',
                shadow: obj.shadow ? new fabric.Shadow(obj.shadow) : null,
                opacity: obj.opacity,
                flipX: obj.flipX,
                flipY: obj.flipY
            });

            // Special handling for text objects
            if (clonedObj.type === 'i-text') {
                // Apply text properties
                clonedObj.set(originalProps);
                
                // Store properties on the object
                clonedObj._originalProps = originalProps;

                // Override the setProperty method
                const originalSetProperty = clonedObj.set.bind(clonedObj);
                clonedObj.set = function(key, value) {
                    if (typeof key === 'object') {
                        // If setting multiple properties
                        originalSetProperty(key);
                        // Ensure font properties are maintained
                        originalSetProperty({
                            fontFamily: this._originalProps.fontFamily,
                            fontSize: this._originalProps.fontSize,
                            fontWeight: this._originalProps.fontWeight,
                            fontStyle: this._originalProps.fontStyle
                        });
                    } else {
                        // If setting single property
                        originalSetProperty(key, value);
                        // If changing stroke or strokeWidth, ensure font is maintained
                        if (key === 'stroke' || key === 'strokeWidth') {
                            originalSetProperty('fontFamily', this._originalProps.fontFamily);
                            originalSetProperty('fontSize', this._originalProps.fontSize);
                            originalSetProperty('fontWeight', this._originalProps.fontWeight);
                            originalSetProperty('fontStyle', this._originalProps.fontStyle);
                        }
                    }
                    return this;
                };
            }
            
            // Special handling for images
            if (clonedObj.type === 'image') {
                clonedObj.set({
                    crossOrigin: 'anonymous',
                    filters: obj.filters ? [...obj.filters] : []
                });
                clonedObj.applyFilters();
            }
            
            canvas.add(clonedObj);
            clonedObj.setCoords();
            clones.push(clonedObj);
        });
    });
    
    canvas.discardActiveObject();
    const activeSelection = new fabric.ActiveSelection(clones, {
        canvas: canvas,
        originX: 'center',
        originY: 'center'
    });
    
    canvas.setActiveObject(activeSelection);
    canvas.requestRenderAll();
    updateLayersList();
});

      // ---------- Função para Selecionar Tudo -------------------------------------------
      document.getElementById('select-all').addEventListener('click', () => {
        const objects = canvas.getObjects().filter(obj => obj !== cloudFolha);
        if (objects.length) {
          canvas.discardActiveObject();
          const activeSelection = new fabric.ActiveSelection(objects, { canvas: canvas });
          canvas.setActiveObject(activeSelection);
          canvas.requestRenderAll();
          updateLayersList();
        }
      });

      // ---------- Função para Remover Seleção -------------------------------------------
      document.getElementById('remove-selection').addEventListener('click', () => {
        canvas.discardActiveObject();
        canvas.requestRenderAll();
        updateLayersList();
      });

      
      // ---------- Atualização da Lista de Camadas após Modificações -------------------------------------------
      canvas.on('object:added', () => {
        updateLayersList();
      });

      canvas.on('object:removed', () => {
        updateLayersList();
      });

      canvas.on('object:modified', () => {
        updateLayersList();
      });

      // ---------- Inicialização -------------------------------------------
      updateDimensionInputs();
      updateLayersList();
      canvas.requestRenderAll();
	  
	  // ---------- Função para Colar -------------------------------------------
function handlePaste(e) {
  const activeObject = canvas.getActiveObject();

  if (activeObject && activeObject.type === 'textbox' && activeObject.isEditing) {
    e.preventDefault(); 

    if (e && e.clipboardData) {
      const items = e.clipboardData.items;
      for (const item of items) {
        if (item.type === 'text/plain') {
          item.getAsString(text => {
            const cursorPosition = activeObject.selectionStart;
            const currentText = activeObject.text;
            const newText =
              currentText.slice(0, cursorPosition) +
              text +
              currentText.slice(cursorPosition);
            activeObject.set('text', newText);

            activeObject.selectionStart = cursorPosition + text.length;
            activeObject.selectionEnd = cursorPosition + text.length;

            canvas.requestRenderAll();
          });
          return;
        }
      }
    }
    else {
      navigator.clipboard.read().then(clipboardItems => {
        for (const item of clipboardItems) {
          if (item.types.includes('text/plain')) {
            item.getType('text/plain').then(textBlob => {
              textBlob.text().then(text => {
                const cursorPosition = activeObject.selectionStart;
                const currentText = activeObject.text;
                const newText =
                  currentText.slice(0, cursorPosition) +
                  text +
                  currentText.slice(cursorPosition);
                activeObject.set('text', newText);

                activeObject.selectionStart = cursorPosition + text.length;
                activeObject.selectionEnd = cursorPosition + text.length;

                canvas.requestRenderAll();
              });
            });
            return;
          }
        }
         showCustomAlert("Nenhum texto encontrado na área de transferência.");
      }).catch(err => {
        console.error('Falha ao acessar a área de transferência:', err);
         showCustomAlert("Falha ao acessar a área de transferência. Certifique-se de que o site está em HTTPS.");
      });
    }
  }
  else {
    if (e && e.clipboardData) {
      const items = e.clipboardData.items;
      for (const item of items) {
        if (item.type.indexOf('image') !== -1) {
          const blob = item.getAsFile();
          const url = URL.createObjectURL(blob);
          fabric.Image.fromURL(url, img => {
            img.set({
              left: cloudFolha.left + cloudFolha.width / 2,
              top: cloudFolha.top + cloudFolha.height / 2,
              originX: 'center',
              originY: 'center'
            });
            img.fileName = `Imagem - imagem${imageCounter++}`;
            addObject(img);
            canvas.setActiveObject(img);
            updateLayersList();
          });
          return;
        } else if (item.type === 'text/plain') {
          item.getAsString(text => {
            const textbox = new fabric.Textbox(text, {
              left: cloudFolha.left + cloudFolha.width / 2,
              top: cloudFolha.top + cloudFolha.height / 2,
              originX: 'left',
              originY: 'top',
              fontSize: 20,
              width: 200,
              editable: true,
              splitByGrapheme: false
            });
            addObject(textbox);
            canvas.setActiveObject(textbox);
            updateLayersList();
          });
          return;
        }
      }
       showCustomAlert("Nenhum dado válido foi colado.");
    } else {
      navigator.clipboard.read().then(clipboardItems => {
        for (const item of clipboardItems) {
          if (item.types.includes('image/png')) {
            item.getType('image/png').then(blob => {
              const url = URL.createObjectURL(blob);
              fabric.Image.fromURL(url, img => {
                img.set({
                  left: cloudFolha.left + cloudFolha.width / 2,
                  top: cloudFolha.top + cloudFolha.height / 2,
                  originX: 'center',
                  originY: 'center'
                });
                img.fileName = `Imagem - imagem${imageCounter++}`;
                addObject(img);
                canvas.setActiveObject(img);
                updateLayersList();
              });
            });
            return;
          } else if (item.types.includes('text/plain')) {
            item.getType('text/plain').then(textBlob => {
              textBlob.text().then(text => {
                const textbox = new fabric.Textbox(text, {
                  left: cloudFolha.left + cloudFolha.width / 2,
                  top: cloudFolha.top + cloudFolha.height / 2,
                  originX: 'left',
                  originY: 'top',
                  fontSize: 20,
                  width: 200,
                  editable: true,
                  splitByGrapheme: false
                });
                addObject(textbox);
                canvas.setActiveObject(textbox);
                updateLayersList();
              });
            });
            return;
          }
        }
         showCustomAlert("Nenhum dado válido encontrado na área de transferência.");
      }).catch(err => {
        console.error('Falha ao acessar a área de transferência:', err);
         showCustomAlert("Falha ao acessar a área de transferência. Certifique-se de que o site está em HTTPS.");
      });
    }
  }
}

document.addEventListener('paste', (e) => {
  e.preventDefault();
  handlePaste(e);
});

document.getElementById('paste').addEventListener('click', () => {
  handlePaste();
});
      // ---------- Função para Adicionar Guias Padrão -------------------------------------------
      document.getElementById('add-guides').addEventListener('click', () => {
        addStandardGuides();
      });

      function addStandardGuides() {
        const guideOffsetCm = 0.5;
        const guideOffsetPx = guideOffsetCm * cmToPx;

        const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
        if (!cloudFolhaObj) return;

        const left = cloudFolhaObj.left;
        const top = cloudFolhaObj.top;
        const width = cloudFolhaObj.width * cloudFolhaObj.scaleX;
        const height = cloudFolhaObj.height * cloudFolhaObj.scaleY;

        const guidePositions = {
          'Esquerda': left + guideOffsetPx,
          'Direita': left + width - guideOffsetPx,
          'Topo': top + guideOffsetPx,
          'Fundo': top + height - guideOffsetPx
        };

        const leftGuide = new fabric.Line([guidePositions.Esquerda, top, guidePositions.Esquerda, top + height], {
          stroke: 'rgba(0, 255, 255, 0.8)',
          strokeWidth: 1,
          selectable: true,
          name: 'Guia - Esquerda'
        });

        const rightGuide = new fabric.Line([guidePositions.Direita, top, guidePositions.Direita, top + height], {
          stroke: 'rgba(0, 255, 255, 0.8)',
          strokeWidth: 1,
          selectable: true,
          name: 'Guia - Direita'
        });

        const topGuide = new fabric.Line([left, guidePositions.Topo, left + width, guidePositions.Topo], {
          stroke: 'rgba(0, 255, 255, 0.8)',
          strokeWidth: 1,
          selectable: true,
          name: 'Guia - Topo'
        });

        const bottomGuide = new fabric.Line([left, guidePositions.Fundo, left + width, guidePositions.Fundo], {
          stroke: 'rgba(0, 255, 255, 0.8)',
          strokeWidth: 1,
          selectable: true,
          name: 'Guia - Fundo'
        });

        [leftGuide, rightGuide, topGuide, bottomGuide].forEach(guide => {
          guide.id = objectIdCounter++;
          canvas.add(guide);
        });

        canvas.requestRenderAll();
        updateLayersList();
      }

      // ---------- Função para Adicionar Guia Vertical -------------------------------------------
document.getElementById('add-vertical-guide').addEventListener('click', () => {
  addVerticalGuideFromInput();
});

document.getElementById('vertical-guide-cm').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    addVerticalGuideFromInput();
  }
});

function addVerticalGuideFromInput() {
  const cmValue = document.getElementById('vertical-guide-cm').value;
  if (cmValue === '') {
    const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
    if (!cloudFolhaObj) return;

    const middleX = cloudFolhaObj.left + (cloudFolhaObj.width * cloudFolhaObj.scaleX) / 2;
    const middleYTop = cloudFolhaObj.top;
    const middleYBottom = cloudFolhaObj.top + cloudFolhaObj.height * cloudFolhaObj.scaleY;

    const verticalGuide = new fabric.Line([middleX, middleYTop, middleX, middleYBottom], {
      stroke: 'rgba(0, 255, 255, 0.8)',
      strokeWidth: 1,
      selectable: true,
      name: 'Guia Vertical (Meio)'
    });

    verticalGuide.id = objectIdCounter++;
    canvas.add(verticalGuide);
    canvas.requestRenderAll();
    updateLayersList();
  } else {
    const cmValueNum = parseFloat(cmValue);
    if (isNaN(cmValueNum)) {
       showCustomAlert("Por favor, insira um valor válido em centímetros para a Guia Vertical.");
      return;
    }
    addVerticalGuide(cmValueNum);
  }
}

function addVerticalGuide(cmValue) {
  const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
  if (!cloudFolhaObj) return;

  const guideX = cloudFolhaObj.left + cmValue * cmToPx;
  const guideYTop = cloudFolhaObj.top;
  const guideYBottom = cloudFolhaObj.top + cloudFolhaObj.height * cloudFolhaObj.scaleY;

  const verticalGuide = new fabric.Line([guideX, guideYTop, guideX, guideYBottom], {
    stroke: 'rgba(0, 255, 255, 0.8)',
    strokeWidth: 1,
    selectable: true,
    name: `Guia Vertical (${cmValue}cm)`
  });

  verticalGuide.id = objectIdCounter++;
  canvas.add(verticalGuide);
  canvas.requestRenderAll();
  updateLayersList();
}

      // ---------- Função para Adicionar Guia Horizontal -------------------------------------------
 document.getElementById('add-horizontal-guide').addEventListener('click', () => {
  addHorizontalGuideFromInput();
});

document.getElementById('horizontal-guide-cm').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    addHorizontalGuideFromInput();
  }
});

function addHorizontalGuideFromInput() {
  const cmValue = document.getElementById('horizontal-guide-cm').value;
  if (cmValue === '') {
    const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
    if (!cloudFolhaObj) return;

    const middleY = cloudFolhaObj.top + (cloudFolhaObj.height * cloudFolhaObj.scaleY) / 2;
    const middleXLeft = cloudFolhaObj.left;
    const middleXRight = cloudFolhaObj.left + cloudFolhaObj.width * cloudFolhaObj.scaleX;

    const horizontalGuide = new fabric.Line([middleXLeft, middleY, middleXRight, middleY], {
      stroke: 'rgba(0, 255, 255, 0.8)',
      strokeWidth: 1,
      selectable: true,
      name: 'Guia Horizontal (Meio)'
    });

    horizontalGuide.id = objectIdCounter++;
    canvas.add(horizontalGuide);
    canvas.requestRenderAll();
    updateLayersList();
  } else {
    const cmValueNum = parseFloat(cmValue);
    if (isNaN(cmValueNum)) {
	
	showCustomAlert("Por favor, insira um valor válido em centímetros para a Guia Horizontal.");
      return;
    }
    addHorizontalGuide(cmValueNum);
  }
}

function addHorizontalGuide(cmValue) {
  const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
  if (!cloudFolhaObj) return;

  const guideY = cloudFolhaObj.top + cmValue * cmToPx;
  const guideXLeft = cloudFolhaObj.left;
  const guideXRight = cloudFolhaObj.left + cloudFolhaObj.width * cloudFolhaObj.scaleX;

  const horizontalGuide = new fabric.Line([guideXLeft, guideY, guideXRight, guideY], {
    stroke: 'rgba(0, 255, 255, 0.8)',
    strokeWidth: 1,
    selectable: true,
    name: `Guia Horizontal (${cmValue}cm)`
  });

  horizontalGuide.id = objectIdCounter++;
  canvas.add(horizontalGuide);
  canvas.requestRenderAll();
  updateLayersList();
}
      // ---------- Função para Apagar Todas as Guias -------------------------------------------
      document.getElementById('delete-all-guides').addEventListener('click', () => {
        const guides = canvas.getObjects().filter(obj => obj.name && obj.name.includes('Guia'));
        guides.forEach(guide => {
          canvas.remove(guide);
        });
        canvas.requestRenderAll();
        updateLayersList();
      });

      // ---------- Eventos para Adicionar Guias por Intervalo -------------------------------------------
      document.getElementById('horizontal-interval').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addHorizontalGuidesAtInterval();
        }
      });

      document.getElementById('vertical-interval').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addVerticalGuidesAtInterval();
        }
      });

      document.getElementById('horizontal-interval').addEventListener('blur', () => {
        addHorizontalGuidesAtInterval();
      });

      document.getElementById('vertical-interval').addEventListener('blur', () => {
        addVerticalGuidesAtInterval();
      });

      function addHorizontalGuidesAtInterval() {
        const intervalCm = parseFloat(document.getElementById('horizontal-interval').value);
        if (isNaN(intervalCm) || intervalCm <= 0) {
           showCustomAlert("Por favor, insira um valor válido e maior que zero para o intervalo horizontal.");
          return;
        }
        const intervalPx = intervalCm * cmToPx;

        const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
        if (!cloudFolhaObj) return;

        const topStart = cloudFolhaObj.top;
        const topEnd = cloudFolhaObj.top + cloudFolhaObj.height * cloudFolhaObj.scaleY;

        for (let y = topStart + intervalPx; y < topEnd; y += intervalPx) {
          const horizontalGuide = new fabric.Line([cloudFolhaObj.left, y, cloudFolhaObj.left + cloudFolhaObj.width * cloudFolhaObj.scaleX, y], {
            stroke: 'rgba(0, 255, 255, 0.8)',
            strokeWidth: 1,
            selectable: true,
            name: `Guia Horizontal (${(y - topStart)/cmToPx}cm)`
          });
          horizontalGuide.id = objectIdCounter++;
          canvas.add(horizontalGuide);
        }
        canvas.requestRenderAll();
        updateLayersList();
      }

      function addVerticalGuidesAtInterval() {
        const intervalCm = parseFloat(document.getElementById('vertical-interval').value);
        if (isNaN(intervalCm) || intervalCm <= 0) {
           showCustomAlert("Por favor, insira um valor válido e maior que zero para o intervalo vertical.");
          return;
        }
        const intervalPx = intervalCm * cmToPx;

        const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
        if (!cloudFolhaObj) return;

        const leftStart = cloudFolhaObj.left;
        const leftEnd = cloudFolhaObj.left + cloudFolhaObj.width * cloudFolhaObj.scaleX;

        for (let x = leftStart + intervalPx; x < leftEnd; x += intervalPx) {
          const verticalGuide = new fabric.Line([x, cloudFolhaObj.top, x, cloudFolhaObj.top + cloudFolhaObj.height * cloudFolhaObj.scaleY], {
            stroke: 'rgba(0, 255, 255, 0.8)',
            strokeWidth: 1,
            selectable: true,
            name: `Guia Vertical (${(x - leftStart)/cmToPx}cm)`
          });
          verticalGuide.id = objectIdCounter++;
          canvas.add(verticalGuide);
        }
        canvas.requestRenderAll();
        updateLayersList();
      }

      // ---------- Implementação de Magnetismo nas Guias -------------------------------------------
      const SNAP_DISTANCE_WEAK = 20;
      const SNAP_DISTANCE_STRONG = 10;

      canvas.on('object:moving', (opt) => {
        const obj = opt.target;
        const padding = 5; 

        const objLeftEdge = obj.left - (obj.width * obj.scaleX) / 2;
        const objRightEdge = obj.left + (obj.width * obj.scaleX) / 2;
        const objTopEdge = obj.top - (obj.height * obj.scaleY) / 2;
        const objBottomEdge = obj.top + (obj.height * obj.scaleY) / 2;

        let snapPoints = [];

        canvas.getObjects().forEach((guide) => {
          if (guide === cloudFolha) return;
          if (guide.type === 'line') {
            if (guide.x1 === guide.x2) {
              const guideX = guide.x1;
              let distLeft = Math.abs(objLeftEdge - guideX);
              if (distLeft <= SNAP_DISTANCE_WEAK) {
                snapPoints.push({ axis: 'x', snap: guideX + (obj.width * obj.scaleX) / 2, distance: distLeft });
              }
              let distRight = Math.abs(objRightEdge - guideX);
              if (distRight <= SNAP_DISTANCE_WEAK) {
                snapPoints.push({ axis: 'x', snap: guideX - (obj.width * obj.scaleX) / 2, distance: distRight });
              }
            } else if (guide.y1 === guide.y2) {
              const guideY = guide.y1;
              let distTop = Math.abs(objTopEdge - guideY);
              if (distTop <= SNAP_DISTANCE_WEAK) {
                snapPoints.push({ axis: 'y', snap: guideY + (obj.height * obj.scaleY) / 2, distance: distTop });
              }
              let distBottom = Math.abs(objBottomEdge - guideY);
              if (distBottom <= SNAP_DISTANCE_WEAK) {
                snapPoints.push({ axis: 'y', snap: guideY - (obj.height * obj.scaleY) / 2, distance: distBottom });
              }
            }
          }
        });

        let closestSnapX = null;
        let closestSnapY = null;
        let minDistX = Infinity;
        let minDistY = Infinity;

        snapPoints.forEach(point => {
          if (point.axis === 'x' && point.distance < minDistX) {
            closestSnapX = point.snap;
            minDistX = point.distance;
          }
          if (point.axis === 'y' && point.distance < minDistY) {
            closestSnapY = point.snap;
            minDistY = point.distance;
          }
        });

        if (closestSnapX !== null) {
          if (minDistX <= SNAP_DISTANCE_STRONG) {
            obj.left = closestSnapX;
          } else if (minDistX <= SNAP_DISTANCE_WEAK) {
            obj.left += (closestSnapX - obj.left) * 0.5;
          }
        }

        if (closestSnapY !== null) {
          if (minDistY <= SNAP_DISTANCE_STRONG) {
            obj.top = closestSnapY;
          } else if (minDistY <= SNAP_DISTANCE_WEAK) {
            obj.top += (closestSnapY - obj.top) * 0.5;
          }
        }
      });

      // ---------- Implementação de Atalhos de Teclado -------------------------------------------
      document.addEventListener('keydown', (e) => {
  const activeObject = canvas.getActiveObject();
  
  if (activeObject && 
      (activeObject.type === 'textbox' || activeObject.type === 'i-text') && 
      activeObject.isEditing) {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      return; 
    }
  }

  if (!activeObject?.isEditing) {
    if (e.code === 'Delete') {
      e.preventDefault();
      document.getElementById('delete-selected').click();
    }

    if (e.ctrlKey && e.code === 'KeyD') {
      e.preventDefault();
      document.getElementById('duplicate-selected').click();
    }
    
    if (e.ctrlKey && e.code === 'KeyA') {
      e.preventDefault();
      document.getElementById('select-all').click();
    }
    
    if (e.code === 'F2') {
      e.preventDefault();
      document.getElementById('add-guides').click();
    }
    
    if (e.ctrlKey && e.code === 'KeyP') {
      e.preventDefault();
      document.getElementById('print-button').click();
    }
  }
});
		
		// ------------ dividir o texto em colunas----------------------------------
function splitTextIntoTwoColumns() {
  const activeObject = canvas.getActiveObject();
  if (activeObject && (activeObject.type === 'textbox' || activeObject.type === 'i-text')) {
    const text = activeObject.text;
    const words = text.split(' ');
    const middle = Math.ceil(words.length / 2);
    const firstHalf = words.slice(0, middle).join(' ');
    const secondHalf = words.slice(middle).join(' ');
    
    // Atualiza o texto da primeira coluna
    activeObject.set('text', firstHalf);
    activeObject.setCoords();

    // Cria a segunda coluna como Textbox
    const secondColumn = new fabric.Textbox(secondHalf, {
      left: activeObject.left + activeObject.width + 20, 
      top: activeObject.top,
      fontSize: activeObject.fontSize,
      fontFamily: activeObject.fontFamily,
      fill: activeObject.fill,
      width: activeObject.width, // Mantém a mesma largura da coluna original
      originX: 'left',
      originY: 'top',
      editable: true,
      splitByGrapheme: false,
      strokeWidth: activeObject.strokeWidth || 0,
      stroke: activeObject.stroke || null,
      paintFirst: 'stroke'
    });

    canvas.add(secondColumn);
    canvas.setActiveObject(secondColumn);
    canvas.requestRenderAll();
  } else {
    showCustomAlert("Selecione um texto para dividir.");
  }
}

document.getElementById('split-text').addEventListener('click', () => {
  splitTextIntoTwoColumns();
});
		
		// ----------------------------------------- Seção Inicio Mover com Setas do teclado ---------------------------------

let arrowKeys = {
    ArrowUp: false,
    ArrowDown: false,
    ArrowLeft: false,
    ArrowRight: false
};

let moveSpeed = 0.1;
const fastSpeed = 0.5;
const maxSpeed = 1;
const speedIncrement = 0.05;

let keyPressTime = 0;
let isKeyPressed = false;

function moveSelectedObjects(dx, dy) {
    const activeObjects = canvas.getActiveObjects();
    if (activeObjects && activeObjects.length > 0) {
        activeObjects.forEach(obj => {
            if (obj.id !== 'CloudFolha') {
                obj.set({
                    left: obj.left + dx,
                    top: obj.top + dy
                });
                obj.setCoords();
            }
        });
        canvas.renderAll();
    }
}

function handleArrowKeys() {
    if (isKeyPressed) {
        keyPressTime += 0.1;
        if (keyPressTime > 5) {
            keyPressTime = 5;
        }
        if (keyPressTime > 5) {
            moveSpeed = fastSpeed;
        }
        if (moveSpeed < maxSpeed) {
            moveSpeed += speedIncrement;
        }
    }

    if (arrowKeys.ArrowUp) {
        moveSelectedObjects(0, -moveSpeed);
    }
    if (arrowKeys.ArrowDown) {
        moveSelectedObjects(0, moveSpeed);
    }
    if (arrowKeys.ArrowLeft) {
        moveSelectedObjects(-moveSpeed, 0);
    }
    if (arrowKeys.ArrowRight) {
        moveSelectedObjects(moveSpeed, 0);
    }

    requestAnimationFrame(handleArrowKeys); 
}

handleArrowKeys();

document.addEventListener('keydown', function (e) {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        if (!arrowKeys[e.key]) {
            arrowKeys[e.key] = true;
            isKeyPressed = true;  
            keyPressTime = 0;  
            e.preventDefault();  
        }
    }
});

document.addEventListener('keyup', function (e) {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        arrowKeys[e.key] = false;
        isKeyPressed = false;  
        moveSpeed = 0.1;  
        keyPressTime = 0;  
    }
});


// ----------------------------------------- Seção Mover zoom espaço do teclado --------------------------------- 

let isSpacePressed = false;

let isDraggingCanvas = false;
let lastPosX = 0;
let lastPosY = 0;

function startDraggingCanvas(e) {
    if (isSpacePressed && !isDraggingCanvas) {
        isDraggingCanvas = true;
        lastPosX = e.clientX;
        lastPosY = e.clientY;
        canvas.defaultCursor = 'grabbing';
        canvas.renderAll();
    }
}

function dragCanvas(e) {
    if (isDraggingCanvas) {
        const deltaX = e.clientX - lastPosX;
        const deltaY = e.clientY - lastPosY;

        const vpt = canvas.viewportTransform;
        vpt[4] += deltaX;
        vpt[5] += deltaY;

        canvas.requestRenderAll();

        lastPosX = e.clientX;
        lastPosY = e.clientY;
    }
}

function stopDraggingCanvas() {
    if (isDraggingCanvas) {
        isDraggingCanvas = false;
        canvas.defaultCursor = isSpacePressed ? 'grab' : 'default';
        canvas.renderAll();
    }
}

document.addEventListener('keydown', function (e) {
    if (e.code === 'Space' && !isSpacePressed) {
        isSpacePressed = true;

        const activeObject = canvas.getActiveObject();
        if (!activeObject || (activeObject.type !== 'i-text' && activeObject.type !== 'text')) {
            canvas.defaultCursor = 'grab';
            canvas.renderAll();
        }
    }
});

document.addEventListener('keyup', function (e) {
    if (e.code === 'Space' && isSpacePressed) {
        isSpacePressed = false;
        canvas.defaultCursor = 'default';
        canvas.renderAll();
    }
});

canvas.on('mouse:down', function (e) {
    if (isSpacePressed) {
        startDraggingCanvas(e.e);
    }
});

canvas.on('mouse:move', function (e) {
    if (isDraggingCanvas) {
        dragCanvas(e.e);
    }
});

canvas.on('mouse:up', function () {
    stopDraggingCanvas();
});

canvas.on('text:editing:entered', function () {
    isSpacePressed = false;
    canvas.defaultCursor = 'text';
    canvas.renderAll();
});

canvas.on('text:editing:exited', function () {
    if (isSpacePressed) {
        canvas.defaultCursor = 'grab';
    } else {
        canvas.defaultCursor = 'default';
    }
    canvas.renderAll();
});

			// ------------- organizar objetos -------------------------
function cmToPixels(cm) {
  return cm * 37.795275591; 
}

async function organizeObjects() {
    isOrganizing = true; 

    const spacingCm = parseFloat(document.getElementById('spacing-input').value) || 0.2;
    const targetZoom = 1.0; 
    const zoom = canvas.getZoom();
    const spacingPx = cmToPixels(spacingCm) / targetZoom; 
    const marginPx = spacingPx;

    const extraTopCm = 0.0;
    const extraLeftCm = 0.0;

    const extraTopPx = cmToPixels(extraTopCm);
    const extraLeftPx = cmToPixels(extraLeftCm);

    const selectedObjects = canvas.getActiveObjects();
    const objectIds = selectedObjects.map(obj => obj.id);
    
    canvas.discardActiveObject();
    canvas.requestRenderAll();

    const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
    if (!cloudFolhaObj) return;

    canvas.setZoom(targetZoom);
    canvas.absolutePan({
        x: (canvas.getWidth() / 2) - (cloudFolhaObj.left + (cloudFolhaObj.width * cloudFolhaObj.scaleX) / 2 + 500),
        y: (canvas.getHeight() / 2) - (cloudFolhaObj.top + (cloudFolhaObj.height * cloudFolhaObj.scaleY) / 2+ 100)
    });

    const folhaBounds = {
        leftTop: fabric.util.transformPoint(
            new fabric.Point(cloudFolhaObj.left, cloudFolhaObj.top),
            canvas.viewportTransform
        ),
        rightBottom: fabric.util.transformPoint(
            new fabric.Point(
                cloudFolhaObj.left + cloudFolhaObj.width * cloudFolhaObj.scaleX,
                cloudFolhaObj.top + cloudFolhaObj.height * cloudFolhaObj.scaleY
            ),
            canvas.viewportTransform
        )
    };

    let currentX = folhaBounds.leftTop.x + marginPx + extraLeftPx;
    let currentY = folhaBounds.leftTop.y + marginPx + extraTopPx; 
    let maxHeightInRow = 0;

    const sortedObjects = selectedObjects.sort((a, b) => {
        const aCenter = a.getCenterPoint();
        const bCenter = b.getCenterPoint();
        return aCenter.y - bCenter.y || aCenter.x - bCenter.x;
    });

    for (const obj of sortedObjects) {
        const objWidth = obj.getScaledWidth();
        const objHeight = obj.getScaledHeight();

        if ((currentX + objWidth) > (folhaBounds.rightBottom.x - marginPx)) {
            currentX = folhaBounds.leftTop.x + marginPx + extraLeftPx; // Reinicia a posição X com o espaço extra
            currentY += maxHeightInRow + spacingPx;
            maxHeightInRow = 0;
        }

        if ((currentY + objHeight) > (folhaBounds.rightBottom.y - marginPx)) {
            console.warn("Não há espaço vertical suficiente");
            break;
        }

        obj.set({
            originX: 'left',
            originY: 'top'
        });

        await new Promise(resolve => {
            obj.animate({
                left: (currentX - canvas.viewportTransform[4]) / targetZoom,
                top: (currentY - canvas.viewportTransform[5]) / targetZoom
            }, {
                duration: 50,
                onChange: canvas.requestRenderAll.bind(canvas),
                onComplete: () => {
                    obj.setCoords();
                    resolve();
                }
            });
        });

        currentX += objWidth + spacingPx;
        maxHeightInRow = Math.max(maxHeightInRow, objHeight);
    }

    const newSelection = sortedObjects.filter(obj => objectIds.includes(obj.id));
    const activeSelection = new fabric.ActiveSelection(newSelection, { canvas: canvas });
    canvas.setActiveObject(activeSelection);
    canvas.requestRenderAll();

    isOrganizing = false;
}
document.getElementById('organize-objects').addEventListener('click', organizeObjects);

// -------------- Formas menu ---------------------------------------------
document.getElementById('insert-square').addEventListener('click', () => {
  const square = new fabric.Rect({
    width: 100,
    height: 100,
    left: cloudFolha.left + cloudFolha.width / 2,
    top: cloudFolha.top + cloudFolha.height / 2,
    fill: '#FF0000',
    originX: 'center',
    originY: 'center',
    padding: 0,
    cornerSize: 10,
    transparentCorners: false,
    borderColor: 'blue',
    cornerColor: 'blue',
    objectCaching: false,
    rx: 0,
    ry: 0 
  });

  const controlPoint = new fabric.Circle({
    radius: 4, 
    fill: 'white', 
    stroke: 'black', 
    strokeWidth: 1, 
    left: square.left - square.width / 2 + 10,
    top: square.top - square.height / 2 + 10,
    originX: 'center',
    originY: 'center',
    hasControls: false,
    hasBorders: false,
    selectable: true,
    evented: true,
    visible: true 
  });

  addObject(square);
  addObject(controlPoint);
  canvas.setActiveObject(square);
  updateLayersList();

  const MIN_RADIUS = 0; 

  function getMinDimension(obj) {
    const width = obj.width * obj.scaleX;
    const height = obj.height * obj.scaleY;
    return Math.min(width, height);
  }

  function normalizeCornerRadius(square, radius) {
    const MAX_RADIUS = getMinDimension(square) / 2; 
    return Math.max(MIN_RADIUS, Math.min(radius, MAX_RADIUS));
  }

controlPoint.on('moving', function (e) {
    controlPoint.set({
        left: square.left - square.width * square.scaleX / 2 + 10
    });

    const deltaY = controlPoint.top - (square.top - square.height * square.scaleY / 2 + 10);
    let radius = normalizeCornerRadius(square, deltaY);

    square.set({
        rx: radius,
        ry: radius
    });

    controlPoint.set({
        top: square.top - square.height * square.scaleY / 2 + 10 + radius
    });

    square.set({
        width: square.width * square.scaleX,
        height: square.height * square.scaleY,
        scaleX: 1,
        scaleY: 1
    });

    square.setCoords();

    canvas.requestRenderAll();
});


  controlPoint.on('mouseup', function () {
    updateControlPointPosition();
    canvas.setActiveObject(square);
    canvas.requestRenderAll();
  });

  function updateControlPointPosition() {
    const radius = square.rx || 0;
    controlPoint.set({
      left: square.left - square.width * square.scaleX / 2 + 10, 
      top: square.top - square.height * square.scaleY / 2 + 10 + radius
    });
  }

  square.on('moving', function () {
    updateControlPointPosition();
    canvas.requestRenderAll();
  });

  square.on('scaling', function () {
    const currentRadius = square.rx || 0;
    const newRadius = normalizeCornerRadius(square, currentRadius);
    square.set({ rx: newRadius, ry: newRadius });
    
    updateControlPointPosition();
    canvas.requestRenderAll();
  });

  square.on('selected', function () {
    controlPoint.set({ visible: true });
    canvas.bringToFront(controlPoint);
    canvas.requestRenderAll();
  });

  square.on('deselected', function () {
    controlPoint.set({ visible: false });
    canvas.requestRenderAll();
  });

  canvas.on('mouse:down', function (e) {
    if (e.target !== square && e.target !== controlPoint) {
      controlPoint.set({ visible: false });
      canvas.requestRenderAll();
    }
  });
});

document.getElementById('insert-circle').addEventListener('click', () => {
  const circle = new fabric.Circle({
    radius: 50,
    left: cloudFolha.left + cloudFolha.width / 2,
    top: cloudFolha.top + cloudFolha.height / 2,
    fill: '#00FF00',
    originX: 'center',
    originY: 'center',
    padding: 0,
    cornerSize: 10, 
    transparentCorners: false, 
    borderColor: 'blue', 
    cornerColor: 'blue',
    objectCaching: false
  });
  addObject(circle);
  canvas.setActiveObject(circle);
  updateLayersList();
});

document.getElementById('insert-triangle').addEventListener('click', () => {
  const triangle = new fabric.Triangle({
    width: 100,
    height: 100,
    left: cloudFolha.left + cloudFolha.width / 2,
    top: cloudFolha.top + cloudFolha.height / 2,
    fill: '#0000FF',
    originX: 'center',
    originY: 'center',
    padding: 0,
    cornerSize: 10,
    transparentCorners: false,
    borderColor: 'blue',
    cornerColor: 'blue',
    objectCaching: false 
  });
  addObject(triangle);
  canvas.setActiveObject(triangle);
  updateLayersList();
});
document.getElementById('insert-line').addEventListener('click', () => {
  const line = new fabric.Line([50, 50, 200, 50], {
    left: cloudFolha.left + cloudFolha.width / 2,
    top: cloudFolha.top + cloudFolha.height / 2,
    stroke: '#FF00FF',
    strokeWidth: 5,
    originX: 'center',
    originY: 'center'
  });
  addObject(line);
  canvas.setActiveObject(line);
  updateLayersList();
});

// ---------------- abrir e salvar documento --------------------------------------
document.getElementById('openDocumentBtn').addEventListener('click', function () {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.cloudapp';
    input.style.display = 'none';
    document.body.appendChild(input);
    input.click();

    input.addEventListener('change', function (e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (event) {
            const canvasState = JSON.parse(event.target.result);
            const cloudFolhaState = canvasState.cloudFolha;

            const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
            if (cloudFolha && cloudFolhaState) {
                cloudFolha.set({
                    width: cloudFolhaState.width,
                    height: cloudFolhaState.height
                });
                cloudFolha.setCoords();
            }

            canvas.loadFromJSON(canvasState, function () {
                if (cloudFolha) {
                    const widthCm = cloudFolha.width / cmToPx;
                    const heightCm = cloudFolha.height / cmToPx;
                    document.getElementById('width-input').value = widthCm.toFixed(1);
                    document.getElementById('height-input').value = heightCm.toFixed(1);
                }

                canvas.requestRenderAll();
                updateLayersList();
            });
        };

        reader.readAsText(file);
    });

    document.body.removeChild(input);
});

document.getElementById('saveDocumentBtn').addEventListener('click', function () {
    const objectsToSave = canvas.getObjects().filter(obj => obj.name !== 'CloudFolha');
    const canvasState = canvas.toDatalessJSON(['id', 'name', 'selectable', 'evented', 'left', 'top', 'width', 'height', 'scaleX', 'scaleY', 'angle', 'fill', 'stroke', 'strokeWidth']);

    const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
    if (cloudFolha) {
        canvasState.cloudFolha = {
            width: cloudFolha.width,
            height: cloudFolha.height
        };
    }

    const blob = new Blob([JSON.stringify(canvasState)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'documento.cloudapp'; 
    document.body.appendChild(a);
    a.click(); 
    document.body.removeChild(a);
    URL.revokeObjectURL(url); 
});

// ---------------- ferramenta de corte ---------------------------
let cropper = null;
let modalElement = null;

document.getElementById('crop-button').addEventListener('click', function() {
  const fabricCanvas = canvas;
  const activeObject = fabricCanvas.getActiveObject();
  
  if (!activeObject || !(activeObject instanceof fabric.Image)) {
    showCustomAlert('Selecione uma imagem para recortar.');
    return;
  }

  function initCropper(fabricCanvas) {
    // Obter a imagem original em sua resolução máxima
    const originalImage = new Image();
    originalImage.src = activeObject.getSrc();
    
    const originalDPI = activeObject.toObject().dpi || 300;
    const originalWidth = activeObject.width;
    const originalHeight = activeObject.height;
    const originalScaleX = activeObject.scaleX;
    const originalScaleY = activeObject.scaleY;

    const style = document.createElement('style');
    style.textContent = `
      .crop-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .crop-modal {
        background: #fff;
        padding: 20px;
        border-radius: 8px;
        max-width: 90vw;
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .crop-container {
        max-height: 70vh;
        overflow: hidden;
      }

      .crop-image {
        max-width: 100%;
        display: block;
      }

      .crop-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
      }

      .crop-button {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
        transition: background-color 0.2s;
      }

      .crop-confirm {
        background: #4CAF50;
        color: white;
      }

      .crop-cancel {
        background: #f44336;
        color: white;
      }

      .crop-button:hover {
        opacity: 0.9;
      }
    `;
    document.head.appendChild(style);

    const modal = document.createElement('div');
    modal.className = 'crop-modal-overlay';
    
    const modalContent = document.createElement('div');
    modalContent.className = 'crop-modal';
    
    const cropContainer = document.createElement('div');
    cropContainer.className = 'crop-container';
    
    const image = document.createElement('img');
    image.className = 'crop-image';
    image.src = activeObject.getSrc();
    
    const buttonsContainer = document.createElement('div');
    buttonsContainer.className = 'crop-buttons';
    
    const confirmButton = document.createElement('button');
    confirmButton.className = 'crop-button crop-confirm';
    confirmButton.textContent = 'Confirmar';
    
    const cancelButton = document.createElement('button');
    cancelButton.className = 'crop-button crop-cancel';
    cancelButton.textContent = 'Cancelar';
    
    buttonsContainer.appendChild(confirmButton);
    buttonsContainer.appendChild(cancelButton);
    cropContainer.appendChild(image);
    modalContent.appendChild(cropContainer);
    modalContent.appendChild(buttonsContainer);
    modal.appendChild(modalContent);
    
    document.body.appendChild(modal);
    modalElement = modal;

    image.onload = () => {
      cropper = new Cropper(image, {
        viewMode: 1,
        dragMode: 'move',
        aspectRatio: NaN,
        autoCropArea: 1,
        restore: false,
        guides: true,
        center: true,
        highlight: false,
        cropBoxMovable: true,
        cropBoxResizable: true,
        toggleDragModeOnDblclick: false,
      });
    };

    confirmButton.addEventListener('click', () => {
      if (!cropper) return;

      const cropData = cropper.getData();
      const cropperImageData = cropper.getImageData();
      
      // Calcular a proporção entre a área cortada e a imagem original
      const cropRatioX = cropData.width / cropperImageData.naturalWidth;
      const cropRatioY = cropData.height / cropperImageData.naturalHeight;
      
      // Calcular as novas dimensões mantendo a escala original
      const newWidth = originalWidth * cropRatioX;
      const newHeight = originalHeight * cropRatioY;
      
      // Criar um canvas temporário com as dimensões proporcionais
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = newWidth;
      tempCanvas.height = newHeight;
      const ctx = tempCanvas.getContext('2d');
      
      // Desativar a suavização para manter a nitidez
      ctx.imageSmoothingEnabled = false;
      
      // Calcular a área de corte proporcional
      const sourceX = (cropData.x / cropperImageData.naturalWidth) * originalImage.naturalWidth;
      const sourceY = (cropData.y / cropperImageData.naturalHeight) * originalImage.naturalHeight;
      const sourceWidth = (cropData.width / cropperImageData.naturalWidth) * originalImage.naturalWidth;
      const sourceHeight = (cropData.height / cropperImageData.naturalHeight) * originalImage.naturalHeight;
      
      // Desenhar a área cortada mantendo a proporção
      ctx.drawImage(
        originalImage,
        sourceX, sourceY,
        sourceWidth, sourceHeight,
        0, 0,
        newWidth, newHeight
      );

      // Criar a nova imagem no Fabric mantendo a escala
      fabric.Image.fromURL(tempCanvas.toDataURL(), (newImg) => {
        const { left, top, angle } = activeObject;
        
        // Calcular a nova posição mantendo o alinhamento
        const leftOffset = (cropData.x / cropperImageData.naturalWidth) * (originalWidth * originalScaleX);
        const topOffset = (cropData.y / cropperImageData.naturalHeight) * (originalHeight * originalScaleY);
        
        const newLeft = left - ((originalWidth * originalScaleX) / 2) + leftOffset + ((newWidth * originalScaleX) / 2);
        const newTop = top - ((originalHeight * originalScaleY) / 2) + topOffset + ((newHeight * originalScaleY) / 2);

        newImg.set({
          left: newLeft,
          top: newTop,
          originX: 'center',
          originY: 'center',
          width: newWidth,
          height: newHeight,
          scaleX: originalScaleX,
          scaleY: originalScaleY,
          angle: angle,
          dpi: originalDPI
        });

        fabricCanvas.remove(activeObject);
        fabricCanvas.add(newImg);
        fabricCanvas.setActiveObject(newImg);
        fabricCanvas.requestRenderAll();
      }, { crossOrigin: 'anonymous' });

      cleanup();
    });

    cancelButton.addEventListener('click', cleanup);

    function handleEsc(e) {
      if (e.key === 'Escape') {
        cleanup();
      }
    }
    document.addEventListener('keydown', handleEsc);

    function cleanup() {
      if (cropper) {
        cropper.destroy();
        cropper = null;
      }
      document.body.removeChild(modal);
      modalElement = null;
      document.removeEventListener('keydown', handleEsc);
      style.remove();
    }
  }

  initCropper(fabricCanvas);
});
// ---------------------------- contraste Automático --------------------------------------------------

function applyAutoContrast() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para aplicar o contraste automático.');
    return;
  }

  const img = activeObject.getElement();
  const canvasEl = document.createElement('canvas');
  const ctx = canvasEl.getContext('2d');

  const originalProps = {
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    angle: activeObject.angle,
    left: activeObject.left,
    top: activeObject.top,
    width: activeObject.width,
    height: activeObject.height,
    flipX: activeObject.flipX,
    flipY: activeObject.flipY,
    originX: activeObject.originX,
    originY: activeObject.originY,
    filters: activeObject.filters || [],
    clipPath: activeObject.clipPath,
    objectIndex: canvas.getObjects().indexOf(activeObject)
  };

  canvasEl.width = img.naturalWidth;
  canvasEl.height = img.naturalHeight;

  if (originalProps.filters.length > 0) {
    fabric.util.applyFilters(canvasEl, originalProps.filters, {
      width: img.naturalWidth,
      height: img.naturalHeight
    });
  }

  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
  const data = imageData.data;

  let minR = 255, maxR = 0;
  let minG = 255, maxG = 0;
  let minB = 255, maxB = 0;

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    minR = Math.min(minR, r);
    maxR = Math.max(maxR, r);
    minG = Math.min(minG, g);
    maxG = Math.max(maxG, g);
    minB = Math.min(minB, b);
    maxB = Math.max(maxB, b);
  }

  const rangeR = maxR - minR || 1;
  const rangeG = maxG - minG || 1;
  const rangeB = maxB - minB || 1;

  for (let i = 0; i < data.length; i += 4) {
    data[i] = ((data[i] - minR) / rangeR) * 255; 
    data[i + 1] = ((data[i + 1] - minG) / rangeG) * 255;
    data[i + 2] = ((data[i + 2] - minB) / rangeB) * 255;
  }

  ctx.putImageData(imageData, 0, 0);

  fabric.Image.fromURL(canvasEl.toDataURL(), newImg => {
    newImg.set({
      ...originalProps,
      crossOrigin: 'anonymous'
    });

    canvas.remove(activeObject);

    if (originalProps.objectIndex >= 0) {
      canvas.insertAt(newImg, originalProps.objectIndex);
    } else {
      canvas.add(newImg);
    }

    canvas.setActiveObject(newImg);
    canvas.requestRenderAll();
  });
}

document.getElementById('BtnContrasteAutm').addEventListener('click', applyAutoContrast);

function applyAutoColor() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para aplicar a cor automática.');
    return;
  }

  const img = activeObject.getElement();
  const canvasEl = document.createElement('canvas');
  const ctx = canvasEl.getContext('2d');

  const originalProps = {
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    angle: activeObject.angle,
    left: activeObject.left,
    top: activeObject.top,
    width: activeObject.width,
    height: activeObject.height,
    filters: activeObject.filters || [],
    flipX: activeObject.flipX,
    flipY: activeObject.flipY,
    opacity: activeObject.opacity,
    shadow: activeObject.shadow ? new fabric.Shadow(activeObject.shadow) : null,
    stroke: activeObject.stroke,
    strokeWidth: activeObject.strokeWidth,
    strokeDashArray: activeObject.strokeDashArray,
    strokeLineCap: activeObject.strokeLineCap,
    strokeLineJoin: activeObject.strokeLineJoin,
    strokeMiterLimit: activeObject.strokeMiterLimit,
    padding: activeObject.padding,
    backgroundColor: activeObject.backgroundColor,
    clipPath: activeObject.clipPath,
    originX: activeObject.originX,
    originY: activeObject.originY,
    cropX: activeObject.cropX,
    cropY: activeObject.cropY
  };

  canvasEl.width = img.naturalWidth;
  canvasEl.height = img.naturalHeight;

  if (originalProps.filters.length > 0) {
    fabric.util.applyFilters(canvasEl, originalProps.filters, {
      width: img.naturalWidth,
      height: img.naturalHeight
    });
  }

  ctx.drawImage(img, 0, 0);

  const imageData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
  const data = imageData.data;

  let rTotal = 0, gTotal = 0, bTotal = 0;
  let count = 0;
  for (let i = 0; i < data.length; i += 4) {
    rTotal += data[i];
    gTotal += data[i + 1];
    bTotal += data[i + 2];
    count++;
  }
  let rAvg = rTotal / count;
  let gAvg = gTotal / count;
  let bAvg = bTotal / count;

  let avg = (rAvg + gAvg + bAvg) / 3;
  let rFactor = avg / rAvg;
  let gFactor = avg / gAvg;
  let bFactor = avg / bAvg;

  for (let i = 0; i < data.length; i += 4) {
    data[i] = Math.min(255, data[i] * rFactor);       // R
    data[i + 1] = Math.min(255, data[i + 1] * gFactor); // G
    data[i + 2] = Math.min(255, data[i + 2] * bFactor); // B
  }

  ctx.putImageData(imageData, 0, 0);

  fabric.Image.fromURL(canvasEl.toDataURL(), newImg => {
    newImg.set(originalProps);

    canvas.remove(activeObject);
    canvas.add(newImg);
    canvas.setActiveObject(newImg);
    canvas.requestRenderAll();
  });
}

document.getElementById('BtnCorAutm').addEventListener('click', applyAutoColor);

function applyAutoTone() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para aplicar o tom automático.');
    return;
  }

  const img = activeObject.getElement();
  const canvasEl = document.createElement('canvas');
  const ctx = canvasEl.getContext('2d');

  const originalProps = {
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    angle: activeObject.angle,
    left: activeObject.left,
    top: activeObject.top,
    width: activeObject.width,
    height: activeObject.height,
    flipX: activeObject.flipX,
    flipY: activeObject.flipY,
    originX: activeObject.originX,
    originY: activeObject.originY,
    filters: activeObject.filters || [],
    clipPath: activeObject.clipPath,
    objectIndex: canvas.getObjects().indexOf(activeObject)
  };

  canvasEl.width = img.naturalWidth;
  canvasEl.height = img.naturalHeight;

  if (originalProps.filters.length > 0) {
    fabric.util.applyFilters(canvasEl, originalProps.filters, {
      width: img.naturalWidth,
      height: img.naturalHeight
    });
  }

  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
  const data = imageData.data;

  const histR = new Array(256).fill(0);
  const histG = new Array(256).fill(0);
  const histB = new Array(256).fill(0);

  for (let i = 0; i < data.length; i += 4) {
    histR[data[i]]++;
    histG[data[i + 1]]++;
    histB[data[i + 2]]++;
  }

  function findCutoffPoints(histogram) {
    const totalPixels = histogram.reduce((a, b) => a + b, 0);
    const cutoffPercent = 0.005;
    
    let sumLow = 0;
    let lowCut = 0;
    while (sumLow < totalPixels * cutoffPercent && lowCut < 255) {
      sumLow += histogram[lowCut];
      lowCut++;
    }

    let sumHigh = 0;
    let highCut = 255;
    while (sumHigh < totalPixels * cutoffPercent && highCut > 0) {
      sumHigh += histogram[highCut];
      highCut--;
    }

    return { lowCut, highCut };
  }

  const cutoffsR = findCutoffPoints(histR);
  const cutoffsG = findCutoffPoints(histG);
  const cutoffsB = findCutoffPoints(histB);

  function adjustValue(value, low, high) {
    if (value <= low) return 0;
    if (value >= high) return 255;
    return Math.round((value - low) / (high - low) * 255);
  }

  for (let i = 0; i < data.length; i += 4) {
    data[i] = adjustValue(data[i], cutoffsR.lowCut, cutoffsR.highCut);
    data[i + 1] = adjustValue(data[i + 1], cutoffsG.lowCut, cutoffsG.highCut);
    data[i + 2] = adjustValue(data[i + 2], cutoffsB.lowCut, cutoffsB.highCut);
  }

  ctx.putImageData(imageData, 0, 0);

  fabric.Image.fromURL(canvasEl.toDataURL(), newImg => {
    newImg.set({
      ...originalProps,
      crossOrigin: 'anonymous'
    });

    canvas.remove(activeObject);

    if (originalProps.objectIndex >= 0) {
      canvas.insertAt(newImg, originalProps.objectIndex);
    } else {
      canvas.add(newImg);
    }

    canvas.setActiveObject(newImg);
    canvas.requestRenderAll();
  });
}

document.getElementById('BtnTomAutm').addEventListener('click', applyAutoTone);

function convertToBlackAndWhite() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para converter para preto e branco.');
    return;
  }

  const img = activeObject.getElement();
  const canvasEl = document.createElement('canvas');
  const ctx = canvasEl.getContext('2d');

  const originalProps = {
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    angle: activeObject.angle,
    left: activeObject.left,
    top: activeObject.top,
    width: activeObject.width,
    height: activeObject.height,
    flipX: activeObject.flipX,
    flipY: activeObject.flipY,
    originX: activeObject.originX,
    originY: activeObject.originY,
    filters: activeObject.filters || [],
    clipPath: activeObject.clipPath,
    objectIndex: canvas.getObjects().indexOf(activeObject)
  };

  canvasEl.width = img.naturalWidth;
  canvasEl.height = img.naturalHeight;

  if (originalProps.filters.length > 0) {
    fabric.util.applyFilters(canvasEl, originalProps.filters, {
      width: img.naturalWidth,
      height: img.naturalHeight
    });
  }

  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
  const data = imageData.data;

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const gray = Math.round(r * 0.299 + g * 0.587 + b * 0.114);
    data[i] = gray;
    data[i + 1] = gray;
    data[i + 2] = gray;
  }

  ctx.putImageData(imageData, 0, 0);

  fabric.Image.fromURL(canvasEl.toDataURL(), newImg => {
    newImg.set({
      ...originalProps,
      crossOrigin: 'anonymous'
    });

    canvas.remove(activeObject);

    if (originalProps.objectIndex >= 0) {
      canvas.insertAt(newImg, originalProps.objectIndex);
    } else {
      canvas.add(newImg);
    }

    canvas.setActiveObject(newImg);
    canvas.requestRenderAll();
  });
}

function invertColors() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para inverter as cores.');
    return;
  }

  const img = activeObject.getElement();
  const canvasEl = document.createElement('canvas');
  const ctx = canvasEl.getContext('2d');

  const originalProps = {
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    angle: activeObject.angle,
    left: activeObject.left,
    top: activeObject.top,
    width: activeObject.width,
    height: activeObject.height,
    flipX: activeObject.flipX,
    flipY: activeObject.flipY,
    originX: activeObject.originX,
    originY: activeObject.originY,
    filters: activeObject.filters || [],
    clipPath: activeObject.clipPath,
    objectIndex: canvas.getObjects().indexOf(activeObject)
  };

  canvasEl.width = img.naturalWidth;
  canvasEl.height = img.naturalHeight;

  if (originalProps.filters.length > 0) {
    fabric.util.applyFilters(canvasEl, originalProps.filters, {
      width: img.naturalWidth,
      height: img.naturalHeight
    });
  }

  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
  const data = imageData.data;

  for (let i = 0; i < data.length; i += 4) {
    data[i] = 255 - data[i];         
    data[i + 1] = 255 - data[i + 1];
    data[i + 2] = 255 - data[i + 2]; 
  }

  ctx.putImageData(imageData, 0, 0);

  fabric.Image.fromURL(canvasEl.toDataURL(), newImg => {
    newImg.set({
      ...originalProps,
      crossOrigin: 'anonymous'
    });

    canvas.remove(activeObject);

    if (originalProps.objectIndex >= 0) {
      canvas.insertAt(newImg, originalProps.objectIndex);
    } else {
      canvas.add(newImg);
    }

    canvas.setActiveObject(newImg);
    canvas.requestRenderAll();
  });
}

document.getElementById('Btn-PretoBranco').addEventListener('click', convertToBlackAndWhite);
document.getElementById('Btn-InverterCor').addEventListener('click', invertColors);

// ---------------- adicionar nitidez ----------------------------------
function addSharpness() {
  const activeObject = canvas.getActiveObject();
  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para adicionar nitidez.');
    return;
  }

  const img = activeObject.getElement();
  const canvasEl = document.createElement('canvas');
  const ctx = canvasEl.getContext('2d');

  const originalProps = {
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    angle: activeObject.angle,
    left: activeObject.left,
    top: activeObject.top,
    width: activeObject.width,
    height: activeObject.height,
    flipX: activeObject.flipX,
    flipY: activeObject.flipY,
    originX: activeObject.originX,
    originY: activeObject.originY,
    filters: activeObject.filters || [],
    clipPath: activeObject.clipPath,
    objectIndex: canvas.getObjects().indexOf(activeObject)
  };

  canvasEl.width = img.naturalWidth;
  canvasEl.height = img.naturalHeight;

  if (originalProps.filters.length > 0) {
    fabric.util.applyFilters(canvasEl, originalProps.filters, {
      width: img.naturalWidth,
      height: img.naturalHeight
    });
  }

  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvasEl.width, canvasEl.height);
  const data = imageData.data;

  const kernel = [
    0, -1,  0,
   -1,  5, -1,
    0, -1,  0
  ];

  const width = canvasEl.width;
  const height = canvasEl.height;
  const outputData = new Uint8ClampedArray(data.length);

  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      for (let c = 0; c < 3; c++) { 
        const idx = (y * width + x) * 4 + c;
        let sum = 0;
        
        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const srcIdx = ((y + ky) * width + (x + kx)) * 4 + c;
            sum += data[srcIdx] * kernel[(ky + 1) * 3 + (kx + 1)];
          }
        }
        
        outputData[idx] = sum;
      }
      
      outputData[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3];
    }
  }

  for (let i = 0; i < outputData.length; i++) {
    data[i] = outputData[i];
  }

  ctx.putImageData(imageData, 0, 0);

  fabric.Image.fromURL(canvasEl.toDataURL(), newImg => {
    newImg.set({
      ...originalProps,
      crossOrigin: 'anonymous'
    });

    canvas.remove(activeObject);

    if (originalProps.objectIndex >= 0) {
      canvas.insertAt(newImg, originalProps.objectIndex);
    } else {
      canvas.add(newImg);
    }

    canvas.setActiveObject(newImg);
    canvas.requestRenderAll();
  });
}

document.getElementById('Btn-Nitidez').addEventListener('click', addSharpness);

// ------------- arrastar e soltar drag drop dragdrop ------------------------------------
canvas.wrapperEl.addEventListener('dragover', (e) => {
  e.preventDefault();
  e.stopPropagation();
  e.dataTransfer.dropEffect = 'copy';
});

canvas.wrapperEl.addEventListener('dragleave', (e) => {
  e.preventDefault();
  e.stopPropagation();
});

function validateFileType(file) {
  const validTypes = ['application/pdf', 'application/octet-stream'];
  return validTypes.includes(file.type) || file.type.startsWith('image/');
}

function getUniqueFileName(fileName) {
  const baseName = fileName.replace(/\.[^/.]+$/, "").replace(/[^a-zA-Z0-9]/g, "_");
  return baseName.substring(0, 20);
}

canvas.wrapperEl.addEventListener('drop', async (e) => {
  e.preventDefault();
  e.stopPropagation();
  const files = e.dataTransfer.files;
  
  if (files.length > 0) {
    for (const file of files) {
      if (file.type.startsWith('image/')) {
        await processImageFile(file, true);
      } else if (file.type === 'application/pdf') {
        await processPDFFile(file, true); 
      } else if (file.name.endsWith('.cloudapp')) {
        await processCloudAppFile(file);
      } else {
        showCustomAlert('Por favor, arraste apenas arquivos de imagem, PDF ou .cloudapp.');
      }
    }
  }
});

// ----------------- abrir imagem ou pdf menu --------------------------------
const fileInput = document.createElement('input');
fileInput.type = 'file';
fileInput.multiple = true;
fileInput.accept = 'image/*,.pdf,.cloudapp';
fileInput.style.display = 'none';
document.body.appendChild(fileInput);

async function processImageFile(file, center = true) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            fabric.Image.fromURL(event.target.result, (img) => {
                const fileName = getUniqueFileName(file.name);

                const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
                if (cloudFolha) {
                    const scaleX = cloudFolha.width / img.width;
                    const scaleY = cloudFolha.height / img.height;
                    const scale = Math.min(scaleX, scaleY); 

                    img.set({
                        left: cloudFolha.left + cloudFolha.width / 2,
                        top: cloudFolha.top + cloudFolha.height / 2,
                        originX: 'center',
                        originY: 'center',
                        scaleX: scale,
                        scaleY: scale,
                        fileName: fileName,
                        name: fileName,
                        originalFile: file.name
                    });

                    addObject(img);
                    canvas.setActiveObject(img);
                    canvas.requestRenderAll();
                }

                resolve(img);
            });
        };
        reader.readAsDataURL(file);
    });
}


async function processPDFFile(file, center = true) {
    const pdf = await pdfjsLib.getDocument({ url: URL.createObjectURL(file) }).promise;
    const numPages = pdf.numPages;
    const pdfName = getUniqueFileName(file.name);

    for (let pageNum = 1; pageNum <= numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);

        const scale = 4; 
        const viewport = page.getViewport({ scale });

        const canvasElement = document.createElement('canvas');
        const context = canvasElement.getContext('2d', { alpha: false });
        canvasElement.width = viewport.width;
        canvasElement.height = viewport.height;

        await page.render({
            canvasContext: context,
            viewport: viewport
        }).promise;

        const imgData = canvasElement.toDataURL('image/png'); 

        await new Promise((resolve) => {
            fabric.Image.fromURL(imgData, (img) => {
                const pageName = `${pdfName}_p${pageNum}`;

                const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
                if (cloudFolha) {
                    const scaleX = cloudFolha.width / img.width;
                    const scaleY = cloudFolha.height / img.height;
                    const finalScale = Math.min(scaleX, scaleY);

                    img.set({
                        left: cloudFolha.left + cloudFolha.width / 2,
                        top: cloudFolha.top + cloudFolha.height / 2,
                        originX: 'center',
                        originY: 'center',
                        scaleX: finalScale,
                        scaleY: finalScale,
                        fileName: pageName,
                        name: pageName,
                        originalFile: `${file.name} - Página ${pageNum}`,
                        isPdfPage: true,
                        pageNumber: pageNum
                    });

                    addObject(img);
                    canvas.setActiveObject(img);
                    canvas.requestRenderAll();
                }

                resolve();
            });
        });
    }
}


async function processCloudAppFile(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = (event) => {
      const canvasState = JSON.parse(event.target.result);
      const cloudFolhaState = canvasState.cloudFolha;
      
      canvas.loadFromJSON(canvasState, function () {
        const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
        
        if (cloudFolha && cloudFolhaState) {
          // Aplicar dimensões originais
          cloudFolha.set({
            width: cloudFolhaState.width,
            height: cloudFolhaState.height,
            scaleX: 1,
            scaleY: 1
          });
          
          // Atualizar inputs com valores em cm
          const widthCm = cloudFolha.width / cmToPx;
          const heightCm = cloudFolha.height / cmToPx;
          document.getElementById('width-input').value = widthCm.toFixed(1);
          document.getElementById('height-input').value = heightCm.toFixed(1);
          
          // Centralizar o objeto
          cloudFolha.set({
            left: (canvas.getWidth() / 2) - (cloudFolha.width / 2) - 250,
            top: (canvas.getHeight() / 2) - (cloudFolha.height / 2) + 100
          });
          
          cloudFolha.setCoords();
        }
        
        canvas.requestRenderAll();
        updateLayersList();
        resolve();
      });
    };
    reader.readAsText(file);
  });
}

document.getElementById('openImagePDFBtn').addEventListener('click', () => {
    fileInput.click();
});

fileInput.addEventListener('change', async (e) => {
    const files = e.target.files;
    
    if (files.length > 0) {
        for (const file of files) {
            try {
                if (file.type.startsWith('image/')) {
                    await processImageFile(file);
                } else if (file.type === 'application/pdf') {
                    await processPDFFile(file);
                } else if (file.name.endsWith('.cloudapp')) {
                    await processCloudAppFile(file);
                } else {
                    showCustomAlert('Por favor, selecione apenas arquivos de imagem, PDF ou .cloudapp.');
                }
            } catch (error) {
                console.error('Erro ao processar arquivo:', error);
                showCustomAlert('Erro ao processar o arquivo. Por favor, tente novamente.');
            }
        }
        
        canvas.requestRenderAll();
        updateLayersList();
        
        fileInput.value = '';
    }
});

function exportCanvas(format, extension, inputId) {
  return new Promise((resolve, reject) => {
    try {
      const cloudFolhaObj = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
      if (!cloudFolhaObj) {
        reject(new Error('CloudFolha não encontrada'));
        return;
      }

      const TARGET_DPI = parseInt(document.getElementById(inputId).value) || 300;
      const BROWSER_DPI = 96;
      const dpiScale = TARGET_DPI / BROWSER_DPI;
      const marginCompensation = 0.1 * cmToPx * dpiScale;

  const exportWidth = cloudFolhaObj.width * dpiScale + marginCompensation;
  const exportHeight = cloudFolhaObj.height * dpiScale + marginCompensation;

  const exportCanvas = new fabric.Canvas(null, {
    width: exportWidth,
    height: exportHeight,
    backgroundColor: 'white'
  });

  const clipPath = new fabric.Rect({
    left: marginCompensation / 2,
    top: marginCompensation / 2,
    width: cloudFolhaObj.width * dpiScale,
    height: cloudFolhaObj.height * dpiScale,
    absolutePositioned: true
  });

  const objectsToExport = canvas.getObjects()
    .filter(obj => obj !== cloudFolhaObj && !obj.name?.includes('Guia'))
    .map(obj => {
      const clone = fabric.util.object.clone(obj);
      const relativeLeft = obj.left - cloudFolhaObj.left;
      const relativeTop = obj.top - cloudFolhaObj.top;

      clone.set({
        left: (relativeLeft * dpiScale) + (marginCompensation / 2),
        top: (relativeTop * dpiScale) + (marginCompensation / 2),
        scaleX: obj.scaleX * dpiScale,
        scaleY: obj.scaleY * dpiScale,
        clipPath: clipPath,
        selectable: false
      });

      if (clone.type === 'i-text') {
        const strokeScale = dpiScale * (clone.strokeWidth > 0 ? 1.2 : 1);
        clone.set({
          fontSize: clone.fontSize * dpiScale,
          strokeWidth: clone.strokeWidth * strokeScale,
          scaleX: 1,
          scaleY: 1,
          paintFirst: 'stroke',
          left: clone.left - (clone.strokeWidth * strokeScale / 2),
          top: clone.top - (clone.strokeWidth * strokeScale / 2)
        });

        clone.width = clone.width + (clone.strokeWidth * strokeScale);
        clone.height = clone.height + (clone.strokeWidth * strokeScale);
      }

      return clone;
    });

  exportCanvas.add(...objectsToExport);
  exportCanvas.renderAll();

  const imgData = exportCanvas.toDataURL({
        format: format,
        quality: 1.0,
        enableRetinaScaling: true
      });

      if (extension === 'PDF') {
        resolve({ imgData, cloudFolhaObj, TARGET_DPI });
      } else {
        const link = document.createElement('a');
        link.download = `CloudApp${extension}_${TARGET_DPI}dpi.${extension}`;
        link.href = imgData;
        link.click();
        resolve();
      }

      // Limpar o canvas temporário após a exportação
      exportCanvas.clear();

      // SOLUÇÃO: Corrigir o bug de renderização dos textos
      setTimeout(() => {
        const textObjects = canvas.getObjects().filter(obj => obj.type === 'i-text');
        textObjects.forEach(obj => {
          obj.set({
            scaleX: 1,
            scaleY: 1
          });
          obj.setCoords();
        });

        const currentZoom = canvas.getZoom();
        canvas.setZoom(currentZoom * 1.01);
        setTimeout(() => canvas.setZoom(currentZoom), 10);

        canvas.requestRenderAll();
      }, 50);
    } catch (error) {
      reject(error);
    }
  });
}

document.getElementById('export-png').addEventListener('click', () => exportCanvas('png', 'PNG', 'dpi-input'));
document.getElementById('export-JPG').addEventListener('click', () => exportCanvas('jpeg', 'JPG', 'dpijpg-input'));

document.getElementById('export-PDF').addEventListener('click', async () => {
  if (typeof window.jspdf === 'undefined') {
    console.error('jsPDF não está carregado. Verifique se a biblioteca foi importada corretamente.');
    showCustomAlert('Erro: biblioteca PDF não encontrada');
    return;
  }

  try {
    const { imgData, cloudFolhaObj, TARGET_DPI } = await exportCanvas('png', 'PDF', 'dpipdf-input');
    
    // Converter de pixels para milímetros
    const pdfWidth = cloudFolhaObj.width * 0.264583;
    const pdfHeight = cloudFolhaObj.height * 0.264583;

    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({
      orientation: pdfWidth > pdfHeight ? 'landscape' : 'portrait',
      unit: 'mm',
      format: [pdfWidth, pdfHeight]
    });

    pdf.addImage(
      imgData,
      'PNG',
      0,
      0,
      pdfWidth,
      pdfHeight,
      undefined,
      'FAST'
    );

    pdf.save(`CloudAppPDF_${TARGET_DPI}dpi.pdf`);
  } catch (error) {
    console.error('Erro ao gerar PDF:', error);
    showCustomAlert('Erro ao gerar PDF: ' + error.message);
  }
});


// ----------------- Opacidade e exportar png e svg menu superior -----------------------------
 const generalControls = document.querySelector('.general-controls');
  const opacityInput = document.getElementById('opacity-input');
  const exportPngButton = document.getElementById('export-png-selected');

  function updateOpacity() {
    const activeObjects = canvas.getActiveObjects();
    if (activeObjects.length === 1) {
      const obj = activeObjects[0];
      opacityInput.value = Math.round(obj.opacity * 100);
      generalControls.style.display = 'block';
    } else if (activeObjects.length > 1) {
      opacityInput.value = '';
      generalControls.style.display = 'block';
    } else {
      generalControls.style.display = 'none';
    }
  }

  opacityInput.addEventListener('input', () => {
    const activeObjects = canvas.getActiveObjects();
    const newOpacity = parseFloat(opacityInput.value) / 100;
    activeObjects.forEach(obj => {
      obj.set('opacity', newOpacity);
      obj.dirty = true;
    });
    canvas.requestRenderAll();
  });

  function exportSelectedObjectsToPNG() {
  const activeObjects = canvas.getActiveObjects();
  if (activeObjects.length === 0) {
    showCustomAlert('Nenhum objeto selecionado para exportar.');
    return;
  }

  // Cria um novo canvas temporário
  const tempCanvasElement = document.createElement('canvas');
  tempCanvasElement.style.display = 'none';
  document.body.appendChild(tempCanvasElement);
  const tempCanvas = new fabric.StaticCanvas(tempCanvasElement, {
    backgroundColor: 'transparent'
  });

  // Clona os objetos selecionados e adiciona ao canvas temporário
  const clonedObjects = activeObjects.map(obj => fabric.util.object.clone(obj));
  clonedObjects.forEach(obj => {
    tempCanvas.add(obj);
  });

  // Ajusta a escala de texto (scaleX = 1, scaleY = 1)
  clonedObjects.forEach(obj => {
    if (obj.type === 'text') {
      obj.set({ scaleX: 1, scaleY: 1 });
    }
  });

  const group = new fabric.Group(clonedObjects, {
    left: 0,
    top: 0,
    originX: 'left',
    originY: 'top'
  });
  tempCanvas.add(group);
  
  setTimeout(() => {
    const groupBounds = group.getBoundingRect();
    const width = groupBounds.width;
    const height = groupBounds.height;

    tempCanvas.setDimensions({ width, height });

    tempCanvas.requestRenderAll();

    const dataUrl = tempCanvas.toDataURL({
      format: 'png',
      quality: 1.0,
      enableRetinaScaling: true
    });

    const downloadLink = document.createElement('a');
    downloadLink.href = dataUrl;
    downloadLink.download = 'CloudApp_Objetos.png';
    downloadLink.click();

    tempCanvas.dispose();
    document.body.removeChild(tempCanvasElement);
  }, 50); 
}

exportPngButton.addEventListener('click', exportSelectedObjectsToPNG);



canvas.on('selection:created', () => {
  updateDimensionInputs();
  updateLayersList();
  updateTextStylingControls();
  updateOpacity();
});

canvas.on('selection:updated', () => {
  updateDimensionInputs();
  updateLayersList();
  updateTextStylingControls();
  updateOpacity();
});

canvas.on('selection:cleared', () => {
  updateDimensionInputs();
  updateLayersList();
  const textStylingControls = document.querySelector('.text-styling-controls');
  textStylingControls.style.display = 'none';
  updateOpacity();
});

updateOpacity();

document.getElementById('export-svg-selected').addEventListener('click', () => {
    const activeObject = canvas.getActiveObject();
    
    if (!activeObject) {
        showCustomAlert('Nenhum objeto selecionado para exportar.');
        return;
    }

    // Lista de tipos suportados para exportação SVG
    const supportedTypes = ['rect', 'circle', 'triangle', 'path', 'i-text', 'textbox'];
    
    if (supportedTypes.includes(activeObject.type)) {
        const tempCanvas = new fabric.Canvas(document.createElement('canvas'));
        
        activeObject.clone((clonedObject) => {
            const bbox = clonedObject.getBoundingRect();
            
            // Adiciona padding extra para texto para evitar cortes
            const padding = (activeObject.type === 'i-text' || activeObject.type === 'textbox') ? 100 : 0;
            
            tempCanvas.setWidth(bbox.width + (padding * 2));
            tempCanvas.setHeight(bbox.height + (padding * 2));
            
            // Preserva todas as propriedades importantes do texto
            if (activeObject.type === 'i-text' || activeObject.type === 'textbox') {
                clonedObject.set({
                    left: padding,
                    top: padding,
                    originX: 'left',
                    originY: 'top',
                    // Preserva propriedades específicas do texto
                    fontFamily: activeObject.fontFamily,
                    fontSize: activeObject.fontSize,
                    fontWeight: activeObject.fontWeight,
                    fontStyle: activeObject.fontStyle,
                    textAlign: activeObject.textAlign,
                    lineHeight: activeObject.lineHeight,
                    underline: activeObject.underline,
                    overline: activeObject.overline,
                    linethrough: activeObject.linethrough,
                    textBackgroundColor: activeObject.textBackgroundColor,
                    charSpacing: activeObject.charSpacing,
                    // Preserva propriedades de estilo
                    fill: activeObject.fill,
                    stroke: activeObject.stroke,
                    strokeWidth: activeObject.strokeWidth,
                    angle: activeObject.angle,
                    opacity: activeObject.opacity,
                    flipX: activeObject.flipX,
                    flipY: activeObject.flipY,
                    scaleX: activeObject.scaleX,
                    scaleY: activeObject.scaleY
                });
            } else {
                clonedObject.set({
                    left: padding,
                    top: padding,
                    originX: 'left',
                    originY: 'top'
                });
            }
            
            tempCanvas.add(clonedObject);
            tempCanvas.renderAll();
            
            let svgContent = tempCanvas.toSVG({
                width: bbox.width + (padding * 2),
                height: bbox.height + (padding * 2),
                viewBox: {
                    x: 0,
                    y: 0,
                    width: bbox.width + (padding * 2),
                    height: bbox.height + (padding * 2)
                }
            });
            
            svgContent = svgContent.replace(/<\?xml[^>]*\?>\s*/g, '');
            
            const finalSvg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n${svgContent}`;
            
            const blob = new Blob([finalSvg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `CloudApp_${activeObject.type}.svg`;
            a.click();
            URL.revokeObjectURL(url);
            
            tempCanvas.dispose();
        });
    } else {
        showCustomAlert('Selecione uma forma ou texto para exportar como SVG.');
    }
});
  // ------------- importar em svg ------------------------------

document.getElementById('import-svg').addEventListener('click', () => {
  const fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = '.svg';
  fileInput.style.display = 'none';
  document.body.appendChild(fileInput);
  fileInput.click();

  fileInput.addEventListener('change', handleSVGImport);

  document.body.removeChild(fileInput);
});

function handleSVGImport(event) {
  const file = event.target.files[0];
  if (file && file.type === 'image/svg+xml') {
    const reader = new FileReader();
    reader.onload = function(e) {
      const svgContent = e.target.result;

      fabric.loadSVGFromString(svgContent, function(objects, options) {
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        objects.forEach((obj) => {
          const objBounds = obj.getBoundingRect();
          minX = Math.min(minX, objBounds.left);
          minY = Math.min(minY, objBounds.top);
          maxX = Math.max(maxX, objBounds.left + objBounds.width);
          maxY = Math.max(maxY, objBounds.top + objBounds.height);
        });

        const originalWidth = maxX - minX;
        const originalHeight = maxY - minY;

        const scaleX = cloudFolha.width / originalWidth;
        const scaleY = cloudFolha.height / originalHeight;
        const scale = Math.min(scaleX, scaleY);

        objects.forEach((obj) => {
          const originalFill = obj.fill;
          const originalStroke = obj.stroke;

          const normalizedLeft = (obj.left - minX) * scale;
          const normalizedTop = (obj.top - minY) * scale;

          obj.set({
            left: normalizedLeft + (cloudFolha.left + cloudFolha.width / 2),
            top: normalizedTop + (cloudFolha.top + cloudFolha.height / 2),
            scaleX: obj.scaleX * scale,
            scaleY: obj.scaleY * scale,
            strokeWidth: obj.strokeWidth || 1,
            stroke: originalStroke || '#000000',
            fill: originalFill || 'transparent',
            objectCaching: false,
            perPixelTargetFind: true,
            strokeUniform: true,
            cornerColor: '#0066ff',
            cornerSize: 12,
            cornerStyle: 'circle',
            transparentCorners: false,
            hasBorders: true,
            hasControls: true,
            selectable: true
          });

          canvas.add(obj);
          obj.setCoords();
        });

        const allObjects = canvas.getObjects().filter(obj => obj !== cloudFolha);
        if (allObjects.length > 0) {
          const selection = new fabric.ActiveSelection(allObjects, { canvas: canvas });
          selection.center();
          canvas.discardActiveObject();
          canvas.setActiveObject(selection);
        }

        canvas.requestRenderAll();
        updateLayersList();
      });
    };
    reader.readAsText(file);
  } else {
    showCustomAlert('Por favor, selecione um arquivo SVG válido.');
  }
}

// ------------ Borracha Apagar -----------------------------------
const eraserButton = document.getElementById('eraser-button');
eraserButton.addEventListener('click', () => {
  const activeObject = canvas.getActiveObject();

  if (!activeObject) {
    showCustomAlert('Nenhuma imagem selecionada!');
    return;
  }

  const originalProps = {
    left: activeObject.left,
    top: activeObject.top,
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    width: activeObject.width,
    height: activeObject.height,
    angle: activeObject.angle,
    originX: activeObject.originX,
    originY: activeObject.originY
  };

  let eraserHistory = [];
  let currentHistoryIndex = -1;
  const MAX_HISTORY = 10;

  const modalContainer = document.createElement('div');
  modalContainer.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  `;

  const modalContent = document.createElement('div');
  modalContent.style.cssText = `
    background: #151f28;
    padding: 20px;
    border-radius: 8px;
    width: 800px;
    height: 600px;
    position: relative;
    margin-bottom: 20px;
    display: flex;
    flex-direction: column;
  `;

  // Criar container com scroll
  const canvasScrollContainer = document.createElement('div');
  canvasScrollContainer.style.cssText = `
    flex: 1;
    overflow: auto;
    position: relative;
    margin-bottom: 20px;
  `;

const brushControls = document.createElement('div');
brushControls.style.cssText = `
  position: absolute;
  bottom: 20px;
  left: 20px;
  background-color: #151f28; /* Cor de fundo sólida */
  padding: 10px;
  border-radius: 4px;
  z-index: 1002;
  display: flex;
  align-items: center;
  gap: 10px;
`;

  const undoButton = document.createElement('button');
  undoButton.textContent = 'Voltar';
  undoButton.style.cssText = `
    padding: 5px 15px;
    background: #3498db;
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s;
    margin-right: 15px;
  `;
  undoButton.disabled = true;
  undoButton.onmouseover = () => undoButton.style.background = '#2980b9';
  undoButton.onmouseout = () => undoButton.style.background = '#3498db';

  brushControls.appendChild(undoButton);

  const brushSlider = document.createElement('input');
  brushSlider.type = 'range';
  brushSlider.min = '1';
  brushSlider.max = '500';
  brushSlider.value = '20';
  brushSlider.style.cssText = `
    width: 150px;
    accent-color: #2ecc71;
  `;

  const brushSizeInput = document.createElement('input');
  brushSizeInput.type = 'number';
  brushSizeInput.value = '20';
  brushSizeInput.min = '1';
  brushSizeInput.max = '500';
  brushSizeInput.style.cssText = `
    width: 60px;
    padding: 5px;
    border: 1px solid #2ecc71;
    border-radius: 4px;
    background: #151f28;
    color: white;
  `;

  const brushLabel = document.createElement('span');
  brushLabel.textContent = 'Tamanho:';
  brushLabel.style.cssText = `
    color: white;
    font-size: 14px;
  `;

  brushControls.appendChild(brushLabel);
  brushControls.appendChild(brushSlider);
  brushControls.appendChild(brushSizeInput);

  const cursorPreview = document.createElement('div');
  cursorPreview.style.cssText = `
    position: absolute;
    pointer-events: none;
    border: 2px solid white;
    border-radius: 50%;
    display: none;
    z-index: 1001;
  `;

  const buttonsContainer = document.createElement('div');
  buttonsContainer.style.cssText = `
    display: flex;
    gap: 10px;
    margin-top: 10px;
  `;

  const confirmButton = document.createElement('button');
  confirmButton.textContent = 'Confirmar';
  confirmButton.style.cssText = `
    padding: 10px 20px;
    background: #2ecc71;
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s;
  `;
  confirmButton.onmouseover = () => confirmButton.style.background = '#27ae60';
  confirmButton.onmouseout = () => confirmButton.style.background = '#2ecc71';

  const cancelButton = document.createElement('button');
  cancelButton.textContent = 'Cancelar';
  cancelButton.style.cssText = `
    padding: 10px 20px;
    background: #e74c3c;
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s;
  `;
  cancelButton.onmouseover = () => cancelButton.style.background = '#c0392b';
  cancelButton.onmouseout = () => cancelButton.style.background = '#e74c3c';

  const closeButton = document.createElement('button');
  closeButton.innerHTML = '×';
  closeButton.style.cssText = `
    position: absolute;
    right: 10px;
    top: 10px;
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    z-index: 1001;
  `;

   const canvasContainer = document.createElement('div');
  canvasContainer.style.cssText = `
    position: relative;
    display: inline-block;
  `;

  const eraserCanvasElement = document.createElement('canvas');
  eraserCanvasElement.id = 'modal-eraser-canvas';

  canvasContainer.appendChild(eraserCanvasElement);
  canvasContainer.appendChild(cursorPreview);
  canvasScrollContainer.appendChild(canvasContainer);
  modalContent.appendChild(closeButton);
  modalContent.appendChild(canvasScrollContainer);
  modalContent.appendChild(brushControls);
  buttonsContainer.appendChild(confirmButton);
  buttonsContainer.appendChild(cancelButton);
  modalContainer.appendChild(modalContent);
  modalContainer.appendChild(buttonsContainer);
  document.body.appendChild(modalContainer);

  const originalWidth = activeObject._element.naturalWidth || activeObject.width;
  const originalHeight = activeObject._element.naturalHeight || activeObject.height;

  const eraserCanvas = new fabric.Canvas('modal-eraser-canvas', {
    width: 790,   // Largura fixa do canvas
    height: 580,  // Altura fixa do canvas
    selection: false,
    preserveObjectStacking: true,
    enableRetinaScaling: true,
    imageSmoothingEnabled: true,
    imageSmoothingQuality: 'high'
});

  const containerWidth = canvasScrollContainer.clientWidth - 40;
  const containerHeight = canvasScrollContainer.clientHeight - 40;
  const initialZoom = Math.min(
    containerWidth / originalWidth,
    containerHeight / originalHeight
  );

  activeObject.clone((clonedObj) => {
    clonedObj.set({
      left: originalWidth / 2,
      top: originalHeight / 2,
      scaleX: 1,
      scaleY: 1,
      originX: 'center',
      originY: 'center',
      erasable: true
    });

    eraserCanvas.setZoom(initialZoom);
    eraserCanvas.absolutePan(new fabric.Point(
      (containerWidth - originalWidth * initialZoom) / 2 - 250,
      (containerHeight - originalHeight * initialZoom) / 2
    ));

    const saveToHistory = () => {
      if (currentHistoryIndex < MAX_HISTORY - 1) {
        eraserHistory = eraserHistory.slice(0, currentHistoryIndex + 1);

        clonedObj.clone((historyObj) => {
          currentHistoryIndex++;
          eraserHistory.push(historyObj);

          if (eraserHistory.length > MAX_HISTORY) {
            eraserHistory.shift();
            currentHistoryIndex--;
          }

          undoButton.disabled = currentHistoryIndex <= 0;
        });
      }
    };

    saveToHistory();

    eraserCanvas.add(clonedObj);
    eraserCanvas.setActiveObject(clonedObj);

    eraserCanvas.freeDrawingBrush = new fabric.EraserBrush(eraserCanvas);
    eraserCanvas.freeDrawingBrush.width = parseInt(brushSlider.value);
    eraserCanvas.isDrawingMode = true;

    eraserCanvas.on('mouse:up', () => {
      if (eraserCanvas.isDrawingMode) {
        saveToHistory();
      }
    });

    const undo = () => {
      if (currentHistoryIndex > 0) {
        currentHistoryIndex--;
        const previousState = eraserHistory[currentHistoryIndex];

        eraserCanvas.remove(clonedObj);
        previousState.clone((restoredObj) => {
          clonedObj = restoredObj;
          clonedObj.set({
            left: eraserCanvas.width / 2,
            top: eraserCanvas.height / 2,
            originX: 'center',
            originY: 'center',
            erasable: true
          });
          eraserCanvas.add(clonedObj);
          eraserCanvas.setActiveObject(clonedObj);
          eraserCanvas.renderAll();
        });

        undoButton.disabled = currentHistoryIndex <= 0;
      }
    };

    undoButton.addEventListener('click', undo);

    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'z') {
        undo();
        e.preventDefault();
      }
    });

    function updateBrushSize(size) {
      const intSize = Math.min(Math.max(parseInt(size), 1), 500);
      eraserCanvas.freeDrawingBrush.width = intSize;
      brushSlider.value = intSize;
      brushSizeInput.value = intSize;

      const zoom = eraserCanvas.getZoom();
      const adjustedSize = intSize * zoom;
      cursorPreview.style.width = adjustedSize + 'px';
      cursorPreview.style.height = adjustedSize + 'px';
    }

    brushSlider.addEventListener('input', (e) => {
      updateBrushSize(e.target.value);
    });

    brushSizeInput.addEventListener('input', (e) => {
      updateBrushSize(e.target.value);
    });

    brushSizeInput.addEventListener('blur', (e) => {
      updateBrushSize(e.target.value);
    });

    canvasContainer.addEventListener('mousemove', (e) => {
      const rect = canvasContainer.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const zoom = eraserCanvas.getZoom();
      const adjustedSize = eraserCanvas.freeDrawingBrush.width * zoom;

      cursorPreview.style.display = 'block';
      cursorPreview.style.left = (x - adjustedSize / 2) + 'px';
      cursorPreview.style.top = (y - adjustedSize / 2) + 'px';
      cursorPreview.style.width = adjustedSize + 'px';
      cursorPreview.style.height = adjustedSize + 'px';
    });

    canvasContainer.addEventListener('mouseleave', () => {
      cursorPreview.style.display = 'none';
    });

    eraserCanvas.on('mouse:wheel', (opt) => {
      const delta = opt.e.deltaY;
      let zoom = eraserCanvas.getZoom();
      zoom *= 0.999 ** delta;
      zoom = Math.min(Math.max(0.1, zoom), 4);
      const point = new fabric.Point(opt.e.offsetX, opt.e.offsetY);
      eraserCanvas.zoomToPoint(point, zoom);

      const adjustedSize = eraserCanvas.freeDrawingBrush.width * zoom;
      cursorPreview.style.width = adjustedSize + 'px';
      cursorPreview.style.height = adjustedSize + 'px';

      opt.e.preventDefault();
      opt.e.stopPropagation();
    });

    confirmButton.addEventListener('click', () => {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = originalWidth;
      tempCanvas.height = originalHeight;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.imageSmoothingEnabled = true;
      tempCtx.imageSmoothingQuality = 'high';

      const group = new fabric.Group([clonedObj], {
        originX: 'center',
        originY: 'center'
      });

      const sourceCanvas = group.toCanvasElement({
        multiplier: 1,
        width: originalWidth,
        height: originalHeight
      });

      tempCtx.drawImage(sourceCanvas, 0, 0);

      fabric.Image.fromURL(tempCanvas.toDataURL('image/png', 1.0), (newImg) => {
        newImg.set({
          ...originalProps,
          width: originalWidth,
          height: originalHeight
        });

        canvas.remove(activeObject);
        canvas.add(newImg);
        canvas.setActiveObject(newImg);
        canvas.requestRenderAll();

        tempCanvas.remove();
        sourceCanvas.remove();
        closeModal();
      }, { crossOrigin: 'anonymous' });
    });

    const closeModal = () => {
      eraserCanvas.dispose();
      document.body.removeChild(modalContainer);
    };

    closeButton.addEventListener('click', closeModal);
    cancelButton.addEventListener('click', closeModal);
    modalContainer.addEventListener('click', (e) => {
      if (e.target === modalContainer) {
        closeModal();
      }
    });

    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        closeModal();
        document.removeEventListener('keydown', handleEscape);
      }
    };
    document.addEventListener('keydown', handleEscape);
  });
});

// ------------ Pincel Pintar -----------------------------------
const paintButton = document.getElementById('paint-button');
paintButton.addEventListener('click', () => {
  const activeObject = canvas.getActiveObject();

  if (!activeObject) {
    showCustomAlert('Nenhuma imagem selecionada!');
    return;
  }

  const originalProps = {
    left: activeObject.left,
    top: activeObject.top,
    scaleX: activeObject.scaleX,
    scaleY: activeObject.scaleY,
    width: activeObject.width,
    height: activeObject.height,
    angle: activeObject.angle,
    originX: activeObject.originX,
    originY: activeObject.originY
  };

  let paintHistory = [];
  let currentHistoryIndex = -1;
  const MAX_HISTORY = 20;

  const modalContainer = document.createElement('div');
  modalContainer.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  `;

  const modalContent = document.createElement('div');
  modalContent.style.cssText = `
    background: #151f28;
    padding: 20px;
    border-radius: 8px;
    width: 800px;
    height: 600px;
    position: relative;
    margin-bottom: 20px;
    display: flex;
    flex-direction: column;
  `;

  // Create scrollable container for canvas
  const canvasScrollContainer = document.createElement('div');
  canvasScrollContainer.style.cssText = `
    flex: 1;
    overflow: auto;
    position: relative;
    margin-bottom: 20px;
  `;

const brushControls = document.createElement('div');
brushControls.style.cssText = `
  position: absolute;
  bottom: 20px;
  left: 20px;
  background-color: #151f28; /* Cor de fundo sólida */
  padding: 10px;
  border-radius: 4px;
  z-index: 1002;
  display: flex;
  align-items: center;
  gap: 10px;
`;

  const undoButton = document.createElement('button');
  undoButton.textContent = 'Voltar';
  undoButton.style.cssText = `
    padding: 5px 15px;
    background: #3498db;
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s;
    margin-right: 15px;
  `;
  undoButton.disabled = true;
  undoButton.onmouseover = () => undoButton.style.background = '#2980b9';
  undoButton.onmouseout = () => undoButton.style.background = '#3498db';

  brushControls.appendChild(undoButton);

  // Add color picker
  const colorPicker = document.createElement('input');
  colorPicker.type = 'color';
  colorPicker.value = '#000000';
  colorPicker.style.cssText = `
    width: 40px;
    height: 40px;
    padding: 0;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-right: 15px;
  `;

  brushControls.appendChild(colorPicker);

  const brushSlider = document.createElement('input');
  brushSlider.type = 'range';
  brushSlider.min = '1';
  brushSlider.max = '500';
  brushSlider.value = '20';
  brushSlider.style.cssText = `
    width: 150px;
    accent-color: #2ecc71;
  `;

  const brushSizeInput = document.createElement('input');
  brushSizeInput.type = 'number';
  brushSizeInput.value = '20';
  brushSizeInput.min = '1';
  brushSizeInput.max = '500';
  brushSizeInput.style.cssText = `
    width: 60px;
    padding: 5px;
    border: 1px solid #2ecc71;
    border-radius: 4px;
    background: #151f28;
    color: white;
  `;

  const brushLabel = document.createElement('span');
  brushLabel.textContent = 'Tamanho:';
  brushLabel.style.cssText = `
    color: white;
    font-size: 14px;
  `;

  brushControls.appendChild(brushLabel);
  brushControls.appendChild(brushSlider);
  brushControls.appendChild(brushSizeInput);

  const cursorPreview = document.createElement('div');
  cursorPreview.style.cssText = `
    position: absolute;
    pointer-events: none;
    border: 2px solid white;
    border-radius: 50%;
    display: none;
    z-index: 1001;
  `;

  // Add buttons container
  const buttonsContainer = document.createElement('div');
  buttonsContainer.style.cssText = `
    display: flex;
    gap: 10px;
    margin-top: 10px;
  `;

  const confirmButton = document.createElement('button');
  confirmButton.textContent = 'Confirmar';
  confirmButton.style.cssText = `
    padding: 10px 20px;
    background: #2ecc71;
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s;
  `;
  confirmButton.onmouseover = () => confirmButton.style.background = '#27ae60';
  confirmButton.onmouseout = () => confirmButton.style.background = '#2ecc71';

  const cancelButton = document.createElement('button');
  cancelButton.textContent = 'Cancelar';
  cancelButton.style.cssText = `
    padding: 10px 20px;
    background: #e74c3c;
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s;
  `;
  cancelButton.onmouseover = () => cancelButton.style.background = '#c0392b';
  cancelButton.onmouseout = () => cancelButton.style.background = '#e74c3c';

  const closeButton = document.createElement('button');
  closeButton.innerHTML = '×';
  closeButton.style.cssText = `
    position: absolute;
    right: 10px;
    top: 10px;
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    z-index: 1001;
  `;

  const canvasContainer = document.createElement('div');
  canvasContainer.style.cssText = `
    position: relative;
    display: inline-block;
  `;

  const paintCanvasElement = document.createElement('canvas');
  paintCanvasElement.id = 'modal-paint-canvas';

  canvasContainer.appendChild(paintCanvasElement);
  canvasContainer.appendChild(cursorPreview);
  canvasScrollContainer.appendChild(canvasContainer);
  modalContent.appendChild(closeButton);
  modalContent.appendChild(canvasScrollContainer);
  modalContent.appendChild(brushControls);
  buttonsContainer.appendChild(confirmButton);
  buttonsContainer.appendChild(cancelButton);
  modalContainer.appendChild(modalContent);
  modalContainer.appendChild(buttonsContainer);
  document.body.appendChild(modalContainer);

  // Get original image dimensions
  const originalWidth = activeObject._element.naturalWidth || activeObject.width;
  const originalHeight = activeObject._element.naturalHeight || activeObject.height;

const paintCanvas = new fabric.Canvas('modal-paint-canvas', {
    width: 790,  
    height: 580, 
    selection: false,
    preserveObjectStacking: true,
    enableRetinaScaling: true,
    imageSmoothingEnabled: true,
    imageSmoothingQuality: 'high'
});

  const containerWidth = canvasScrollContainer.clientWidth - 0; // Account for padding
  const containerHeight = canvasScrollContainer.clientHeight - 0;
  const initialZoom = Math.min(
    containerWidth / originalWidth,
    containerHeight / originalHeight
  );

  activeObject.clone((clonedObj) => {
    clonedObj.set({
      left: originalWidth / 2,
      top: originalHeight / 2,
      scaleX: 1,
      scaleY: 1,
      originX: 'center',
      originY: 'center'
    });

    paintCanvas.setZoom(initialZoom);
    paintCanvas.absolutePan(new fabric.Point(
      (containerWidth - originalWidth * initialZoom) / 2- 250,
      (containerHeight - originalHeight * initialZoom) / 2
    ));

    const saveToHistory = () => {
      if (currentHistoryIndex < MAX_HISTORY - 1) {
        paintHistory = paintHistory.slice(0, currentHistoryIndex + 1);
        
        const json = JSON.stringify(paintCanvas.toJSON(['selectable']));
        currentHistoryIndex++;
        paintHistory.push(json);

        if (paintHistory.length > MAX_HISTORY) {
          paintHistory.shift();
          currentHistoryIndex--;
        }

        undoButton.disabled = currentHistoryIndex <= 0;
      }
    };

    paintCanvas.add(clonedObj);
    clonedObj.moveTo(0);
    paintCanvas.setActiveObject(clonedObj);
	
	requestAnimationFrame(() => {
      saveToHistory();
      
      paintCanvas.freeDrawingBrush = new fabric.PencilBrush(paintCanvas);
      paintCanvas.freeDrawingBrush.width = parseInt(brushSlider.value);
      paintCanvas.freeDrawingBrush.color = colorPicker.value;
      paintCanvas.isDrawingMode = true;
    });

    paintCanvas.on('mouse:up', () => {
      if (paintCanvas.isDrawingMode) {
        saveToHistory();
      }
    });
	
	paintCanvas.on('object:added', (e) => {
      if (e.target !== clonedObj && e.target.type === 'path') {
        e.target.moveTo(paintCanvas.getObjects().length); 
      }
    });

    const undo = () => {
      if (currentHistoryIndex > 0) {
        currentHistoryIndex--;
        const previousState = JSON.parse(paintHistory[currentHistoryIndex]);
        
        paintCanvas.clear();
        paintCanvas.loadFromJSON(previousState, () => {
          const objects = paintCanvas.getObjects();
          if (objects.length > 0) {
            const baseImage = objects[0];
            baseImage.selectable = true;
            paintCanvas.setActiveObject(baseImage);
          }
          paintCanvas.renderAll();
        });

        undoButton.disabled = currentHistoryIndex <= 0;
      }
    };
	
    undoButton.addEventListener('click', undo);

    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'z') {
        undo();
        e.preventDefault();
      }
    });

    function updateBrushSize(size) {
      const intSize = Math.min(Math.max(parseInt(size), 1), 500);
      paintCanvas.freeDrawingBrush.width = intSize;
      brushSlider.value = intSize;
      brushSizeInput.value = intSize;

      const zoom = paintCanvas.getZoom();
      const adjustedSize = intSize * zoom;
      cursorPreview.style.width = adjustedSize + 'px';
      cursorPreview.style.height = adjustedSize + 'px';
    }

    // Color picker event listener
    colorPicker.addEventListener('input', (e) => {
      paintCanvas.freeDrawingBrush.color = e.target.value;
      cursorPreview.style.borderColor = e.target.value;
    });

    brushSlider.addEventListener('input', (e) => {
      updateBrushSize(e.target.value);
    });

    brushSizeInput.addEventListener('input', (e) => {
      updateBrushSize(e.target.value);
    });

    brushSizeInput.addEventListener('blur', (e) => {
      updateBrushSize(e.target.value);
    });

    canvasContainer.addEventListener('mousemove', (e) => {
      const rect = canvasContainer.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const zoom = paintCanvas.getZoom();
      const adjustedSize = paintCanvas.freeDrawingBrush.width * zoom;

      cursorPreview.style.display = 'block';
      cursorPreview.style.left = (x - adjustedSize / 2) + 'px';
      cursorPreview.style.top = (y - adjustedSize / 2) + 'px';
      cursorPreview.style.width = adjustedSize + 'px';
      cursorPreview.style.height = adjustedSize + 'px';
      cursorPreview.style.borderColor = colorPicker.value;
    });

    canvasContainer.addEventListener('mouseleave', () => {
      cursorPreview.style.display = 'none';
    });

    paintCanvas.on('mouse:wheel', (opt) => {
      const delta = opt.e.deltaY;
      let zoom = paintCanvas.getZoom();
      zoom *= 0.999 ** delta;
      zoom = Math.min(Math.max(0.1, zoom), 4);
      const point = new fabric.Point(opt.e.offsetX, opt.e.offsetY);
      paintCanvas.zoomToPoint(point, zoom);

      const adjustedSize = paintCanvas.freeDrawingBrush.width * zoom;
      cursorPreview.style.width = adjustedSize + 'px';
      cursorPreview.style.height = adjustedSize + 'px';

      opt.e.preventDefault();
      opt.e.stopPropagation();
    });

   confirmButton.addEventListener('click', () => {
      // Create a new canvas with original dimensions
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = originalWidth;
      tempCanvas.height = originalHeight;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.imageSmoothingEnabled = true;
      tempCtx.imageSmoothingQuality = 'high';

      // Create group with all elements at original scale
      const group = new fabric.Group([
        clonedObj,
        ...paintCanvas.getObjects().filter(obj => obj !== clonedObj)
      ], {
        originX: 'center',
        originY: 'center'
      });

      // Render at original size
      const sourceCanvas = group.toCanvasElement({
        multiplier: 1,
        width: originalWidth,
        height: originalHeight
      });

  tempCtx.drawImage(sourceCanvas, 0, 0);

      // Create new image maintaining original properties
      fabric.Image.fromURL(tempCanvas.toDataURL('image/png', 1.0), (newImg) => {
        newImg.set({
          ...originalProps,
          width: originalWidth,
          height: originalHeight
        });

        canvas.remove(activeObject);
        canvas.add(newImg);
        canvas.setActiveObject(newImg);
        canvas.requestRenderAll();

        tempCanvas.remove();
        sourceCanvas.remove();
        closeModal();
      }, { crossOrigin: 'anonymous' });
    });

    const closeModal = () => {
      paintCanvas.dispose();
      document.body.removeChild(modalContainer);
    };

    closeButton.addEventListener('click', closeModal);
    cancelButton.addEventListener('click', closeModal);
    modalContainer.addEventListener('click', (e) => {
      if (e.target === modalContainer) {
        closeModal();
      }
    });

    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        closeModal();
        document.removeEventListener('keydown', handleEscape);
      }
    };
    document.addEventListener('keydown', handleEscape);
  });
});


// ------------------- mesclagem -----------------------

const createNumberMergingModal = () => {
  // Create modal container
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0,0,0,0.9);
    z-index: 9999;
    display: flex;
    justify-content: center;
    align-items: center;
  `;

  // Create iframe
  const iframe = document.createElement('iframe');
  iframe.src = 'https://nkmplay.github.io/cgf/teste/index.html';
  iframe.style.cssText = `
    width: 95%;
    height: 95%;
    border: none;
    background: white;
  `;

  // Create close button
  const closeButton = document.createElement('button');
  closeButton.textContent = '×';
  closeButton.style.cssText = `
    position: absolute;
    top: 10px;
    right: 10px;
    background: red;
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 24px;
    cursor: pointer;
    z-index: 10000;
  `;

  // Close modal when button is clicked
  closeButton.addEventListener('click', () => {
    document.body.removeChild(modal);
  });

  // Append elements
  modal.appendChild(iframe);
  modal.appendChild(closeButton);
  document.body.appendChild(modal);
};

// Add event listener to the "Mesclagem de Números" button
document.getElementById('MesclarBtn').addEventListener('click', createNumberMergingModal);

// ---------------------- Botão ver detalhes do objeto (Imagem/Texto) ----------------------
const imageDetailsModal = document.getElementById('cloudphoto-image-details-modal');
const imageDetailsContent = document.getElementById('cloudphoto-image-details-content');
const modalClose = document.querySelector('.cloudphoto-modal-close');
const btnDados = document.getElementById('BtnDados');

function getImageOrigin(image) {
    if (image.src && image.src.startsWith('blob:')) return 'Blob URL';
    if (image.src && image.src.startsWith('data:')) return 'Base64 Data URL';
    if (image.src) return 'URL';
    return 'Desconhecido';
}

function showObjectDetails(activeObject) {
    if (!activeObject) return;

    let details = {};

    if (activeObject.type === 'image') {
        function getImageDetails(image) {
            // Fabric.js specific properties
            if (image._originalElement) {
                return {
                    origin: 'Fabric.js Canvas',
                    sourceType: image._originalElement.src ? 'Carregado' : 'Criado no Canvas',
                    sourceDetails: image._originalElement.src || 'Elemento criado diretamente no canvas'
                };
            }
            // Fallback detection
            if (image.src) {
                if (image.src.startsWith('blob:')) return {
                    origin: 'Blob URL',
                    sourceType: 'Blob',
                    sourceDetails: image.src
                };
                if (image.src.startsWith('data:')) return {
                    origin: 'Base64 Data URL',
                    sourceType: 'Base64',
                    sourceDetails: `${image.src.substring(0, 50)}... (truncado)`
                };
                return {
                    origin: 'URL ou Fonte',
                    sourceType: 'URL',
                    sourceDetails: image.src
                };
            }
            return {
                origin: 'Desconhecido',
                sourceType: 'Não identificado',
                sourceDetails: 'Sem informações de origem'
            };
        }

        const imageInfo = getImageDetails(activeObject);
        details = {
            'Tipo': 'Imagem',
            'Nome do Arquivo': activeObject.fileName || 'Sem nome',
            'Dimensões': `${Math.round(activeObject.width)} x ${Math.round(activeObject.height)} px`,
            'Origem': imageInfo.origin,
            'Tipo de Fonte': imageInfo.sourceType,
            'Detalhes da Fonte': imageInfo.sourceDetails,
            'Escala': `${(activeObject.scaleX * 100).toFixed(2)}%`,
            'Rotação': `${(activeObject.angle || 0).toFixed(2)}°`,
            'Posição': `X: ${Math.round(activeObject.left)}, Y: ${Math.round(activeObject.top)}`
        };
    } else if (activeObject.type === 'textbox') {
        details = {
            'Tipo': 'Texto',
            'Conteúdo': activeObject.text,
            'Fonte': activeObject.fontFamily,
            'Tamanho': `${activeObject.fontSize}px`,
            'Cor': activeObject.fill,
            'Alinhamento': activeObject.textAlign,
            'Estilo': [
                activeObject.fontWeight === 'bold' ? 'Negrito' : '',
                activeObject.fontStyle === 'italic' ? 'Itálico' : '',
                activeObject.underline ? 'Sublinhado' : ''
            ].filter(Boolean).join(', ') || 'Normal',
            'Dimensões': `${Math.round(activeObject.width)} x ${Math.round(activeObject.height)} px`,
            'Escala': `${(activeObject.scaleX * 100).toFixed(2)}%`,
            'Rotação': `${(activeObject.angle || 0).toFixed(2)}°`,
            'Posição': `X: ${Math.round(activeObject.left)}, Y: ${Math.round(activeObject.top)}`
        };
    }

    imageDetailsContent.textContent = Object.entries(details)
        .map(([key, value]) => `${key}: ${value}`)
        .join('\n');
    imageDetailsModal.style.display = 'flex';
}

btnDados.onclick = () => {
    const activeObject = canvas.getActiveObject();
    showObjectDetails(activeObject);
};

modalClose.onclick = () => {
    imageDetailsModal.style.display = 'none';
};

canvas.on('selection:created', opt => {
    const activeObject = opt.target;
    if ((activeObject?.type === 'image' || activeObject?.type === 'textbox') && 
        imageDetailsModal.style.display === 'flex') {
        showObjectDetails(activeObject);
    }
});

canvas.on('selection:updated', opt => {
    const activeObject = opt.target;
    if ((activeObject?.type === 'image' || activeObject?.type === 'textbox') && 
        imageDetailsModal.style.display === 'flex') {
        showObjectDetails(activeObject);
    }
});
	
	
// -------------- Brilho Contraste Saturação --------------------------
      document.getElementById('filtroscorBtn').addEventListener('click', () => {
        const style = document.createElement('style');
        style.innerHTML = `
#imageAdjustModal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #151f28;
  width: 800px;
  height: 600px;
  border-radius: 12px;
  border: 1px solid #4a90e2;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  color: white;
  font-family: Arial, sans-serif;
  z-index: 1000;
  display: flex;
  overflow: hidden;
}

.preview-container {
  flex: 1;
  background: #1a2634;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px;
  border-right: 1px solid rgba(74, 144, 226, 0.3);
  min-height: 400px;
  position: relative;
}

#previewCanvas {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  display: block;
}

.controls-container {
  width: 280px;
  padding: 20px;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
}

.controls-title {
  font-size: 18px;
  color: white;
  margin-bottom: 24px;
  font-weight: 500;
}

.modal-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 16px;
  overflow-y: auto;
  padding-right: 8px;
  width: 100%;
  box-sizing: border-box;
}

.modal-content::-webkit-scrollbar {
  width: 4px;
}

.modal-content::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
}

.modal-content::-webkit-scrollbar-thumb {
  background: #4a90e2;
  border-radius: 2px;
}

.modal-row {
  display: flex;
  flex-direction: column;
  gap: 6px;
  width: 100%;
  box-sizing: border-box;
}

.modal-row label {
  font-size: 13px;
  color: #4a90e2;
  font-weight: 500;
  white-space: nowrap;
}

.slider-container {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  box-sizing: border-box;
}

.modal-row input[type="range"] {
  flex: 1;
  width: calc(100% - 50px);
  min-width: 0;
}

.modal-row input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: white;
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid #4a90e2;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.modal-row span {
  min-width: 40px;
  text-align: right;
  font-size: 12px;
  color: white;
  font-variant-numeric: tabular-nums;
  flex-shrink: 0;
}

.modal-buttons {
  display: flex;
  gap: 12px;
  margin-top: 24px;
}

.modal-buttons button {
  flex: 1;
  padding: 12px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.save-button {
  background-color: #4a90e2;
  color: white;
}

.save-button:hover {
  background-color: #357abd;
  transform: translateY(-1px);
}

.cancel-button {
  background-color: #1a2634;
  color: white;
  border: 1px solid rgba(74, 144, 226, 0.5);
}

.cancel-button:hover {
  background-color: #1f2f3d;
  transform: translateY(-1px);
}

.processing-message {
  color: #4a90e2;
  font-size: 13px;
  text-align: center;
  margin-top: 12px;
  min-height: 20px;
}
        `;
        document.head.appendChild(style);

        let modal = document.getElementById('imageAdjustModal');
        let selectedImage = null;
        let previewCanvas = null;
        let previewContext = null;
        let currentImage = null;

        if (!modal) {
          modal = document.createElement('div');
          modal.id = 'imageAdjustModal';
          modal.innerHTML = `
            <div class="preview-container" id="previewContainer">
              <!-- The preview canvas will be created dynamically -->
            </div>
            <div class="controls-container">
              <div class="controls-title">Ajustes de Imagem</div>
              <div class="modal-content">
                <div class="modal-row">
                  <label>Brilho</label>
                  <div class="slider-container">
                    <input type="range" id="brightnessSlider" min="-100" max="100" value="0">
                    <span id="brightnessValue">0%</span>
                  </div>
                </div>
                <div class="modal-row">
                  <label>Contraste</label>
                  <div class="slider-container">
                    <input type="range" id="contrastSlider" min="-100" max="100" value="0">
                    <span id="contrastValue">0%</span>
                  </div>
                </div>
                <div class="modal-row">
                  <label>Saturação</label>
                  <div class="slider-container">
                    <input type="range" id="saturationSlider" min="-100" max="100" value="0">
                    <span id="saturationValue">0%</span>
                  </div>
                </div>
                <div class="modal-row">
                  <label>Matiz</label>
                  <div class="slider-container">
                    <input type="range" id="hueSlider" min="-180" max="180" value="0">
                    <span id="hueValue">0°</span>
                  </div>
                </div>
              </div>
              <div class="processing-message" id="processingMessage"></div>
              <div class="modal-buttons">
                <button class="save-button" id="saveAdjustments">Salvar</button>
                <button class="cancel-button" id="cancelAdjustments">Cancelar</button>
              </div>
            </div>
          `;
          document.body.appendChild(modal);
        }

        // Create a new preview canvas each time to avoid residual sizes or distortions.
        function createPreviewCanvas() {
          const container = document.getElementById('previewContainer');
          if (!container) return;
          
          // Remove any existing canvas
          container.innerHTML = '';
          
          // Create new canvas
          previewCanvas = document.createElement('canvas');
          previewCanvas.id = 'previewCanvas';
          container.appendChild(previewCanvas);
          previewContext = previewCanvas.getContext('2d');
        }

        function initPreviewCanvas(fabricImage) {
          if (!fabricImage) return;
          
          // Ensure the container exists
          const container = document.getElementById('previewContainer');
          if (!container) return;
          
          // Create new canvas
          createPreviewCanvas();
          
          if (!previewCanvas || !previewContext) {
            console.error('Failed to create preview canvas');
            return;
          }

          // Get the original dimensions from the fabric image element
          const originalWidth = fabricImage._element.naturalWidth;
          const originalHeight = fabricImage._element.naturalHeight;
          
          // Get container dimensions
          const containerStyle = window.getComputedStyle(container);
          const maxWidth = container.clientWidth - 
            (parseFloat(containerStyle.paddingLeft) + parseFloat(containerStyle.paddingRight));
          const maxHeight = container.clientHeight - 
            (parseFloat(containerStyle.paddingTop) + parseFloat(containerStyle.paddingBottom));
          
          // Calculate scale to fit container while maintaining aspect ratio
          const scaleWidth = maxWidth / originalWidth;
          const scaleHeight = maxHeight / originalHeight;
          const scale = Math.min(scaleWidth, scaleHeight);
          
          // Set dimensions maintaining aspect ratio
          previewCanvas.width = Math.round(originalWidth * scale);
          previewCanvas.height = Math.round(originalHeight * scale);
          
          // Create new image for preview
          const previewImg = new Image();
          previewImg.crossOrigin = 'anonymous';
          
          previewImg.onload = () => {
            if (!previewContext || !previewCanvas) {
              console.error('Preview context or canvas is null');
              return;
            }
            
            // Store the original image for reference
            currentImage = previewImg;
            
            // Clear and draw the image
            previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewContext.drawImage(previewImg, 0, 0, previewCanvas.width, previewCanvas.height);
            
            // Apply any existing filters
            applyFilters();
          };
          
          previewImg.onerror = (err) => {
            console.error('Erro ao carregar imagem para preview:', err);
            showCustomAlert('Erro ao carregar preview da imagem');
          };
          
          // Set the source image with error handling
          try {
            if (fabricImage._element && fabricImage._element.src) {
              previewImg.src = fabricImage._element.src;
            } else if (fabricImage.toDataURL) {
              previewImg.src = fabricImage.toDataURL();
            } else {
              throw new Error('No valid image source found');
            }
          } catch (error) {
            console.error('Error setting image source:', error);
            showCustomAlert('Erro ao configurar fonte da imagem');
          }
        }

        function resetPreviewCanvas() {
          if (previewCanvas) {
            const container = document.getElementById('previewContainer');
            if (container) {
              container.innerHTML = '';
            }
            previewContext = null;
            previewCanvas = null;
            currentImage = null;
          }
        }

        function applyFilters() {
          if (!currentImage || !previewContext || !previewCanvas) return;
          const brightness = parseInt(document.getElementById('brightnessSlider').value);
          const contrast = parseInt(document.getElementById('contrastSlider').value);
          const saturation = parseInt(document.getElementById('saturationSlider').value);
          const hue = parseInt(document.getElementById('hueSlider').value);
          previewContext.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
          previewContext.filter = `
            brightness(${100 + brightness}%)
            contrast(${100 + contrast}%)
            saturate(${100 + saturation}%)
            hue-rotate(${hue}deg)
          `;
          previewContext.drawImage(currentImage, 0, 0, previewCanvas.width, previewCanvas.height);
        }

        async function applyChangesToOriginalImage() {
          if (!selectedImage) return;
          const processingMessage = document.getElementById('processingMessage');
          processingMessage.textContent = 'Processando imagem...';
          const originalProps = {
            scaleX: selectedImage.scaleX,
            scaleY: selectedImage.scaleY,
            angle: selectedImage.angle,
            left: selectedImage.left,
            top: selectedImage.top,
            flipX: selectedImage.flipX,
            flipY: selectedImage.flipY,
            originX: selectedImage.originX,
            originY: selectedImage.originY,
            objectIndex: canvas.getObjects().indexOf(selectedImage)
          };
          try {
            const tempCanvas = document.createElement('canvas');
            const scaleFactor = Math.min(1, 4096 / selectedImage.width);
            tempCanvas.width = selectedImage.width * scaleFactor;
            tempCanvas.height = selectedImage.height * scaleFactor;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.filter = getCurrentFilters();
            tempCtx.drawImage(selectedImage.getElement(), 0, 0, tempCanvas.width, tempCanvas.height);
            const newImg = await createFabricImage(tempCanvas, originalProps);
            replaceOriginalImage(newImg, originalProps.objectIndex);
            hideImageAdjustModal();
          } catch (error) {
            console.error('Erro:', error);
            processingMessage.textContent = 'Erro ao processar imagem';
          }
        }

        async function createFabricImage(canvasElem, props) {
          return new Promise((resolve, reject) => {
            canvasElem.toBlob(blob => {
              const url = URL.createObjectURL(blob);
              fabric.Image.fromURL(url, img => {
                img.set({
                  ...props,
                  width: canvasElem.width,
                  height: canvasElem.height,
                  scaleX: props.scaleX * (selectedImage.width / canvasElem.width),
                  scaleY: props.scaleY * (selectedImage.height / canvasElem.height)
                });
                resolve(img);
              }, { crossOrigin: 'anonymous' });
            }, 'image/png', 0.9);
          });
        }

        function replaceOriginalImage(newImg, originalIndex) {
          canvas.remove(selectedImage);
          if (originalIndex >= 0 && originalIndex < canvas.getObjects().length) {
            canvas.insertAt(newImg, originalIndex);
          } else {
            canvas.add(newImg);
          }
          canvas.setActiveObject(newImg);
          canvas.requestRenderAll();
          selectedImage = newImg;
        }

        function getCurrentFilters() {
          const brightness = parseInt(document.getElementById('brightnessSlider').value);
          const contrast = parseInt(document.getElementById('contrastSlider').value);
          const saturation = parseInt(document.getElementById('saturationSlider').value);
          const hue = parseInt(document.getElementById('hueSlider').value);
          return `
            brightness(${100 + brightness}%)
            contrast(${100 + contrast}%)
            saturate(${100 + saturation}%)
            hue-rotate(${hue}deg)
          `;
        }

        function showImageAdjustModal() {
          modal.style.display = 'flex';
          if (selectedImage) {
            resetPreviewCanvas();
            updateSliders(selectedImage);
            setTimeout(() => {
              initPreviewCanvas(selectedImage);
            }, 50);
          }
        }

        function hideImageAdjustModal() {
          modal.style.display = 'none';
          resetPreviewCanvas();
        }

        function updateSliders(image) {
          const sliders = ['brightness', 'contrast', 'saturation', 'hue'];
          sliders.forEach(type => {
            const slider = document.getElementById(`${type}Slider`);
            const value = document.getElementById(`${type}Value`);
            slider.value = 0;
            value.textContent = type === 'hue' ? '0°' : '0%';
          });
        }

        function createSliderHandler() {
          return (e) => {
            const valueId = e.target.id.replace('Slider', 'Value');
            const isHue = e.target.id === 'hueSlider';
            document.getElementById(valueId).textContent = `${e.target.value}${isHue ? '°' : '%'}`;
            applyFilters();
          };
        }
        ['brightness', 'contrast', 'saturation', 'hue'].forEach(type => {
          document.getElementById(`${type}Slider`).addEventListener('input', createSliderHandler());
        });
        document.getElementById('saveAdjustments').addEventListener('click', applyChangesToOriginalImage);
        document.getElementById('cancelAdjustments').addEventListener('click', hideImageAdjustModal);

        canvas.on('selection:cleared', () => {
          selectedImage = null;
          resetPreviewCanvas();
          hideImageAdjustModal();
        });
        canvas.on('selection:created', (e) => {
          if (e.target && e.target.type === 'image') {
            selectedImage = e.target;
            resetPreviewCanvas();
            updateSliders(selectedImage);
            setTimeout(() => { initPreviewCanvas(selectedImage); }, 0);
            showImageAdjustModal();
          }
        });
        canvas.on('selection:updated', (e) => {
          if (e.target && e.target.type === 'image') {
            selectedImage = e.target;
            resetPreviewCanvas();
            updateSliders(selectedImage);
            setTimeout(() => { initPreviewCanvas(selectedImage); }, 0);
            showImageAdjustModal();
          }
        });
        let resizeTimeout;
        window.addEventListener('resize', () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => { if (selectedImage && modal.style.display === 'flex') initPreviewCanvas(selectedImage); }, 250);
        });
        const activeObject = canvas.getActiveObject();
        if (activeObject && activeObject.type === 'image') {
          selectedImage = activeObject;
          updateSliders(selectedImage);
          initPreviewCanvas(selectedImage);
          showImageAdjustModal();
        } else {
          showCustomAlert('Selecione uma imagem para ajustar.');
        }
      });
      // -------------- Fim Brilho Contraste Saturação --------------------------

// ----------- balde --------------------
document.getElementById('btnBalde').addEventListener('click', () => {
  const activeObject = canvas.getActiveObject();

  if (!activeObject || activeObject.type !== 'image') {
    showCustomAlert('Selecione uma imagem para usar a ferramenta de balde.');
    return;
  }

  // Cria o modal
  const modalOverlay = document.createElement('div');
  modalOverlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  `;

  const modalContent = document.createElement('div');
  modalContent.style.cssText = `
    background: #151f28;
    border-radius: 8px;
    padding: 20px;
    width: 700px;
    height: 600px;
    display: flex;
    flex-direction: column;
    gap: 20px;
  `;

  // Container para a imagem
  const imageContainer = document.createElement('div');
  imageContainer.style.cssText = `
    flex: 1;
    overflow: hidden;
    position: relative;
    border: 1px solid #4a90e2;
    border-radius: 4px;
  `;

  // Criar novo canvas para edição
  const editCanvas = document.createElement('canvas');
  const ctx = editCanvas.getContext('2d');
  const img = activeObject.getElement();

  // Configura o tamanho original do canvas
  editCanvas.width = img.width;
  editCanvas.height = img.height;

  // Desenha a imagem original
  ctx.drawImage(img, 0, 0, img.width, img.height);

  // Ajusta o estilo do canvas para caber no container
  editCanvas.style.cssText = `
    max-width: 100%;
    max-height: 100%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  `;

  // Controles
  const controls = document.createElement('div');
  controls.style.cssText = `
    display: flex;
    gap: 15px;
    align-items: center;
    padding: 10px;
  `;

  const sliderContainer = document.createElement('div');
  sliderContainer.style.cssText = `
    display: flex;
    align-items: center;
    gap: 10px;
    flex: 1;
  `;

  const slider = document.createElement('input');
  slider.type = 'range';
  slider.min = '0';
  slider.max = '100';
  slider.value = '50';
  slider.style.cssText = `
    flex: 1;
    accent-color: #4a90e2;
  `;

  const input = document.createElement('input');
  input.type = 'number';
  input.value = '50';
  input.min = '0';
  input.max = '100';
  input.style.cssText = `
    width: 60px;
    padding: 5px;
    border: 1px solid #4a90e2;
    border-radius: 4px;
    background: #151f28;
    color: white;
  `;

  const colorPicker = document.createElement('input');
  colorPicker.type = 'color';
  colorPicker.value = 'black';
  colorPicker.style.cssText = `
    width: 40px;
    height: 40px;
    padding: 0;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  `;

  // Botões
  const buttonContainer = document.createElement('div');
  buttonContainer.style.cssText = `
    display: flex;
    gap: 10px;
    justify-content: flex-end;
  `;

  const undoButton = document.createElement('button');
  undoButton.textContent = 'Voltar';
  undoButton.style.cssText = `
    padding: 10px 20px;
    background: #e74c3c;
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
    font-size: 14px;
  `;

  const cancelButton = document.createElement('button');
  cancelButton.textContent = 'Cancelar';
  cancelButton.style.cssText = `
    padding: 10px 20px;
    background: #e74c3c;
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
    font-size: 14px;
  `;

  const saveButton = document.createElement('button');
  saveButton.textContent = 'Salvar';
  saveButton.style.cssText = `
    padding: 10px 20px;
    background: #2ecc71;
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
    font-size: 14px;
  `;

  // Monta a estrutura do modal
  sliderContainer.appendChild(slider);
  sliderContainer.appendChild(input);
  controls.appendChild(undoButton);
  controls.appendChild(sliderContainer);
  controls.appendChild(colorPicker);

  buttonContainer.appendChild(cancelButton);
  buttonContainer.appendChild(saveButton);

  imageContainer.appendChild(editCanvas);
  modalContent.appendChild(imageContainer);
  modalContent.appendChild(controls);
  modalContent.appendChild(buttonContainer);
  modalOverlay.appendChild(modalContent);
  document.body.appendChild(modalOverlay);

  // Sincroniza slider com input
  slider.addEventListener('input', () => input.value = slider.value);
  input.addEventListener('input', () => slider.value = input.value);

  // Função de flood fill
  function floodFill(canvas, startX, startY, color, tolerance) {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const pixels = imageData.data;

    const startPos = (startY * canvas.width + startX) * 4;
    const startR = pixels[startPos];
    const startG = pixels[startPos + 1];
    const startB = pixels[startPos + 2];

    const fillR = parseInt(color.slice(1, 3), 16);
    const fillG = parseInt(color.slice(3, 5), 16);
    const fillB = parseInt(color.slice(5, 7), 16);

    const toleranceLevel = tolerance * 255;

    function matchesColor(pos) {
      return (
        Math.abs(pixels[pos] - startR) <= toleranceLevel &&
        Math.abs(pixels[pos + 1] - startG) <= toleranceLevel &&
        Math.abs(pixels[pos + 2] - startB) <= toleranceLevel
      );
    }

    const stack = [[startX, startY]];
    const visited = new Set();

    while (stack.length) {
      const [x, y] = stack.pop();
      const pos = (y * canvas.width + x) * 4;

      if (
        x < 0 || x >= canvas.width ||
        y < 0 || y >= canvas.height ||
        visited.has(`${x},${y}`) ||
        !matchesColor(pos)
      ) {
        continue;
      }

      visited.add(`${x},${y}`);

      pixels[pos] = fillR;
      pixels[pos + 1] = fillG;
      pixels[pos + 2] = fillB;

      stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
    }

    ctx.putImageData(imageData, 0, 0);
  }

  // Sistema de histórico melhorado
  let history = [];
  let currentHistoryIndex = -1;

  // Função para salvar estado atual no histórico
  function saveToHistory() {
    // Remove estados futuros se houver (caso tenha feito undo e depois uma nova ação)
    history = history.slice(0, currentHistoryIndex + 1);
    
    // Adiciona novo estado
    history.push(editCanvas.toDataURL());
    currentHistoryIndex++;
  }

  // Salva o estado inicial
  saveToHistory();

  // Adiciona evento de clique no canvas
  editCanvas.addEventListener('click', (e) => {
    const rect = editCanvas.getBoundingClientRect();
    const scaleX = editCanvas.width / rect.width;
    const scaleY = editCanvas.height / rect.height;

    const x = Math.floor((e.clientX - rect.left) * scaleX);
    const y = Math.floor((e.clientY - rect.top) * scaleY);

    // Salva o estado atual antes de aplicar o flood fill
    saveToHistory();

    // Aplica o flood fill
    floodFill(editCanvas, x, y, colorPicker.value, parseInt(slider.value) / 100);
  });

  // Eventos dos botões
  undoButton.addEventListener('click', () => {
    if (currentHistoryIndex > 0) {
      currentHistoryIndex--;
      const previousState = history[currentHistoryIndex];
      const img = new Image();
      img.src = previousState;
      img.onload = () => {
        ctx.clearRect(0, 0, editCanvas.width, editCanvas.height);
        ctx.drawImage(img, 0, 0);
      };
    }
  });

  cancelButton.addEventListener('click', () => {
    document.body.removeChild(modalOverlay);
  });

  saveButton.addEventListener('click', () => {
    // Cria nova imagem com o resultado
    fabric.Image.fromURL(editCanvas.toDataURL(), (img) => {
      img.set({
        left: activeObject.left,
        top: activeObject.top,
        scaleX: activeObject.scaleX,
        scaleY: activeObject.scaleY,
        angle: activeObject.angle,
        flipX: activeObject.flipX,
        flipY: activeObject.flipY,
        originX: activeObject.originX,
        originY: activeObject.originY
      });

      canvas.remove(activeObject);
      canvas.add(img);
      canvas.setActiveObject(img);
      canvas.requestRenderAll();

      document.body.removeChild(modalOverlay);
    });
  });
});
// ----------- fim balde --------------------

// ------------------- remover cor ao clique e cor total --------------------------
function initializeColorRemoval() {
    const style = `
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-container {
            background-color: white;
            width: 800px;
            height: 600px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-content {
			flex: 1;
			position: relative;
			overflow: hidden;
			background-color: #151f28;
		}

        .modal-canvas-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-controls {
            padding: 16px;
            background-color: #f8f9fa;
            border-top: 1px solid #dee2e6;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .modal-slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .modal-slider-container input[type="range"] {
            width: 150px;
        }

        .modal-buttons {
            display: flex;
            gap: 8px;
        }

        .modal-btn {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .modal-btn-primary {
            background-color: #4a90e2;
            color: white;
        }

        .modal-btn-secondary {
            background-color: #6c757d;
            color: white;
        }

        .modal-btn:hover {
            opacity: 0.9;
        }

        .modal-removal-type {
            display: flex;
            gap: 8px;
            margin-right: 16px;
        }
    `;

    const styleSheet = document.createElement("style");
    styleSheet.type = "text/css";
    styleSheet.innerText = style;
    document.head.appendChild(styleSheet);

    const modalHTML = `
        <div id="colorRemovalModal" class="modal-overlay">
            <div class="modal-container">
                <div class="modal-content">
                    <div class="modal-canvas-container">
                        <canvas id="modalCanvas"></canvas>
                    </div>
                </div>
                <div class="modal-controls">
                    <div class="modal-removal-type">
                        <button id="modal-click-removal" class="modal-btn modal-btn-primary">Remover por Clique</button>
                        <button id="modal-total-removal" class="modal-btn modal-btn-secondary">Remover Total</button>
                    </div>
                    <div class="modal-slider-container">
                        <label for="modal-detection-level">Sensibilidade:</label>
                        <input type="range" id="modal-detection-level" min="1" max="200" value="30">
                        <span id="modal-slider-value">30</span>
                        <button id="modal-undo-btn" class="modal-btn modal-btn-secondary">Desfazer</button>
                    </div>
                    <div class="modal-buttons">
                        <button id="modal-save-btn" class="modal-btn modal-btn-primary">Salvar</button>
                        <button id="modal-cancel-btn" class="modal-btn modal-btn-secondary">Cancelar</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHTML);

    let modalFabricCanvas = null;
    let originalImage = null;
    let tolerance = 30;
    let isColorRemovalActive = true;
    let isTotalColorRemovalActive = false;
    let undoStack = [];
    let currentZoom = 1;

    function initializeModalCanvas() {
    const modalCanvas = document.getElementById('modalCanvas');
    modalFabricCanvas = new fabric.Canvas('modalCanvas', {
        selection: false
    });

    // Capturar o container do canvas para o evento de scroll
    const canvasContainer = document.querySelector('.modal-canvas-container');
    
    canvasContainer.addEventListener('wheel', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const delta = e.deltaY;
        let zoom = modalFabricCanvas.getZoom();
        
        // Ajustar o fator de zoom
        if (delta > 0) {
            zoom *= 0.9; // Zoom out
        } else {
            zoom *= 1.1; // Zoom in
        }
        
        // Limitar o zoom entre 0.1 e 20
        zoom = Math.min(Math.max(0.1, zoom), 20);
        
        // Obter a posição do mouse em relação ao canvas
        const pointer = modalFabricCanvas.getPointer(e);
        
        // Aplicar o zoom no ponto do mouse
        modalFabricCanvas.zoomToPoint(pointer, zoom);
        
        currentZoom = zoom;
    }, { passive: false });

    modalFabricCanvas.on('mouse:down', function(options) {
        if (isColorRemovalActive || isTotalColorRemovalActive) {
            const pointer = modalFabricCanvas.getPointer(options.e);
            const zoomAdjustedPointer = {
                x: pointer.x / currentZoom,
                y: pointer.y / currentZoom
            };
            handleColorRemoval(options, zoomAdjustedPointer);
        }
    });
}

    function saveToUndoStack() {
        if (modalFabricCanvas) {
            const state = modalFabricCanvas.toJSON();
            undoStack.push(state);
            if (undoStack.length > 20) {
                undoStack.shift();
            }
        }
    }

    function findImageBounds(imageData) {
        const width = imageData.width;
        const height = imageData.height;
        let minX = width;
        let minY = height;
        let maxX = 0;
        let maxY = 0;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const index = (y * width + x) * 4;
                const alpha = imageData.data[index + 3];
                if (alpha > 0) {
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                }
            }
        }

        return {
            left: minX,
            top: minY,
            right: maxX,
            bottom: maxY,
            width: maxX - minX + 1,
            height: maxY - minY + 1
        };
    }

    function cropTransparentEdges(imageElement) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = imageElement.width;
        tempCanvas.height = imageElement.height;
        tempCtx.drawImage(imageElement, 0, 0);

        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const bounds = findImageBounds(imageData);

        // Create new canvas with cropped dimensions
        const croppedCanvas = document.createElement('canvas');
        const croppedCtx = croppedCanvas.getContext('2d');
        croppedCanvas.width = bounds.width;
        croppedCanvas.height = bounds.height;

        // Draw cropped image
        croppedCtx.drawImage(
            imageElement,
            bounds.left, bounds.top, bounds.width, bounds.height,
            0, 0, bounds.width, bounds.height
        );

        return {
            dataUrl: croppedCanvas.toDataURL(),
            bounds: bounds
        };
    }

    function openColorRemovalModal(sourceObject) {
        const modal = document.getElementById('colorRemovalModal');
        modal.style.display = 'flex';
        
        if (!modalFabricCanvas) {
            initializeModalCanvas();
        }

        isColorRemovalActive = true;
        isTotalColorRemovalActive = false;
        undoStack = [];
        currentZoom = 1;
        
        document.getElementById('modal-click-removal').classList.add('modal-btn-primary');
        document.getElementById('modal-click-removal').classList.remove('modal-btn-secondary');
        document.getElementById('modal-total-removal').classList.remove('modal-btn-primary');
        document.getElementById('modal-total-removal').classList.add('modal-btn-secondary');

        originalImage = sourceObject;
        fabric.Image.fromURL(originalImage._element.src, function(img) {
            const containerWidth = 800;
            const containerHeight = 600 - 70;
            const scale = Math.min(
                containerWidth / img.width,
                containerHeight / img.height
            );

            modalFabricCanvas.setWidth(containerWidth);
            modalFabricCanvas.setHeight(containerHeight);

            img.set({
                scaleX: scale,
                scaleY: scale,
                left: (containerWidth - img.width * scale) / 2,
                top: (containerHeight - img.height * scale) / 2,
                selectable: false,
                hoverCursor: 'crosshair'
            });

            modalFabricCanvas.clear();
            modalFabricCanvas.add(img);
            modalFabricCanvas.renderAll();
            
            saveToUndoStack();
        });
    }

    function closeColorRemovalModal() {
        const modal = document.getElementById('colorRemovalModal');
        modal.style.display = 'none';
        isColorRemovalActive = false;
        isTotalColorRemovalActive = false;
        modalFabricCanvas.defaultCursor = 'default';
    }

    document.getElementById('modal-detection-level').addEventListener('input', function() {
        tolerance = parseInt(this.value);
        document.getElementById('modal-slider-value').textContent = this.value;
    });

    document.getElementById('removeCorCliqueBtn').addEventListener('click', function() {
        const selectedImage = canvas.getActiveObject();
        if (selectedImage && selectedImage.type === 'image') {
            openColorRemovalModal(selectedImage);
        }
    });

    document.getElementById('modal-click-removal').addEventListener('click', function() {
        isColorRemovalActive = true;
        isTotalColorRemovalActive = false;
        modalFabricCanvas.defaultCursor = 'crosshair';
        this.classList.remove('modal-btn-secondary');
        this.classList.add('modal-btn-primary');
        document.getElementById('modal-total-removal').classList.remove('modal-btn-primary');
        document.getElementById('modal-total-removal').classList.add('modal-btn-secondary');
    });

    document.getElementById('modal-total-removal').addEventListener('click', function() {
        isTotalColorRemovalActive = true;
        isColorRemovalActive = false;
        modalFabricCanvas.defaultCursor = 'crosshair';
        this.classList.remove('modal-btn-secondary');
        this.classList.add('modal-btn-primary');
        document.getElementById('modal-click-removal').classList.remove('modal-btn-primary');
        document.getElementById('modal-click-removal').classList.add('modal-btn-secondary');
    });

    document.getElementById('modal-save-btn').addEventListener('click', function() {
        if (originalImage && modalFabricCanvas) {
            const modalImage = modalFabricCanvas.getObjects()[0];
            
            // Process the image to remove transparent edges
            const croppedImage = cropTransparentEdges(modalImage._element);
            
            fabric.Image.fromURL(croppedImage.dataUrl, function(img) {
                // Calculate new scale to maintain visual size
                const originalWidth = originalImage.width * originalImage.scaleX;
                const originalHeight = originalImage.height * originalImage.scaleY;
                const newScaleX = originalWidth / img.width;
                const newScaleY = originalHeight / img.height;

                img.set({
                    left: originalImage.left,
                    top: originalImage.top,
                    scaleX: newScaleX,
                    scaleY: newScaleY,
                    angle: originalImage.angle,
                    name: originalImage.name
                });
                
                canvas.remove(originalImage);
                canvas.add(img);
                
                const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
                if (cloudFolha) {
                    canvas.sendToBack(cloudFolha);
                }
                
                canvas.renderAll();
                updateLayersList();
                closeColorRemovalModal();
            });
        }
    });

    document.getElementById('modal-cancel-btn').addEventListener('click', closeColorRemovalModal);

    document.getElementById('modal-undo-btn').addEventListener('click', function() {
        if (undoStack.length > 0) {
            const previousState = undoStack.pop();
            modalFabricCanvas.loadFromJSON(previousState, function() {
                modalFabricCanvas.renderAll();
            });
        }
    });

    function handleColorRemoval(options, zoomAdjustedPointer) {
    const image = modalFabricCanvas.getObjects()[0];

    if (image && image.type === 'image') {
        saveToUndoStack();

        const imageElement = image._element;
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = imageElement.width;
        tempCanvas.height = imageElement.height;
        tempCtx.drawImage(imageElement, 0, 0, imageElement.width, imageElement.height);

        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        
        // Calculate the inverse transform matrix
        const transform = modalFabricCanvas.viewportTransform;
        
        // Get the actual pointer position in the original image coordinates
        const imageX = Math.round(((options.e.offsetX - transform[4]) / transform[0] - image.left) / image.scaleX);
        const imageY = Math.round(((options.e.offsetY - transform[5]) / transform[3] - image.top) / image.scaleY);
        
        const index = (imageY * imageData.width + imageX) * 4;
        const targetColor = {
            r: imageData.data[index],
            g: imageData.data[index + 1],
            b: imageData.data[index + 2],
            a: imageData.data[index + 3]
        };

        if (isTotalColorRemovalActive) {
            removeTotalColor(imageData, targetColor);
        } else {
            removeColorArea(imageData, targetColor, {x: imageX, y: imageY});
        }

        tempCtx.putImageData(imageData, 0, 0);

        fabric.Image.fromURL(tempCanvas.toDataURL(), function(img) {
            img.set({
                left: image.left,
                top: image.top,
                scaleX: image.scaleX,
                scaleY: image.scaleY,
                selectable: false,
                hoverCursor: 'crosshair'
            });
            modalFabricCanvas.remove(image);
            modalFabricCanvas.add(img);
            modalFabricCanvas.renderAll();
        });
    }
}

    function getColorAtPosition(imageData, pointer, obj) {
        const x = Math.round((pointer.x - obj.left) / obj.scaleX);
        const y = Math.round((pointer.y - obj.top) / obj.scaleY);
        const index = (y * imageData.width + x) * 4;
        return {
            r: imageData.data[index],
            g: imageData.data[index + 1],
            b: imageData.data[index + 2],
            a: imageData.data[index + 3]
        };
    }

    function removeTotalColor(imageData, targetColor) {
        for (let i = 0; i < imageData.data.length; i += 4) {
            const r = imageData.data[i];
            const g = imageData.data[i + 1];
            const b = imageData.data[i + 2];

            if (
                Math.abs(r - targetColor.r) <= tolerance &&
                Math.abs(g - targetColor.g) <= tolerance &&
                Math.abs(b - targetColor.b) <= tolerance
            ) {
                imageData.data[i + 3] = 0;
            }
        }
    }

    function removeColorArea(imageData, targetColor, startPoint) {
        const width = imageData.width;
        const height = imageData.height;
        const stack = [[startPoint.x, startPoint.y]];
        const visited = new Set();

        while (stack.length > 0) {
            const [x, y] = stack.pop();
            const key = `${x},${y}`;

            if (visited.has(key)) continue;
            if (x < 0 || x >= width || y < 0 || y >= height) continue;

            const index = (y * width + x) * 4;
            const r = imageData.data[index];
            const g = imageData.data[index + 1];
            const b = imageData.data[index + 2];

            if (
                Math.abs(r - targetColor.r) <= tolerance &&
                Math.abs(g - targetColor.g) <= tolerance &&
                Math.abs(b - targetColor.b) <= tolerance
            ) {
                imageData.data[index + 3] = 0;  // Make pixel transparent
                visited.add(key);

                // Add neighboring pixels
                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
        }
    }
}

initializeColorRemoval();

// ---------------- fim de seção ---------------------------------------

// ---------------- extrair imagem --------------------------------------

document.getElementById('extractRegionsBtn').addEventListener('click', () => {
    const activeObject = canvas.getActiveObject();
    openExtractRegionsModal(canvas, activeObject);
});

function openExtractRegionsModal(canvas, activeObject) {
    if (!activeObject || activeObject.type !== 'image') {
        showCustomAlert('Selecione uma imagem para extrair as regiões.');
        return;
    }

    const imgElement = activeObject.getElement();
    const canvasTemp = document.createElement('canvas');
    const ctxTemp = canvasTemp.getContext('2d');
    canvasTemp.width = imgElement.width;
    canvasTemp.height = imgElement.height;
    ctxTemp.drawImage(imgElement, 0, 0);

    const imageData = ctxTemp.getImageData(0, 0, canvasTemp.width, canvasTemp.height);
    const visited = new Set();
    const regions = [];

    const minRegionSize = 10;

    for (let y = 0; y < canvasTemp.height; y++) {
        for (let x = 0; x < canvasTemp.width; x++) {
            const pos = (y * canvasTemp.width + x) * 4;
            const alpha = imageData.data[pos + 3];

            if (alpha > 0 && !visited.has(`${x},${y}`)) {
                const region = findRegion(imageData, x, y, canvasTemp.width, canvasTemp.height, visited);
                if (region.pixels.length > 0) {
                    const width = region.bounds.maxX - region.bounds.minX + 1;
                    const height = region.bounds.maxY - region.bounds.minY + 1;
                    if (width >= minRegionSize && height >= minRegionSize) {
                        regions.push(region);
                        addRegionToCanvas(region, imgElement);
                    }
                }
            }
        }
    }

    showCustomAlert(`Extraídas ${regions.length} regiões da imagem.`);
}

function findRegion(imageData, startX, startY, width, height, visited) {
    const pixels = [];
    const queue = [[startX, startY]];
    let minX = startX, minY = startY, maxX = startX, maxY = startY;
    while (queue.length > 0) {
        const [x, y] = queue.shift();
        const key = `${x},${y}`;

        if (visited.has(key)) continue;
        visited.add(key);

        const pos = (y * width + x) * 4;
        if (imageData.data[pos + 3] > 0) {
            pixels.push([x, y]);
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);

            const neighbors = [
                [x + 1, y], [x - 1, y],
                [x, y + 1], [x, y - 1]
            ];
            for (const [nx, ny] of neighbors) {
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const npos = (ny * width + nx) * 4;
                    if (imageData.data[npos + 3] > 0) {
                        queue.push([nx, ny]);
                    }
                }
            }
        }
    }

    return {
        pixels,
        bounds: { minX, minY, maxX, maxY }
    };
}

function addRegionToCanvas(region, imgElement) {
    const canvasTemp = document.createElement('canvas');
    const ctxTemp = canvasTemp.getContext('2d');
    const width = region.bounds.maxX - region.bounds.minX + 1;
    const height = region.bounds.maxY - region.bounds.minY + 1;

    canvasTemp.width = width;
    canvasTemp.height = height;

    ctxTemp.drawImage(imgElement,
        region.bounds.minX, region.bounds.minY, width, height,
        0, 0, width, height);

    const imageData = ctxTemp.getImageData(0, 0, width, height);
    const pixels = new Set(region.pixels.map(([x, y]) => `${x - region.bounds.minX},${y - region.bounds.minY}`));

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (!pixels.has(`${x},${y}`)) {
                const pos = (y * width + x) * 4;
                imageData.data[pos + 3] = 0;
            }
        }
    }

    ctxTemp.putImageData(imageData, 0, 0);

    fabric.Image.fromURL(canvasTemp.toDataURL(), function (img) {
        img.set({
            left: region.bounds.minX,
            top: region.bounds.minY,
            originX: 'left',
            originY: 'top',
            selectable: true,
            evented: true
        });
        canvas.add(img);
        canvas.renderAll();
    });
}

// ------------------------- vetorizar pb -----------------------
function saveState() {
    if (canvas) {
        canvas.history = canvas.history || [];
        const json = canvas.toJSON();
        canvas.history.push(json);
    }
}

document.getElementById('vectorizePBBtn').addEventListener('click', async () => {
    const activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') {
        showCustomAlert('Selecione uma imagem para vetorizar.');
        return;
    }

    const cloudFolha = canvas.getObjects().find(obj => obj.name === 'CloudFolha');
    if (!cloudFolha) {
        showCustomAlert('Folha "CloudFolha" não encontrada.');
        return;
    }

    const centerX = cloudFolha.left + (cloudFolha.width * cloudFolha.scaleX) / 2;
    const centerY = cloudFolha.top + (cloudFolha.height * cloudFolha.scaleY) / 2;
    const imgElement = activeObject.getElement();
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = imgElement.width;
    tempCanvas.height = imgElement.height;
    const ctx = tempCanvas.getContext('2d');
    ctx.drawImage(imgElement, 0, 0);

    const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
        const threshold = 128;
        data[i] = data[i + 1] = data[i + 2] = brightness > threshold ? 255 : 0;
    }
    ctx.putImageData(imageData, 0, 0);

    tempCanvas.toBlob(blob => {
        Potrace.loadImageFromFile(new File([blob], "image.png", { type: "image/png" }));
        Potrace.process(() => {
            const svgContent = Potrace.getSVG(1, { turdsize: 2, alphamax: 1, optcurve: true, detail: 5 });
            fabric.loadSVGFromString(svgContent, (objects, options) => {
                try {
                    const pathData = objects.filter(obj => obj.type === 'path')
                        .map(obj => obj.path.map(point => point.join(' ')).join(' '))
                        .join(' ');

                    if (!pathData) {
                        showCustomAlert('Nenhum caminho foi gerado pelo Potrace.');
                        return;
                    }

                    const path = new fabric.Path(pathData, {
                        left: centerX,
                        top: centerY,
                        fill: 'black',
                        stroke: 'black',
                        strokeWidth: 1,
                        selectable: true,
                        evented: true
                    });

                    path.center();
                    canvas.add(path);
                    canvas.renderAll();
                    saveState();
                } catch (error) {
                    console.error('Erro ao processar o SVG:', error);
                    showCustomAlert('Ocorreu um erro ao vetorizar a imagem.');
                }
            });
        });
    }, 'image/png');
});


    });
  </script>
</body>
</html>
