<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Layout com Canvas</title>
    <script src="https://nkmplay.github.io/cgf/scripts/fabric.min.js"></script>
    <script src="https://nkmplay.github.io/cgf/scripts/jspdf.umd.min.js"></script>
    <script src="https://nkmplay.github.io/cgf/scripts/html2canvas.min.js"></script>
    <script src="https://nkmplay.github.io/cgf/scripts/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://nkmplay.github.io/cgf/scripts/pdf.worker.min.js';</script>
    <link rel="stylesheet" href="https://nkmplay.github.io/cgf/scripts/cropper.min.css">
    <script src="https://nkmplay.github.io/cgf/scripts/cropper.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #categories-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 60px;
            bottom: 0;
            background-color: #0f3460;
            z-index: 95;
            display: flex;
            flex-direction: column;
            color: white;
            font-size: 17px;
            letter-spacing: 2px;
        }

        .category-item {
            flex: 1;
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 10px 0;
            transition: background-color 0.3s;
            font-family: Arial, sans-serif;
            font-weight: bold;
        }

        .category-item:hover {
            background-color: #1a4b8c;
        }

        .category-item.active {
            background-color: #1a4b8c;
        }

        #left-menu {
            position: fixed;
            top: 0;
            left: 63px;
            width: 300px;
            bottom: 0;
            background-color: #0f3460;
            z-index: 90;
            padding: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        #left-menu::-webkit-scrollbar {
            width: 8px;
        }

        #left-menu::-webkit-scrollbar-track {
            background: #0f3460;
        }

        #left-menu::-webkit-scrollbar-thumb {
            background: #1a4b8c;
            border-radius: 4px;
        }

        #left-menu::-webkit-scrollbar-thumb:hover {
            background: #235ab4;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 366px;
            right: 0;
            bottom: 0;
            background-color: transparent;
            overflow: hidden;
        }

        .separator-vertical {
            width: 2px;
            height: 30px;
            background-color: #92c1ff;
            margin: 0 5px;
        }

        .separator {
            height: 2px;
            background-color: #92c1ff;
            margin: 10px 0;
        }

        button, .menu-item {
            background-color: #1a4b8c;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 4px 0;
            border-radius: 4px;
            width: 100%;
            cursor: pointer;
            font-size: 15px;
        }

        button:hover, .menu-item:hover {
            background-color: #235ab4;
        }

        #fileInput {
            display: none;
        }

        .menu-content {
            display: none;
        }

        .menu-content.active {
            display: block;
        }

        #menu-separator {
            position: fixed;
            top: 0;
            left: 60px;
            width: 3px;
            bottom: 0;
            background-color: #235ab4;
            z-index: 92;
        }

        h3 {
            font-size: 20px !important;
            text-align: center;
            font-weight: bold;
        }

        .dimension-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .dimension-input {
            width: 60px;
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #235ab4;
            background: #1a4b8c;
            color: white;
            font-size: 12px;
        }

        .dimension-label {
            font-size: 12px;
        }

        .export-options {
            display: none;
            padding: 10px 0;
        }

        .export-options.active {
            display: block;
        }

        .resolution-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .resolution-control input {
            width: 80px;
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #235ab4;
            background: #1a4b8c;
            color: white;
            font-size: 12px;
        }

        .export-btn {
            margin: 5px 0;
        }

        .image-dimension-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px 0;
            gap: 10px;
        }

        .image-dimension-input {
            width: 60px;
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #235ab4;
            background: #1a4b8c;
            color: white;
            font-size: 12px;
        }

        .image-dimension-label {
            font-size: 12px;
        }

        .duplicate-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .duplicate-input {
            width: 50px;
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #235ab4;
            background: #1a4b8c;
            color: white;
            font-size: 12px;
        }

        .highlight-button {
            background-color: #ffd700 !important;
            height: 50px !important;
            font-weight: bold;
            margin: 10px 0 !important;
            color: black !important;
        }

        .guides-menu {
            display: none;
            margin-top: 10px;
        }

        .guides-menu.active {
            display: block;
        }

        .guides-options {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .guides-options .menu-item.active {
            background-color: #235ab4 !important;
        }

        .guides-options .menu-item {
            flex: 1;
            margin-right: 5px;
        }

        .guides-options .menu-item:last-child {
            margin-right: 0;
        }

        .guides-position {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
        }

        .guides-position span {
            margin-right: 10px;
        }
		.version-badge {
		position: fixed;
		bottom: 5px;
		right: 5px;
		background-color: #ffd700;
		color: Black;
		padding: 2px 6px;
		border-radius: 3px;
		font-size: 20px;
		font-family: Arial, sans-serif;
		z-index: 100;
		pointer-events: none;
		}
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: #0f3460;
            height: 600px;
            max-width: 90%;
            display: flex;
            flex-direction: column;
            border-radius: 8px;
            overflow: hidden;
        }

        .modal-body {
            height: 550px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .modal-footer {
            height: 50px;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 0 10px;
            background: #1a4b8c;
        }

        .modal-footer button {
            margin: 0 5px;
            padding: 5px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .modal-footer .save-btn {
            background: #ffd700;
            color: black;
        }

        .modal-footer .cancel-btn {
            background: #ff4444;
            color: white;
        }

        .crop-container {
            max-height: 550px;
            max-width: 100%;
        }

        .crop-container img {
            max-width: 100%;
            max-height: 550px;
        }

.text-controls {
    padding: 10px;
}

.control-group {
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 10px;
}

.text-input {
    width: 100%;
    padding: 4px;
    background: #1a4b8c;
    color: white;
    border: 1px solid #235ab4;
    border-radius: 4px;
}

.gradient-stops {
    margin-bottom: 10px;
}

.gradient-stop {
    display: flex;
    align-items: center;
    gap: 5px;
    margin-bottom: 5px;
}

.gradient-color {
    width: 50px;
}

.gradient-position {
    width: 60px;
    padding: 4px;
    background: #1a4b8c;
    color: white;
    border: 1px solid #235ab4;
    border-radius: 4px;
}

.remove-stop {
    background: #ff4444;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 2px 6px;
    cursor: pointer;
}

.gradient-angle {
    margin-top: 10px;
}

input[type="color"] {
    width: 100%;
    height: 30px;
    padding: 0;
    border: none;
    border-radius: 4px;
    background: #1a4b8c;
}
.font-label {
    display: block; /* Coloca o texto "Fonte:" em uma linha acima */
    margin-bottom: 5px; /* Espaçamento entre o texto e o combobox */
    font-size: 14px; /* Tamanho do texto "Fonte:" */
}

.font-select {
    width: 100%; /* Ocupa toda a largura disponível */
    height: 40px; /* Altura maior para o combobox */
    font-size: 20px; /* Tamanho do texto dentro do combobox */
    padding: 5px; /* Espaçamento interno para melhorar a aparência */
    border-radius: 4px; /* Borda arredondada */
    border: 1px solid #235ab4; /* Cor da borda */
    background: #1a4b8c; /* Cor de fundo */
    color: white; /* Cor do texto */
}
    </style>
</head>
<body>
    <div id="categories-menu">
        <div class="category-item" data-category="documento">DOCUMENTO</div>
        <div class="category-item active" data-category="editar">EDITAR</div>
        <div class="category-item" data-category="texto">TEXTO</div>
        <div class="category-item" data-category="formas">FORMAS</div>
        <div class="category-item" data-category="filtros">FILTROS</div>
    </div>
    <div id="menu-separator"></div>
    <div id="left-menu">
        <div id="menu-documento" class="menu-content">
            <h3>Tamanho da Folha:</h3>
            <div class="dimension-controls">
                <span class="dimension-label">&#x2194;</span>
                <input type="number" id="width-input" class="dimension-input" value="21" min="1" step="0.1">
                <span class="dimension-label">&#x2195;</span>
                <input type="number" id="height-input" class="dimension-input" value="29.7" min="1" step="0.1">
            </div>
            <div class="separator"></div>
            <button id="openDocumentBtn" class="menu-item">Abrir Documento</button>
            <button id="saveDocumentBtn" class="menu-item">Salvar Documento</button>
            <div class="separator"></div>
            <button id="addGuidesBtn" class="menu-item">Adicionar Guias</button>
            <div id="guidesMenu" class="guides-menu">
                <div class="guides-options">
                    <button id="horizontalGuideBtn" class="menu-item active">Horizontal</button>
                    <button id="verticalGuideBtn" class="menu-item">Vertical</button>
                </div>
                <div class="guides-options">
                    <button id="singleGuideBtn" class="menu-item active">Uma Guia</button>
                    <button id="multipleGuidesBtn" class="menu-item">Várias Guias</button>
                </div>
                <div class="guides-position">
                    <span>Posição (cm):</span>
                    <input type="number" id="guidePositionInput" class="dimension-input" value="1" min="1" step="0.1">
                </div>
                <button id="addGuideBtn" class="menu-item">Adicionar</button>
            </div>
            <div class="separator"></div>
            <button id="addDefaultGuidesBtn" class="menu-item">Adicionar Guias Padrão</button>
            <button id="removeGuidesBtn" class="menu-item">Apagar Guias</button>
            <div class="separator"></div>
            <button id="exportButton" class="menu-item">Exportar</button>
            <div id="exportOptions" class="export-options">
                <div class="resolution-control">
                    <span>Resolução:</span>
                    <input type="number" id="resolutionInput" value="600" min="72" max="2400">
                </div>
                <button class="menu-item export-btn" data-format="png">PNG</button>
                <button class="menu-item export-btn" data-format="jpg">JPG</button>
                <button class="menu-item export-btn" data-format="pdf">PDF</button>
                <button class="menu-item export-btn" data-format="vector-pdf">Formas em PDF Vetor</button>
                <button class="menu-item export-btn" id="previewExportBtn">Ver área de exportação</button>
            </div>
        </div>
        <div id="menu-editar" class="menu-content active">
            <button id="loadImageBtn2" class="highlight-button">Carregar Imagem</button>
            <input type="file" id="fileInput" accept="image/*">
            <div class="image-dimension-controls">
                <span class="image-dimension-label">&#x2194;</span>
                <input type="number" id="image-width-input" class="image-dimension-input" value="0" min="0.1" step="0.1">
                <span class="image-dimension-label">&#x2195;</span>
                <input type="number" id="image-height-input" class="image-dimension-input" value="0" min="0.1" step="0.1">
            </div>
            <div class="separator"></div>
            <button id="cropImageBtn" class="menu-item">Recortar</button>
            <div class="separator"></div>
            <div class="duplicate-control">
                <button id="brushBtn" class="menu-item" style="width: 31%; margin-right: 3.5%;">Pincel</button>
                <button id="eraserBtn" class="menu-item" style="width: 31%; margin-right: 3.5%;">Borracha</button>
                <button id="fillBtn" class="menu-item" style="width: 31%;">Balde</button>
            </div>
            <div class="separator"></div>
            <button id="removeColorClickBtn" class="menu-item">Remover Cor Clique</button>
            <button id="removeColorTotalBtn" class="menu-item">Remover Cor Total</button>
            <div class="separator"></div>
            <button id="aiRemoverBtn" class="menu-item">Removedor IA</button>
            <button id="vectorizePBBtn" class="menu-item">Vetorizar PB</button>
            <div class="separator"></div>
            <div class="duplicate-control">
                <button id="duplicateImageBtn" class="menu-item" style="margin-right: 5px;">Duplicar</button>
                <input type="number" id="duplicateInput" class="duplicate-input" value="1" min="1" step="1">
            </div>
            <div class="duplicate-control">
                <button id="organizeBtn" class="menu-item" style="margin-right: 5px;">Organizar</button>
                <input type="number" id="organizeInput" class="duplicate-input" value="0" min="1" step="0.1">
            </div>
            <div class="duplicate-control">
                <button id="alignHorizontalBtn" class="menu-item" style="width: 48%; margin-right: 4%;">Alinhar &#x2194;</button>
                <button id="alignVerticalBtn" class="menu-item" style="width: 48%;">Alinhar &#x2195;</button>
            </div>
            <div class="duplicate-control">
                <button id="mirrorHorizontalBtn" class="menu-item" style="width: 48%; margin-right: 4%;">Espelhar &#x2194;</button>
                <button id="mirrorVerticalBtn" class="menu-item" style="width: 48%;">Espelhar &#x2195;</button>
            </div>
            <div class="duplicate-control">
                <button id="rotateBtn" class="menu-item" style="margin-right: 5px;">Girar</button>
                <input type="number" id="rotateInput" class="duplicate-input" value="90" min="0" step="1">
            </div>
            <div class="separator"></div>
            <button id="exportSelectedImageBtn" class="menu-item">Exportar Imagem Selecionada</button>
        </div>
		<div id="menu-texto" class="menu-content">
			<button id="addTextBtn" class="highlight-button">Adicionar Texto</button>
			<div class="text-controls">
				<div class="control-group">
					<label for="fontSelect" class="font-label">Fonte:</label>
					<select id="fontSelect" class="text-input font-select">
					<option value="Arial" style="font-family: Arial;">Arial</option>
					  <option value="Arial Black" style="font-family: 'Arial Black';">Arial Black</option>
					  <option value="Brush Script MT" style="font-family: 'Brush Script MT';">Brush Script MT</option>
					  <option value="Bookman Old Style" style="font-family: 'Bookman Old Style';">Bookman Old Style</option>
					  <option value="Comic Sans MS" style="font-family: 'Comic Sans MS';">Comic Sans MS</option>
					  <option value="Courier" style="font-family: Courier;">Courier</option>
					  <option value="Dancing Script" style="font-family: 'Dancing Script';">Dancing Script</option>
					  <option value="Impact" style="font-family: Impact;">Impact</option>
					  <option value="Lucida Handwriting" style="font-family: 'Lucida Handwriting';">Lucida Handwriting</option>
					  <option value="Lucida Sans Unicode" style="font-family: 'Lucida Sans Unicode';">Lucida Sans Unicode</option>
					  <option value="Papyrus" style="font-family: Papyrus;">Papyrus</option>
					  <option value="Segoe Print" style="font-family: 'Segoe Print';">Segoe Print</option>
					  <option value="Segoe Script" style="font-family: 'Segoe Script';">Segoe Script</option>
					  <option value="Segoe UI" style="font-family: 'Segoe UI';">Segoe UI</option>
					  <option value="Times New Roman" style="font-family: 'Times New Roman';">Times New Roman</option>
					  <option value="Trebuchet MS" style="font-family: 'Trebuchet MS';">Trebuchet MS</option>
					  <option value="Verdana" style="font-family: Verdana;">Verdana</option>
					  <option value="Monotype Corsiva" style="font-family: 'Monotype Corsiva';">Monotype Corsiva</option>
					  <option value="Mistral" style="font-family: Mistral;">Mistral</option>
					  <option value="Freestyle Script" style="font-family: 'Freestyle Script';">Freestyle Script</option>
					  <option value="Bradley Hand ITC" style="font-family: 'Bradley Hand ITC';">Bradley Hand ITC</option>
					  <option value="Edwardian Script ITC" style="font-family: 'Edwardian Script ITC';">Edwardian Script ITC</option>
					  <option value="Vivaldi" style="font-family: Vivaldi;">Vivaldi</option>
					  <option value="Rage Italic" style="font-family: 'Rage Italic';">Rage Italic</option>
					</select>
				</div>

				<div class="control-group">
					<label>Tamanho:</label>
					<input type="number" id="fontSizeInput" class="text-input" value="20" min="1">
				</div>

				<div class="control-group">
					<button id="solidColorBtn" class="menu-item active">Cor Padrão</button>
					<button id="gradientColorBtn" class="menu-item">Gradiente</button>
				</div>

				<div id="solidColorPicker" class="control-group">
					<input type="color" id="textColorInput" value="#000000">
				</div>

				<div id="gradientPicker" class="control-group" style="display: none;">
					<div class="gradient-stops">
						<div class="gradient-stop">
							<input type="color" class="gradient-color" value="#000000">
							<input type="number" class="gradient-position" value="100" min="0" max="100">
							<button class="remove-stop">&times;</button>
						</div>
						<div class="gradient-stop">
							<input type="color" class="gradient-color" value="#ff0000">
							<input type="number" class="gradient-position" value="20" min="0" max="100">
							<button class="remove-stop">&times;</button>
						</div>
					</div>
					<button id="addGradientStop" class="menu-item">Adicionar Cor</button>
				</div>

				<div class="separator"></div>

				<div class="control-group">
					<input type="checkbox" id="stroke1Enable">
					<label>Contorno</label>
					<input type="number" id="stroke1Width" class="text-input" value="1" min="0" disabled>
					<input type="color" id="stroke1Color" value="#000000">
				</div>
			</div>
		</div>
        <div id="menu-formas" class="menu-content">
            <button class="menu-item" id="squareBtn">Quadrado</button>
            <button class="menu-item" id="circleBtn">Circulo</button>
            <button class="menu-item" id="triangleBtn">Triângulo</button>
            <button class="menu-item" id="lineBtn">Linha</button>
            <button class="menu-item" id="ellipseBtn">Elipse</button>
            <button class="menu-item" id="polygonBtn">Polígono</button>
            <button class="menu-item" id="polylineBtn">Polilinha</button>
            <button class="menu-item" id="rectangleBtn">Retângulo</button>
            <button class="menu-item" id="cakeBtn">Bolo</button>
        </div>
        <div id="menu-filtros" class="menu-content">
			<!-- Conteúdo do menu Filtros -->
        </div>
    </div>
    <input type="file" id="openFileInput" accept=".cloudapp" style="display: none;">
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    <div id="cropperModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-body">
                <div class="crop-container">
                    <img id="cropperImage" src="">
                </div>
            </div>
            <div class="modal-footer">
                <button class="cancel-btn" id="cancelCropBtn">Cancelar</button>
                <button class="save-btn" id="saveCropBtn">Salvar</button>
            </div>
        </div>
    </div>
	<div class="version-badge">EM DESENVOLVIMENTO - CloudPhoto Alfa V0.15 - 22/12/2024</div>
<script>
const container = document.getElementById('canvas-container');
if (!container) {
  console.error('Canvas container not found');
  throw new Error('Canvas container not found');
}

const canvas = new fabric.Canvas('canvas', {
  preserveObjectStacking: true,
  selection: true
});

if (!canvas || !canvas.add) {
  console.error('Failed to initialize fabric.Canvas');
  throw new Error('Canvas initialization failed');
}

const IMAGE_MAX_SIZE = 4096;
const CM_TO_PX = 37.795275591;

// ---------- Inicio Seção Configuração do Canvas ----------
const patternCanvas = document.createElement('canvas');
patternCanvas.width = 20;
patternCanvas.height = 20;
const ctx = patternCanvas.getContext('2d');

ctx.fillStyle = '#16213e';
ctx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);

ctx.fillStyle = '#1f2b4c';
ctx.beginPath();
ctx.arc(10, 10, 3, 0, Math.PI * 2);
ctx.fill();

const pattern = new fabric.Pattern({
    source: patternCanvas,
    repeat: 'repeat'
});

canvas.setBackgroundColor(pattern, canvas.renderAll.bind(canvas));
// ---------- Final Seção Configuração do Canvas ----------

// ---------- Inicio Seção Variáveis Globais ----------
const fileInput = document.getElementById('fileInput');
const loadImageBtn2 = document.getElementById('loadImageBtn2');
const categoryItems = document.querySelectorAll('.category-item');
const menuContents = document.querySelectorAll('.menu-content');
const widthInput = document.getElementById('width-input');
const heightInput = document.getElementById('height-input');
const imageWidthInput = document.getElementById('image-width-input');
const imageHeightInput = document.getElementById('image-height-input');
let selectedObjectIds = [];
let a4Page;
let MAX_HISTORY = 10;
let history = [];
let currentHistoryIndex = -1;
let previewRect = null;
let guides = [];
let textIdCounter = 0;
const textSettings = {};
let isTextEditing = false;

// ---------- Final Seção Variáveis Globais ----------

// ---------- Inicio Seção Eventos de Categoria ----------
categoryItems.forEach(item => {
  item.addEventListener('click', () => {
    categoryItems.forEach(i => i.classList.remove('active'));
    menuContents.forEach(m => m.classList.remove('active'));
    item.classList.add('active');
    const category = item.dataset.category;
    document.getElementById(`menu-${category}`).classList.add('active');
  });
});

loadImageBtn2.addEventListener('click', () => {
  fileInput.click();
});
// ---------- Final Seção Eventos de Categoria ----------

// ---------- Inicio Seção Dimensões da Página ----------
function updatePageDimensions() {
  const width = parseFloat(widthInput.value) * CM_TO_PX;
  const height = parseFloat(heightInput.value) * CM_TO_PX;

  const existingFolha = canvas.getObjects().filter(obj => obj.id === 'CloudFolha');
  existingFolha.forEach(obj => canvas.remove(obj));

  a4Page = new fabric.Rect({
    id: 'CloudFolha',
    left: (canvas.width - width) / 2,
    top: (canvas.height - height) / 2,
    width: width,
    height: height,
    fill: 'white',
    selectable: false,
    evented: false,
    scaleX: 1,
    scaleY: 1
  });

  canvas.add(a4Page);
  canvas.sendToBack(a4Page);
  canvas.renderAll();
  addToHistory();
}

widthInput.addEventListener('input', updatePageDimensions);
widthInput.addEventListener('change', updatePageDimensions);
heightInput.addEventListener('input', updatePageDimensions);
heightInput.addEventListener('change', updatePageDimensions);
// ---------- Final Seção Dimensões da Página ----------

// ---------- Inicio Seção Redimensionamento do Canvas ----------
function resizeCanvas() {
    canvas.setWidth(container.offsetWidth);
    canvas.setHeight(container.offsetHeight);

    canvas.setBackgroundColor(pattern, canvas.renderAll.bind(canvas));

    const pageHeight = parseFloat(heightInput.value) * CM_TO_PX;
    const containerHeight = container.offsetHeight;

    const zoom = (containerHeight / pageHeight) * 0.7;

    canvas.setZoom(zoom);

    const leftMenuWidth = 0;
    const marginLeft = 10;
    const topMargin = 150;

    canvas.absolutePan({ x: -(leftMenuWidth + marginLeft), y: -topMargin });

    updatePageDimensions();
    canvas.renderAll();
}

let isPanning = false;
let lastPosX;
let lastPosY;
let isSpacePressed = false;

function updateCursor() {
  if (isSpacePressed) {
    canvas.defaultCursor = 'grab';
    canvas.hoverCursor = 'grab';
    if (isPanning) {
      canvas.defaultCursor = 'grabbing';
      canvas.hoverCursor = 'grabbing';
    }
  } else {
    canvas.defaultCursor = 'default';
    canvas.hoverCursor = 'move';
  }
  canvas.requestRenderAll();
}

canvas.on('mouse:wheel', function(opt) {
  var delta = opt.e.deltaY;
  var zoom = canvas.getZoom();
  var point = {
    x: opt.e.offsetX,
    y: opt.e.offsetY
  };

  var factor = 1.1;
  if (delta > 0) {
    zoom = zoom / factor;
  } else {
    zoom = zoom * factor;
  }

  if (zoom > 20) zoom = 20;
  if (zoom < 0.01) zoom = 0.01;

  canvas.zoomToPoint(point, zoom);

  opt.e.preventDefault();
  opt.e.stopPropagation();
});

canvas.on('mouse:down', function(opt) {
  if (isSpacePressed && opt.e.buttons === 1) {
    isPanning = true;
    lastPosX = opt.e.clientX;
    lastPosY = opt.e.clientY;
    updateCursor();
  }
});

canvas.on('mouse:move', function(opt) {
  if (isPanning && opt.e.buttons === 1) {
    const deltaX = opt.e.clientX - lastPosX;
    const deltaY = opt.e.clientY - lastPosY;

    const vpt = canvas.viewportTransform;
    vpt[4] += deltaX;
    vpt[5] += deltaY;

    canvas.requestRenderAll();

    lastPosX = opt.e.clientX;
    lastPosY = opt.e.clientY;
  }
});

canvas.on('mouse:up', function() {
  isPanning = false;
  updateCursor();
});

// Event listeners para a tecla espaço
document.addEventListener('keydown', function(e) {
  if (e.code === 'Space' && !isSpacePressed) {
    e.preventDefault();
    isSpacePressed = true;
    updateCursor();
  }
});

document.addEventListener('keyup', function(e) {
  if (e.code === 'Space') {
    e.preventDefault();
    isSpacePressed = false;
    isPanning = false;
    updateCursor();
  }
});

window.addEventListener('keydown', function(e) {
  if (e.code === 'Space') {
    e.preventDefault();
  }
});

window.addEventListener('load', resizeCanvas);
// ---------- Final Seção Redimensionamento do Canvas ----------

// ---------- Inicio Seção Histórico ----------
function compressCanvasState(canvas) {
    const objects = canvas.getObjects().map(obj => {
        const essentialProps = {
            type: obj.type,
            left: obj.left,
            top: obj.top,
            width: obj.width,
            height: obj.height,
            scaleX: obj.scaleX,
            scaleY: obj.scaleY,
            angle: obj.angle,
            id: obj.id,
            name: obj.name
        };

        if (obj.src) {
            essentialProps.src = obj.src;
        }

        return essentialProps;
    });

    return objects;
}

function saveCanvasState() {
    selectedObjectIds = canvas.getActiveObjects().map(obj => canvas.getObjects().indexOf(obj));
    const state = {
        objects: compressCanvasState(canvas),
        selectedObjectIds: selectedObjectIds
    };
    return JSON.stringify(state);
}

function loadCanvasState(stateStr) {
    try {
        const state = JSON.parse(stateStr);
        canvas.clear();

        if (state.objects) {
            state.objects.forEach(obj => {
                if (obj.type === 'image') {
                    fabric.Image.fromURL(obj.src, img => {
                        img.set(obj);
                        canvas.add(img);
                        canvas.renderAll();
                    });
                } else {
                    let fabricObj;
                    switch(obj.type) {
                        case 'rect':
                            fabricObj = new fabric.Rect(obj);
                            break;
                        // Add other object types as needed
                        default:
                            fabricObj = new fabric.Object(obj);
                    }
                    canvas.add(fabricObj);
                }
            });
        }

        if (state.selectedObjectIds) {
            const objectsToSelect = state.selectedObjectIds
                .map(index => canvas.getObjects()[index])
                .filter(obj => obj);

            if (objectsToSelect.length > 0) {
                if (objectsToSelect.length === 1) {
                    canvas.setActiveObject(objectsToSelect[0]);
                } else {
                    const selection = new fabric.ActiveSelection(objectsToSelect, { canvas });
                    canvas.setActiveObject(selection);
                }
            }
        }

        canvas.renderAll();
    } catch (error) {
        console.error('Error loading canvas state:', error);
    }
}

function saveHistoryToLocalStorage() {
    try {
        const recentHistory = history.slice(-5);
        localStorage.setItem('canvasHistory', JSON.stringify(recentHistory));
        localStorage.setItem('currentHistoryIndex', Math.min(currentHistoryIndex, 4));
    } catch (error) {
        console.warn('Failed to save to localStorage:', error);
        localStorage.clear();
        try {
            const recentHistory = history.slice(-5);
            localStorage.setItem('canvasHistory', JSON.stringify(recentHistory));
            localStorage.setItem('currentHistoryIndex', Math.min(currentHistoryIndex, 4));
        } catch (error) {
            console.error('Still unable to save to localStorage:', error);
        }
    }
}

function loadHistoryFromLocalStorage() {
    try {
        const savedHistory = localStorage.getItem('canvasHistory');
        const savedIndex = localStorage.getItem('currentHistoryIndex');

        if (savedHistory && savedIndex) {
            history = JSON.parse(savedHistory);
            currentHistoryIndex = parseInt(savedIndex);
            if (history.length > 0) {
                loadCanvasState(history[currentHistoryIndex]);
            }
        }
    } catch (error) {
        console.error('Error loading history:', error);
        localStorage.clear();
    }
}

function addToHistory() {
    try {
        if (history.length >= MAX_HISTORY) {
            history = history.slice(-Math.floor(MAX_HISTORY/2));
            currentHistoryIndex = Math.floor(MAX_HISTORY/2) - 1;
        }

        currentHistoryIndex++;
        history = history.slice(0, currentHistoryIndex);
        history.push(saveCanvasState());

        if (currentHistoryIndex % 5 === 0) {
            saveHistoryToLocalStorage();
        }
    } catch (error) {
        console.error('Error adding to history:', error);
    }
}

// ---------- Final Seção Histórico ----------

// ---------- Inicio Seção Manipulação de Objetos ----------
document.addEventListener('keydown', function(e) {
    if (e.key === 'Delete' || e.key === 'Backspace') {
        const activeObject = canvas.getActiveObject();

        if (activeObject) {
            if (activeObject.type.includes('text') && activeObject.isEditing) {
                return;
            } else {
                e.preventDefault();
                canvas.remove(activeObject);
                canvas.requestRenderAll();
                addToHistory();
            }
        }
    }
});

document.addEventListener('paste', function(e) {
  const items = e.clipboardData.items;
  for (let i = 0; i < items.length; i++) {
    const item = items[i];

    // Verifica se é uma imagem
    if (item.type.indexOf('image') !== -1) {
      const blob = item.getAsFile();
      const reader = new FileReader();
      reader.onload = function(event) {
        fabric.Image.fromURL(event.target.result, function(img) {
          const canvasCenter = getCanvasCenter();
          img.set({
            left: canvasCenter.left,
            top: canvasCenter.top,
            originX: 'center',
            originY: 'center',
            perPixelTargetFind: true,
            lockMovementX: false,
            lockMovementY: false
          });
          resizeImageToMaxSize(img);
          canvas.add(img);
          canvas.setActiveObject(img);
          canvas.renderAll();
          addToHistory();
        }, { crossOrigin: 'anonymous' });
      };
      reader.readAsDataURL(blob);
    }

    // Verifica se é texto
    else if (item.type.indexOf('text/plain') !== -1) {
      item.getAsString(function(text) {
        const canvasCenter = getCanvasCenter();

        // Cria um novo IText com o texto colado
        const newText = new fabric.IText(text, {
          left: canvasCenter.left,
          top: canvasCenter.top,
          fontSize: 20, 
          fontFamily: DEFAULT_TEXT_SETTINGS.fontFamily,
          fill: DEFAULT_TEXT_SETTINGS.fill,
          originX: 'center',
          originY: 'center',
          editable: true,
          selectable: true
        });

        // Gera um ID único para o texto
        newText.textId = generateUniqueId();

        // Adiciona o texto ao canvas
        canvas.add(newText);
        canvas.setActiveObject(newText);
        canvas.renderAll();
        addToHistory();

        // Ativa a categoria de texto
        activateTextCategory();
      });
    }
  }
});

document.addEventListener('keydown', function(e) {
  if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
    e.preventDefault();
    const activeObject = canvas.getActiveObject();
    if (activeObject) {
      activeObject.clone(function (cloned) {
        cloned.set({
          left: cloned.left + 20,
          top: cloned.top + 20
        });
        canvas.add(cloned);
        canvas.setActiveObject(cloned);
        canvas.renderAll();
        addToHistory();
      });
    }
  }
});

document.addEventListener('keydown', function(e) {
  if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
    e.preventDefault();
    const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
    if (objects.length > 0) {
      const selection = new fabric.ActiveSelection(objects, { canvas: canvas });
      canvas.setActiveObject(selection);
      canvas.renderAll();
    }
  }
});

document.addEventListener('keydown', function(e) {
  if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
    e.preventDefault();
    const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
    if (cloudFolha) {
      const printCanvas = document.createElement('canvas');
      const ctx = printCanvas.getContext('2d');
      printCanvas.width = cloudFolha.width;
      printCanvas.height = cloudFolha.height;

      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, printCanvas.width, printCanvas.height);

      const tempCanvas = new fabric.Canvas(printCanvas);
      tempCanvas.setWidth(cloudFolha.width);
      tempCanvas.setHeight(cloudFolha.height);

      const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
      objects.forEach(obj => {
        const clonedObj = fabric.util.object.clone(obj);

        const relativeLeft = (obj.left - cloudFolha.left) / cloudFolha.scaleX;
        const relativeTop = (obj.top - cloudFolha.top) / cloudFolha.scaleY;

        clonedObj.set({
          left: relativeLeft,
          top: relativeTop,
          scaleX: obj.scaleX / cloudFolha.scaleX,
          scaleY: obj.scaleY / cloudFolha.scaleY
        });

        tempCanvas.add(clonedObj);
      });

      tempCanvas.renderAll();

      const dataUrl = tempCanvas.toDataURL('image/png');
      const printWindow = window.open('', '_blank');
      printWindow.document.write(`
        <html>
          <head>
            <title>Print</title>
            <style>
              @media print {
                img { max-width: 100%; }
              }
            </style>
          </head>
          <body>
            <img src="${dataUrl}" onload="window.print();window.close()">
          </body>
        </html>
      `);
      printWindow.document.close();

      tempCanvas.dispose();
    }
  }
});

canvas.on('selection:created', function(e) {
    if (e.selected[0] && e.selected[0].type === 'text') {
        activateTextCategory();
    } else {
        const editarCategory = document.querySelector('.category-item[data-category="editar"]');
        if (!editarCategory.classList.contains('active')) {
            categoryItems.forEach(i => i.classList.remove('active'));
            menuContents.forEach(m => m.classList.remove('active'));
            editarCategory.classList.add('active');
            document.getElementById('menu-editar').classList.add('active');
        }
    }
    if (e.selected && e.selected[0]) {
        updateImageDimensionInputs(e.selected[0]);
    }
});

canvas.on('selection:updated', function(e) {
  const editarCategory = document.querySelector('.category-item[data-category="editar"]');
  if (!editarCategory.classList.contains('active')) {
    categoryItems.forEach(i => i.classList.remove('active'));
    menuContents.forEach(m => m.classList.remove('active'));
    editarCategory.classList.add('active');
    document.getElementById('menu-editar').classList.add('active');
  }
  if (e.selected && e.selected[0]) {
    updateImageDimensionInputs(e.selected[0]);
  }
});

canvas.on('selection:cleared', function() {
  imageWidthInput.value = "0";
  imageHeightInput.value = "0";
});

canvas.on('object:modified', function (e) {
    const activeObject = e.target;

    if (activeObject) {
        updateImageDimensionInputs(activeObject);

        if (activeObject.type === 'text') {
            const newFontSize = activeObject.fontSize * activeObject.scaleX;
            activeObject.set('fontSize', newFontSize);
            activeObject.set('scaleX', 1);
            activeObject.set('scaleY', 1);
            canvas.renderAll();

            document.getElementById('fontSizeInput').value = Math.round(newFontSize);
        }
    }
});

canvas.on('object:scaling', function(e) {
  const obj = e.target;
  if (obj) {
    // Atualizar as dimensões da imagem (se for uma imagem)
    updateImageDimensionInputs(obj);

    // Atualizar o tamanho da fonte do texto (se for um texto)
    if (obj.type === 'text') {
      const newFontSize = obj.fontSize * obj.scaleX;
      obj.set('fontSize', newFontSize);
      obj.set('scaleX', 1);
      obj.set('scaleY', 1);
      canvas.renderAll();

      // Atualizar o tamanho da fonte nas configurações
      activeTextSettings.fontSize = newFontSize;
      saveTextSettings(obj);
    }
  }
});

function updateImageDimensionInputs(obj) {
  if (!obj || !obj.type === 'image') {
    imageWidthInput.value = "0";
    imageHeightInput.value = "0";
    return;
  }

  const widthInCm = (obj.width * obj.scaleX) / CM_TO_PX;
  const heightInCm = (obj.height * obj.scaleY) / CM_TO_PX;

  imageWidthInput.value = widthInCm.toFixed(1);
  imageHeightInput.value = heightInCm.toFixed(1);
}

function resizeImageToMaxSize(img) {
  const maxWidthInCm = 21;
  const maxHeightInCm = 29.7;

  const maxWidthPx = maxWidthInCm * CM_TO_PX;
  const maxHeightPx = maxHeightInCm * CM_TO_PX;

  let scaleX = 1;
  let scaleY = 1;

  if (img.width > maxWidthPx || img.height > maxHeightPx) {
    const scaleW = maxWidthPx / img.width;
    const scaleH = maxHeightPx / img.height;
    const scale = Math.min(scaleW, scaleH);

    scaleX = scale;
    scaleY = scale;
  }

  img.set({
    scaleX: scaleX,
    scaleY: scaleY,
    perPixelTargetFind: true,
    lockMovementX: false,
    lockMovementY: false
  });
}

fileInput.addEventListener('change', function (e) {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function (event) {
      fabric.Image.fromURL(event.target.result, function (img) {
        const canvasCenter = getCanvasCenter();

        img.set({
          left: canvasCenter.left,
          top: canvasCenter.top,
          name: file.name,
          originX: 'center',
          originY: 'center',
          perPixelTargetFind: true,
          lockMovementX: false,
          lockMovementY: false
        });

        resizeImageToMaxSize(img);

        canvas.add(img);
        canvas.setActiveObject(img);
        canvas.renderAll();

        updateImageDimensionInputs(img);
        addToHistory();
      }, { crossOrigin: 'anonymous' });
    };
    reader.readAsDataURL(file);
  }
  fileInput.value = '';
});

// ---------- Final Seção Manipulação de Objetos ----------

// ---------- Inicio Seção Formas ----------
function addShape(shapeName) {
  let shape;
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  const center = {
    left: cloudFolha.left + (cloudFolha.width * cloudFolha.scaleX) / 2,
    top: cloudFolha.top + (cloudFolha.height * cloudFolha.scaleY) / 2
  };

  switch(shapeName) {
    case 'square':
      shape = new fabric.Rect({
        left: center.left,
        top: center.top,
        width: 100,
        height: 100,
        fill: '#fff',
        stroke: '#000',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center'
      });
      break;

    case 'circle':
      shape = new fabric.Circle({
        left: center.left,
        top: center.top,
        radius: 50,
        fill: '#fff',
        stroke: '#000',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center'
      });
      break;

    case 'triangle':
      shape = new fabric.Triangle({
        left: center.left,
        top: center.top,
        width: 100,
        height: 100,
        fill: '#fff',
        stroke: '#000',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center'
      });
      break;

    case 'line':
      shape = new fabric.Line([50, 50, 150, 50], {
        left: center.left - 50,
        top: center.top,
        stroke: '#000',
        strokeWidth: 2
      });
      break;

    case 'ellipse':
      shape = new fabric.Ellipse({
        left: center.left,
        top: center.top,
        rx: 80,
        ry: 40,
        fill: '#fff',
        stroke: '#000',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center'
      });
      break;

    case 'polygon':
      shape = new fabric.Polygon([
        {x: 0, y: 0},
        {x: 100, y: 0},
        {x: 100, y: 100},
        {x: 50, y: 150},
        {x: 0, y: 100}
      ], {
        left: center.left - 50,
        top: center.top - 75,
        fill: '#fff',
        stroke: '#000',
        strokeWidth: 2
      });
      break;

    case 'polyline':
      shape = new fabric.Polyline([
        {x: 0, y: 0},
        {x: 50, y: 50},
        {x: 100, y: 0},
        {x: 150, y: 50}
      ], {
        left: center.left - 75,
        top: center.top - 25,
        fill: '',
        stroke: '#000',
        strokeWidth: 2
      });
      break;

    case 'rectangle':
      shape = new fabric.Rect({
        left: center.left,
        top: center.top,
        width: 150,
        height: 100,
        fill: '#fff',
        stroke: '#000',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center'
      });
      break;
  }

  if (shape) {
    canvas.add(shape);
    canvas.setActiveObject(shape);
    canvas.renderAll();
    addToHistory();
  }
}

document.getElementById('squareBtn').addEventListener('click', () => addShape('square'));
document.getElementById('circleBtn').addEventListener('click', () => addShape('circle'));
document.getElementById('triangleBtn').addEventListener('click', () => addShape('triangle'));
document.getElementById('lineBtn').addEventListener('click', () => addShape('line'));
document.getElementById('ellipseBtn').addEventListener('click', () => addShape('ellipse'));
document.getElementById('polygonBtn').addEventListener('click', () => addShape('polygon'));
document.getElementById('polylineBtn').addEventListener('click', () => addShape('polyline'));
document.getElementById('rectangleBtn').addEventListener('click', () => addShape('rectangle'));
// ---------- Final Seção Formas ----------

// ---------- Inicio Seção Guias ----------
const addGuidesBtn = document.getElementById('addGuidesBtn');
const guidesMenu = document.getElementById('guidesMenu');
const addGuideBtn = document.getElementById('addGuideBtn');
const guidePositionInput = document.getElementById('guidePositionInput');
const horizontalGuideBtn = document.getElementById('horizontalGuideBtn');
const verticalGuideBtn = document.getElementById('verticalGuideBtn');
const singleGuideBtn = document.getElementById('singleGuideBtn');
const multipleGuidesBtn = document.getElementById('multipleGuidesBtn');

addGuidesBtn.addEventListener('click', () => {
  guidesMenu.classList.toggle('active');
});

addGuideBtn.addEventListener('click', () => {
  const position = parseFloat(guidePositionInput.value) * CM_TO_PX;
  const isHorizontal = horizontalGuideBtn.classList.contains('active');
  const isSingle = singleGuideBtn.classList.contains('active');

  if (isHorizontal) {
    if (isSingle) {
      addHorizontalGuide(position);
    } else {
      addMultipleHorizontalGuides(position);
    }
  } else {
    if (isSingle) {
      addVerticalGuide(position);
    } else {
      addMultipleVerticalGuides(position);
    }
  }

  guidesMenu.classList.remove('active');
});

function addHorizontalGuide(position) {
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (cloudFolha) {
    const guide = new fabric.Line([cloudFolha.left, cloudFolha.top + position, cloudFolha.left + cloudFolha.width * cloudFolha.scaleX, cloudFolha.top + position], {
      stroke: 'red',
      strokeDashArray: [5, 5],
      selectable: false,
      evented: false,
      id: 'guide'
    });
    guides.push(guide);
    canvas.add(guide);
    canvas.renderAll();
  }
}

function addVerticalGuide(position) {
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (cloudFolha) {
    const guide = new fabric.Line([cloudFolha.left + position, cloudFolha.top, cloudFolha.left + position, cloudFolha.top + cloudFolha.height * cloudFolha.scaleY], {
      stroke: 'red',
      strokeDashArray: [5, 5],
      selectable: false,
      evented: false,
      id: 'guide'
    });
    guides.push(guide);
    canvas.add(guide);
    canvas.renderAll();
  }
}

function addMultipleHorizontalGuides(position) {
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (cloudFolha) {
    const numGuides = Math.floor(cloudFolha.height / position);
    for (let i = 1; i <= numGuides; i++) {
      addHorizontalGuide(i * position);
    }
  }
}

function addMultipleVerticalGuides(position) {
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (cloudFolha) {
    const numGuides = Math.floor(cloudFolha.width / position);
    for (let i = 1; i <= numGuides; i++) {
      addVerticalGuide(i * position);
    }
  }
}

const addDefaultGuidesBtn = document.getElementById('addDefaultGuidesBtn');
addDefaultGuidesBtn.addEventListener('click', addDefaultGuides);

function addDefaultGuides() {
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (cloudFolha) {
    const margin = 0.5 * CM_TO_PX;
    addHorizontalGuide(margin);
    addHorizontalGuide(cloudFolha.height - margin);
    addVerticalGuide(margin);
    addVerticalGuide(cloudFolha.width - margin);
  }
}

const removeGuidesBtn = document.getElementById('removeGuidesBtn');
removeGuidesBtn.addEventListener('click', removeGuides);

function removeGuides() {
  guides.forEach(guide => canvas.remove(guide));
  guides = [];
  canvas.renderAll();
}

canvas.on('object:moving', function(e) {
  const obj = e.target;
  guides.forEach(guide => {
    if (guide.type === 'line') {
      if (guide.x1 === guide.x2) {
        if (Math.abs(obj.left - guide.x1) < 5) {
          obj.set('left', guide.x1);
        }
      } else {
        if (Math.abs(obj.top - guide.y1) < 5) {
          obj.set('top', guide.y1);
        }
      }
    }
  });
});

horizontalGuideBtn.addEventListener('click', () => {
  horizontalGuideBtn.classList.add('active');
  verticalGuideBtn.classList.remove('active');
});

verticalGuideBtn.addEventListener('click', () => {
  verticalGuideBtn.classList.add('active');
  horizontalGuideBtn.classList.remove('active');
});

singleGuideBtn.addEventListener('click', () => {
  singleGuideBtn.classList.add('active');
  multipleGuidesBtn.classList.remove('active');
});

multipleGuidesBtn.addEventListener('click', () => {
  multipleGuidesBtn.classList.add('active');
  singleGuideBtn.classList.remove('active');
});

addGuideBtn.addEventListener('click', () => {
  const position = parseFloat(guidePositionInput.value) * CM_TO_PX;
  const isHorizontal = horizontalGuideBtn.classList.contains('active');
  const isSingle = singleGuideBtn.classList.contains('active');

  if (isHorizontal) {
    if (isSingle) {
      addHorizontalGuide(position);
    } else {
      addMultipleHorizontalGuides(position);
    }
  } else {
    if (isSingle) {
      addVerticalGuide(position);
    } else {
      addMultipleVerticalGuides(position);
    }
  }

  guidesMenu.classList.remove('active');
});
// ---------- Final Seção Guias ----------

// ---------- Inicio Seção Exportação ----------
const exportButton = document.getElementById('exportButton');
const exportOptions = document.getElementById('exportOptions');
const resolutionInput = document.getElementById('resolutionInput');

exportButton.addEventListener('click', () => {
  if (previewRect) {
    canvas.remove(previewRect);
    previewRect = null;
    canvas.renderAll();
  }
  exportOptions.classList.toggle('active');
});

function exportCanvas(format) {
  const dpi = parseInt(resolutionInput.value) || 600;
  const scale = dpi / 96;

  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (!cloudFolha) return;

  const tempContainer = document.createElement('div');
  tempContainer.style.position = 'absolute';
  tempContainer.style.left = '-9999px';
  tempContainer.style.top = '-9999px';
  document.body.appendChild(tempContainer);

  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = cloudFolha.width;
  exportCanvas.height = cloudFolha.height;
  tempContainer.appendChild(exportCanvas);

  const exportFabricCanvas = new fabric.Canvas(exportCanvas);
  exportFabricCanvas.setWidth(cloudFolha.width);
  exportFabricCanvas.setHeight(cloudFolha.height);

  const objects = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
  objects.forEach(obj => {
    const clonedObj = fabric.util.object.clone(obj);

    const relativeLeft = (obj.left - cloudFolha.left) / cloudFolha.scaleX;
    const relativeTop = (obj.top - cloudFolha.top) / cloudFolha.scaleY;

    clonedObj.set({
      left: relativeLeft,
      top: relativeTop,
      scaleX: obj.scaleX / cloudFolha.scaleX,
      scaleY: obj.scaleY / cloudFolha.scaleY
    });

    exportFabricCanvas.add(clonedObj);
  });

  exportFabricCanvas.renderAll();

  html2canvas(exportCanvas, {
    scale: scale,
    backgroundColor: format === 'jpg' ? '#ffffff' : null,
    logging: false,
    useCORS: true
  }).then(outputCanvas => {
    const link = document.createElement('a');
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');

    if (format === 'png' || format === 'jpg') {
      link.href = outputCanvas.toDataURL(`image/${format}`, 1.0);
      link.download = `CloudApp_${timestamp}.${format}`;
      link.click();
    }

    tempContainer.remove();
    exportFabricCanvas.dispose();
  });
}

document.querySelectorAll('.export-btn').forEach(btn => {
  if (btn.id !== 'previewExportBtn') {
    btn.addEventListener('click', () => {
      const format = btn.dataset.format;
      if (format === 'pdf' || format === 'vector-pdf') {
        return;
      }
      exportCanvas(format);
    });
  }
});

document.getElementById('previewExportBtn').addEventListener('click', () => {
  if (previewRect) {
    canvas.remove(previewRect);
    previewRect = null;
    canvas.renderAll();
    return;
  }

  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (!cloudFolha) return;

  previewRect = new fabric.Rect({
    left: cloudFolha.left,
    top: cloudFolha.top,
    width: cloudFolha.width,
    height: cloudFolha.height,
    fill: 'rgba(255, 0, 0, 0.2)',
    stroke: 'red',
    strokeWidth: 2,
    selectable: false,
    evented: false,
    scaleX: cloudFolha.scaleX,
    scaleY: cloudFolha.scaleY
  });

  canvas.add(previewRect);
  canvas.bringToFront(previewRect);
  canvas.renderAll();
});

imageWidthInput.addEventListener('change', () => {
  const activeObj = canvas.getActiveObject();
  if (!activeObj) return;

  const widthInPx = parseFloat(imageWidthInput.value) * CM_TO_PX;
  const heightInPx = parseFloat(imageHeightInput.value) * CM_TO_PX;

  const scaleX = widthInPx / activeObj.width;
  const scaleY = heightInPx / activeObj.height;

  activeObj.set({
    scaleX: scaleX,
    scaleY: scaleY
  });

  canvas.renderAll();
  addToHistory();
});

imageHeightInput.addEventListener('change', () => {
  const activeObj = canvas.getActiveObject();
  if (!activeObj) return;

  const widthInPx = parseFloat(imageWidthInput.value) * CM_TO_PX;
  const heightInPx = parseFloat(imageHeightInput.value) * CM_TO_PX;

  const scaleX = widthInPx / activeObj.width;
  const scaleY = heightInPx / activeObj.height;

  activeObj.set({
    scaleX: scaleX,
    scaleY: scaleY
  });

  canvas.renderAll();
  addToHistory();
});
// ---------- Final Seção Exportação ----------

// ---------- Inicio Seção Manipulação de Objetos Novos ----------
function alignObjectsHorizontal() {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length < 2) return;

  const group = canvas.getActiveObject();
  const groupCenter = group.getCenterPoint();

  activeObjects.forEach(obj => {
    obj.set('left', obj.left + (groupCenter.x - obj.getCenterPoint().x));
  });

  canvas.renderAll();
  addToHistory();
}

function alignObjectsVertical() {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length < 2) return;

  const group = canvas.getActiveObject();
  const groupCenter = group.getCenterPoint();

  activeObjects.forEach(obj => {
    obj.set('top', obj.top + (groupCenter.y - obj.getCenterPoint().y));
  });

  canvas.renderAll();
  addToHistory();
}

function mirrorObjectsHorizontal() {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length === 0) return;

  activeObjects.forEach(obj => {
    obj.set('flipX', !obj.flipX);
  });

  canvas.renderAll();
  addToHistory();
}

function mirrorObjectsVertical() {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length === 0) return;

  activeObjects.forEach(obj => {
    obj.set('flipY', !obj.flipY);
  });

  canvas.renderAll();
  addToHistory();
}

function rotateObjects(angle) {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length === 0) return;

  activeObjects.forEach(obj => {
    obj.rotate(parseFloat(angle));
  });

  canvas.renderAll();
  addToHistory();
}

function exportSelectedObjects() {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length === 0) return;

  const tempCanvas = document.createElement('canvas');
  const tempFabricCanvas = new fabric.Canvas(tempCanvas);

  const bounds = {
    left: Number.POSITIVE_INFINITY,
    top: Number.POSITIVE_INFINITY,
    right: Number.NEGATIVE_INFINITY,
    bottom: Number.NEGATIVE_INFINITY
  };

  activeObjects.forEach(obj => {
    const objBounds = obj.getBoundingRect(true, true);
    bounds.left = Math.min(bounds.left, objBounds.left);
    bounds.top = Math.min(bounds.top, objBounds.top);
    bounds.right = Math.max(bounds.right, objBounds.left + objBounds.width);
    bounds.bottom = Math.max(bounds.bottom, objBounds.top + objBounds.height);
  });

  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;

  tempFabricCanvas.setWidth(width);
  tempFabricCanvas.setHeight(height);

  activeObjects.forEach(obj => {
    obj.clone(function(cloned) {
      cloned.set({
        left: cloned.left - bounds.left,
        top: cloned.top - bounds.top
      });
      tempFabricCanvas.add(cloned);
    });
  });

  setTimeout(() => {
    tempFabricCanvas.renderAll();

    const scaleFactor = 600 / 96;
    const scaledCanvas = document.createElement('canvas');
    scaledCanvas.width = width * scaleFactor;
    scaledCanvas.height = height * scaleFactor;
    const ctx = scaledCanvas.getContext('2d');
    ctx.scale(scaleFactor, scaleFactor);
    ctx.drawImage(tempCanvas, 0, 0);

    const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');
    const link = document.createElement('a');
    link.download = `CloudAppImagem_${timestamp}.png`;
    link.href = scaledCanvas.toDataURL('image/png');
    link.click();

    tempFabricCanvas.dispose();
  }, 100);
}

// Função para obter o centro do canvas
function getCanvasCenter() {
  return {
    left: canvas.getWidth() / 2,
    top: canvas.getHeight() / 2
  };
}

// ---------- Final Seção Manipulação de Objetos Novos ----------

// ---------- Inicio Seção Eventos Novos ----------
document.getElementById('alignHorizontalBtn').addEventListener('click', alignObjectsHorizontal);
document.getElementById('alignVerticalBtn').addEventListener('click', alignObjectsVertical);
document.getElementById('mirrorHorizontalBtn').addEventListener('click', mirrorObjectsHorizontal);
document.getElementById('mirrorVerticalBtn').addEventListener('click', mirrorObjectsVertical);
document.getElementById('rotateBtn').addEventListener('click', function() {
  const angle = document.getElementById('rotateInput').value;
  rotateObjects(angle);
});
document.getElementById('exportSelectedImageBtn').addEventListener('click', exportSelectedObjects);
// ---------- Final Seção Eventos Novos ----------

// ---------- Inicio Seção Documentos ----------
function saveDocument() {
  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (!cloudFolha) return;

  const documentData = {
    version: '1.0',
    pageWidth: widthInput.value,
    pageHeight: heightInput.value,
    objects: []
  };

  canvas.getObjects().forEach(obj => {
    if (obj.id !== 'CloudFolha' && obj.id !== 'guide') {
      const objData = obj.toObject(['id', 'name']);

      if (obj.type === 'image' && obj._element) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = obj._element.width;
        tempCanvas.height = obj._element.height;
        const ctx = tempCanvas.getContext('2d');
        ctx.drawImage(obj._element, 0, 0);
        objData.src = tempCanvas.toDataURL('image/png');
      }

      documentData.objects.push(objData);
    }
  });

  const jsonString = JSON.stringify(documentData);
  const blob = new Blob([jsonString], { type: 'application/json' });
  const url = URL.createObjectURL(blob);

  const link = document.createElement('a');
  link.href = url;
  const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');
  link.download = `documento_${timestamp}.cloudapp`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

function openDocument() {
  const input = document.getElementById('openFileInput');
  input.click();
}

function loadDocumentFile(file) {
  const reader = new FileReader();
  reader.onload = function (event) {
    try {
      const documentData = JSON.parse(event.target.result);

      widthInput.value = documentData.pageWidth;
      heightInput.value = documentData.pageHeight;
      updatePageDimensions();

      const objectsToRemove = canvas.getObjects().filter(obj => obj.id !== 'CloudFolha');
      canvas.remove(...objectsToRemove);

      documentData.objects.forEach(objData => {
        if (objData.type === 'text') {
          // Extrair as configurações do gradiente do objeto salvo
          const gradientData = objData.fill && objData.fill.type === 'linear' ? {
            gradientMode: true,
            gradientType: 'linear',
            gradientStops: objData.fill.colorStops.map(stop => ({
              color: stop.color,
              position: Math.round(stop.offset * 100)
            })),
            gradientAngle: calculateGradientAngle(objData.fill.coords),
            stroke1: {
              enabled: !!objData.stroke,
              width: objData.strokeWidth || 0,
              color: objData.stroke || '#000000'
            }
          } : null;

          // Criar o objeto de texto
          const fabricText = new fabric.Text(objData.text, objData);

          // Gerar e atribuir um ID único se não existir
          if (!objData.textId) {
            fabricText.textId = generateUniqueId();
          } else {
            fabricText.textId = objData.textId;
          }

          // Salvar as configurações no mapa
          if (gradientData) {
            textSettingsMap.set(fabricText.textId, {
              ...gradientData,
              fontFamily: objData.fontFamily,
              fontSize: objData.fontSize,
              fill: objData.fill
            });
          } else {
            textSettingsMap.set(fabricText.textId, {
              gradientMode: false,
              fontFamily: objData.fontFamily,
              fontSize: objData.fontSize,
              fill: objData.fill,
              stroke1: {
                enabled: !!objData.stroke,
                width: objData.strokeWidth || 0,
                color: objData.stroke || '#000000'
              }
            });
          }

          canvas.add(fabricText);
        } else if (objData.type === 'image') {
          fabric.Image.fromURL(objData.src, img => {
            img.set(objData);
            canvas.add(img);
            canvas.renderAll();
          }, { crossOrigin: 'anonymous' });
        } else {
          let fabricObj;
          switch(objData.type) {
            case 'rect':
              fabricObj = new fabric.Rect(objData);
              break;
            case 'circle':
              fabricObj = new fabric.Circle(objData);
              break;
            case 'triangle':
              fabricObj = new fabric.Triangle(objData);
              break;
            case 'line':
              fabricObj = new fabric.Line([objData.x1, objData.y1, objData.x2, objData.y2], objData);
              break;
            default:
              fabricObj = new fabric.Object(objData);
          }
          if (fabricObj) {
            canvas.add(fabricObj);
          }
        }
      });

      canvas.renderAll();
      addToHistory();

    } catch (error) {
      console.error('Erro ao carregar o documento:', error);
    }
  };
  reader.readAsText(file);
}

document.getElementById('openDocumentBtn').addEventListener('click', openDocument);
document.getElementById('saveDocumentBtn').addEventListener('click', saveDocument);
document.getElementById('openFileInput').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (file) {
    loadDocumentFile(file);
  }
  this.value = '';
});

// ---------- Final Seção Documentos ----------

let cropper = null;
let activeObject = null;

document.getElementById('cropImageBtn').addEventListener('click', function() {
    activeObject = canvas.getActiveObject();
    if (!activeObject || activeObject.type !== 'image') {
        return;
    }

    const modal = document.getElementById('cropperModal');
    const cropperImage = document.getElementById('cropperImage');

    if (activeObject._element) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = activeObject._element.width;
        tempCanvas.height = activeObject._element.height;
        const ctx = tempCanvas.getContext('2d');
        ctx.drawImage(activeObject._element, 0, 0);
        cropperImage.src = tempCanvas.toDataURL('image/png');
    }

    modal.style.display = 'flex';

    if (cropper) {
        cropper.destroy();
    }

    cropper = new Cropper(cropperImage, {
        viewMode: 1,
        dragMode: 'move',
        aspectRatio: NaN,
        autoCropArea: 1,
        restore: false,
        modal: true,
        guides: true,
        center: true,
        highlight: true,
        cropBoxMovable: true,
        cropBoxResizable: true,
        toggleDragModeOnDblclick: false,
    });
});

document.getElementById('cancelCropBtn').addEventListener('click', function() {
    const modal = document.getElementById('cropperModal');
    modal.style.display = 'none';
    if (cropper) {
        cropper.destroy();
        cropper = null;
    }
});

document.getElementById('saveCropBtn').addEventListener('click', function() {
    if (!cropper || !activeObject) return;

    const croppedCanvas = cropper.getCroppedCanvas();

    fabric.Image.fromURL(croppedCanvas.toDataURL(), function(img) {
        const originalLeft = activeObject.left;
        const originalTop = activeObject.top;
        const originalScaleX = activeObject.scaleX;
        const originalScaleY = activeObject.scaleY;
        const originalAngle = activeObject.angle;

        img.set({
            left: originalLeft,
            top: originalTop,
            scaleX: originalScaleX,
            scaleY: originalScaleY,
            angle: originalAngle
        });

        canvas.remove(activeObject);
        canvas.add(img);
        canvas.setActiveObject(img);
        canvas.renderAll();
        addToHistory();

        const modal = document.getElementById('cropperModal');
        modal.style.display = 'none';
        cropper.destroy();
        cropper = null;
    });
});

document.getElementById('cropperModal').addEventListener('click', function(e) {
    if (e.target === this) {
        this.style.display = 'none';
        if (cropper) {
            cropper.destroy();
            cropper = null;
        }
    }
});

function duplicateObjects(numDuplicates) {
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length === 0) return;

  let newObjects = [];
  activeObjects.forEach(obj => {
    for (let i = 0; i < numDuplicates; i++) {
      obj.clone(function(cloned) {
        cloned.set({
          left: cloned.left + 20 * (i + 1),
          top: cloned.top + 20 * (i + 1)
        });
        canvas.add(cloned);
        newObjects.push(cloned);
      });
    }
  });

  setTimeout(() => {
    if (newObjects.length > 0) {
      const selection = new fabric.ActiveSelection(newObjects, { canvas });
      canvas.setActiveObject(selection);
      canvas.renderAll();
      addToHistory();
    }
  }, 100);
}

function organizeObjects(marginCm) {
  const marginPx = marginCm * CM_TO_PX;
  const activeObjects = canvas.getActiveObjects();
  if (!activeObjects || activeObjects.length === 0) return;

  const cloudFolha = canvas.getObjects().find(obj => obj.id === 'CloudFolha');
  if (!cloudFolha) return;

  const folhaLeft = cloudFolha.left;
  const folhaTop = cloudFolha.top;
  const folhaWidth = cloudFolha.width * cloudFolha.scaleX;
  const folhaRight = folhaLeft + folhaWidth;

  let currentX = folhaLeft + marginPx;
  let currentY = folhaTop + marginPx;
  let rowHeight = 0;

  activeObjects.forEach(obj => {
    const objWidth = obj.width * obj.scaleX;
    const objHeight = obj.height * obj.scaleY;

    if (currentX + objWidth + marginPx > folhaRight) {
      currentX = folhaLeft + marginPx;
      currentY += rowHeight + marginPx;
      rowHeight = 0;
    }

    obj.set({
      left: currentX,
      top: currentY
    });

    currentX += objWidth + marginPx;
    rowHeight = Math.max(rowHeight, objHeight);
  });

  canvas.renderAll();
  addToHistory();
}

document.getElementById('duplicateImageBtn').addEventListener('click', function() {
  const numDuplicates = parseInt(document.getElementById('duplicateInput').value) || 1;
  duplicateObjects(numDuplicates);
});

document.getElementById('organizeBtn').addEventListener('click', function() {
  const marginCm = parseFloat(document.getElementById('organizeInput').value) || 1;
  organizeObjects(marginCm);
});

// ---------- Inicio Seção Drag and Drop ----------
function handleDrop(e) {
  e.preventDefault();
  e.stopPropagation();

  const files = e.dataTransfer.files;
  handleFiles(files);
}

function handleFiles(files) {
  Array.from(files).forEach(file => {
    if (file.type.startsWith('image/')) {
      handleImageFile(file);
    } else if (file.type === 'application/pdf') {
      handlePdfFile(file);
    } else if (file.name.endsWith('.cloudapp')) {
      loadDocumentFile(file);
    }
  });
}

function handleImageFile(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    if (!canvas || !canvas.add) {
      console.error('Canvas not properly initialized');
      return;
    }

    fabric.Image.fromURL(e.target.result, function(img) {
      if (!img) {
        console.error('Failed to load image');
        return;
      }

      const canvasCenter = getCanvasCenter();
      img.set({
        left: canvasCenter.left,
        top: canvasCenter.top,
        originX: 'center',
        originY: 'center',
        perPixelTargetFind: true,
        lockMovementX: false,
        lockMovementY: false
      });

      resizeImageToMaxSize(img);

      try {
        canvas.add(img);
        canvas.setActiveObject(img);
        canvas.renderAll();
        addToHistory();
      } catch (error) {
        console.error('Error adding image to canvas:', error);
      }
    });
  };
  reader.readAsDataURL(file);
}

function handlePdfFile(file) {
  const modalHtml = `
    <div id="pdfModal" class="modal-overlay" style="display: flex;">
      <div class="modal-content" style="height: auto; padding: 20px; min-width: 300px;">
        <h3 style="color: white; margin-bottom: 20px;">Selecionar Página do PDF</h3>
        <div style="margin-bottom: 20px;">
          <input type="number" id="pdfPageInput" value="1" min="1"
                 style="width: 100%; padding: 8px; background: #1a4b8c; color: white; border: 1px solid #235ab4;">
        </div>
        <div style="display: flex; justify-content: flex-end; gap: 10px;">
          <button id="pdfCancelBtn" class="menu-item" style="width: auto;">Cancelar</button>
          <button id="pdfConfirmBtn" class="menu-item" style="width: auto; background: #ffd700; color: black;">Importar</button>
        </div>
      </div>
    </div>
  `;

  document.body.insertAdjacentHTML('beforeend', modalHtml);

  const modal = document.getElementById('pdfModal');
  const cancelBtn = document.getElementById('pdfCancelBtn');
  const confirmBtn = document.getElementById('pdfConfirmBtn');
  const pageInput = document.getElementById('pdfPageInput');

  cancelBtn.onclick = () => {
    modal.remove();
  };

  confirmBtn.onclick = () => {
    const pageNumber = parseInt(pageInput.value) || 1;
    convertPdfToImage(file, pageNumber - 1).then(() => {
      modal.remove();
    });
  };
}

async function convertPdfToImage(file, pageNumber) {
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;

  if (pageNumber >= pdf.numPages) {
    return;
  }

  const page = await pdf.getPage(pageNumber + 1);
  const scale = 2;
  const viewport = page.getViewport({ scale });

  const tempCanvas = document.createElement('canvas');
  const context = tempCanvas.getContext('2d');
  tempCanvas.height = viewport.height;
  tempCanvas.width = viewport.width;

  await page.render({
    canvasContext: context,
    viewport: viewport
  }).promise;

  if (!canvas || !canvas.add) {
    console.error('Canvas not properly initialized');
    return;
  }

  fabric.Image.fromURL(tempCanvas.toDataURL('image/png'), function(img) {
    if (!img) {
      console.error('Failed to load PDF page as image');
      return;
    }

    const canvasCenter = getCanvasCenter();
    img.set({
      left: canvasCenter.left,
      top: canvasCenter.top,
      originX: 'center',
      originY: 'center',
      perPixelTargetFind: true,
      lockMovementX: false,
      lockMovementY: false
    });

    resizeImageToMaxSize(img);

    try {
      canvas.add(img);
      canvas.setActiveObject(img);
      canvas.renderAll();
      addToHistory();
    } catch (error) {
      console.error('Error adding PDF page to canvas:', error);
    }
  });
}

canvas.wrapperEl.addEventListener('dragover', function(e) {
  e.preventDefault();
  e.stopPropagation();
});

canvas.wrapperEl.addEventListener('drop', handleDrop);
// ---------- Final Seção Drag and Drop ----------

// ---------- Inicio Seção Texto ----------
const DEFAULT_TEXT_SETTINGS = {
    fontSize: 20,
    fontFamily: 'Arial',
    fill: '#000000',
    gradientMode: false,
    gradientType: 'linear',
    gradientStops: [
        { color: '#000000', position: 100 },
        { color: '#ff0000', position: 50 }
    ],
    gradientAngle: 0,
    stroke1: {
        enabled: false,
        width: 1,
        color: '#000000'
    }
};

// Mapa para armazenar configurações de texto por textId
const textSettingsMap = new Map();

// Configurações ativas do texto
let activeTextSettings = {
    gradientMode: false,
    gradientType: 'linear',
    gradientStops: [
        { color: '#000000', position: 100 },
        { color: '#ff0000', position: 50 }
    ],
    gradientAngle: 0,
    stroke1: {
        enabled: false,
        width: 1,
        color: '#000000'
    }
};

// Função para gerar um ID único para cada texto
function generateUniqueId() {
    return '_' + Math.random().toString(36).substr(2, 9);
}

// Função para salvar as configurações de um texto
function saveTextSettings(textObject) {
    if (!textObject.textId) {
        textObject.textId = generateUniqueId();
    }

    const settings = {
        gradientMode: activeTextSettings.gradientMode,
        gradientType: activeTextSettings.gradientType,
        gradientStops: JSON.parse(JSON.stringify(activeTextSettings.gradientStops)),
        gradientAngle: activeTextSettings.gradientAngle,
        stroke1: { ...activeTextSettings.stroke1 },
        fontFamily: textObject.fontFamily,
        fontSize: textObject.fontSize,
        fill: textObject.fill
    };

    textSettingsMap.set(textObject.textId, settings);
}

// Função para carregar as configurações de um texto
function loadTextSettings(textObject) {
    if (!textObject.textId || !textSettingsMap.has(textObject.textId)) {
        return false;
    }

    const settings = textSettingsMap.get(textObject.textId);

    // Atualizar as configurações ativas
    activeTextSettings = JSON.parse(JSON.stringify(settings));

    // Atualizar a interface
    document.getElementById('fontSelect').value = settings.fontFamily;
    document.getElementById('fontSizeInput').value = settings.fontSize;

    // Configurar o modo de cor (sólida ou gradiente)
    document.getElementById('solidColorBtn').classList.toggle('active', !settings.gradientMode);
    document.getElementById('gradientColorBtn').classList.toggle('active', settings.gradientMode);
    document.getElementById('solidColorPicker').style.display = settings.gradientMode ? 'none' : 'block';
    document.getElementById('gradientPicker').style.display = settings.gradientMode ? 'block' : 'none';

    if (!settings.gradientMode) {
        document.getElementById('textColorInput').value = textObject.fill;
    }

    // Atualizar configurações de contorno
    document.getElementById('stroke1Enable').checked = settings.stroke1.enabled;
    document.getElementById('stroke1Width').value = settings.stroke1.width;
    document.getElementById('stroke1Color').value = settings.stroke1.color;
    document.getElementById('stroke1Width').disabled = !settings.stroke1.enabled;
    document.getElementById('stroke1Color').disabled = !settings.stroke1.enabled;

    if (settings.gradientMode) {
        activeTextSettings.gradientStops = [...settings.gradientStops];
        updateGradientStopsUI();
    }
}

// Função para atualizar o texto ativo com as configurações do menu
function updateActiveText() {
    return debugTextOperation('updateActiveText', () => {
        const activeObject = canvas.getActiveObject();
        if (!activeObject || !activeObject.type.includes('text')) {
            console.log('No active text object found');
            return;
        }

        console.log('Current text object settings:', {
            id: activeObject.textId,
            font: activeObject.fontFamily,
            size: activeObject.fontSize,
            fill: activeObject.fill
        });

        // Collect new settings
        const newSettings = {
            fontFamily: document.getElementById('fontSelect').value,
            fontSize: parseInt(document.getElementById('fontSizeInput').value),
            selectable: true,
            editable: true
        };

        // Update fill based on color mode
        if (activeTextSettings.gradientMode) {
            newSettings.fill = createGradientFromStops(activeObject);
        } else {
            newSettings.fill = document.getElementById('textColorInput').value;
        }

        // Apply stroke settings
        if (activeTextSettings.stroke1.enabled) {
            newSettings.stroke = activeTextSettings.stroke1.color;
            newSettings.strokeWidth = parseInt(activeTextSettings.stroke1.width);
            newSettings.paintFirst = 'stroke';
        } else {
            newSettings.stroke = null;
            newSettings.strokeWidth = 0;
        }

        console.log('Applying new settings:', newSettings);

        // Apply settings individually and log any errors
        Object.entries(newSettings).forEach(([key, value]) => {
            try {
                activeObject.set(key, value);
                console.log(`Successfully set ${key} to:`, value);
            } catch (error) {
                console.error(`Error setting ${key}:`, error);
            }
        });

        activeObject.dirty = true;
        saveTextSettings(activeObject);
        canvas.requestRenderAll();
    });
}

// Função para criar um gradiente a partir das paradas (stops)
function createGradientFromStops(obj) {
    const stops = activeTextSettings.gradientStops.sort((a, b) => a.position - b.position);
    const coords = calculateGradientCoords(obj, activeTextSettings.gradientAngle);

    return new fabric.Gradient({
        type: 'linear',
        coords: coords,
        colorStops: stops.map(stop => ({
            offset: stop.position / 100,
            color: stop.color
        }))
    });
}

// Função para calcular as coordenadas do gradiente
function calculateGradientCoords(obj, angle) {
    const angleRad = angle * Math.PI / 180;
    const cos = Math.cos(angleRad);
    const sin = Math.sin(angleRad);

    return {
        x1: -obj.width / 2 * cos,
        y1: -obj.width / 2 * sin,
        x2: obj.width / 2 * cos,
        y2: obj.width / 2 * sin
    };
}

// Função para atualizar os contornos do texto
function updateTextStrokes(obj) {
    const stroke1 = activeTextSettings.stroke1;

    if (stroke1.enabled) {
        obj.set({
            strokeWidth: stroke1.width,
            stroke: stroke1.color,
            paintFirst: 'stroke',
            strokeUniform: true
        });
    } else {
        obj.set({
            strokeWidth: 0,
            stroke: null,
            paintFirst: 'fill',
            strokeUniform: true
        });
    }
}

// Função para ativar a categoria "TEXTO"
function activateTextCategory() {
    categoryItems.forEach(i => i.classList.remove('active'));
    menuContents.forEach(m => m.classList.remove('active'));
    const textoCategory = document.querySelector('.category-item[data-category="texto"]');
    textoCategory.classList.add('active');
    document.getElementById('menu-texto').classList.add('active');
}

// Evento para adicionar um novo texto
document.getElementById('addTextBtn').addEventListener('click', function() {
    debugTextOperation('addTextBtn click', () => {
        const text = new fabric.IText('CloudApp', {
            left: canvas.getWidth() / 2,
            top: canvas.getHeight() / 2,
            fontSize: DEFAULT_TEXT_SETTINGS.fontSize,
            fill: DEFAULT_TEXT_SETTINGS.fill,
            fontFamily: DEFAULT_TEXT_SETTINGS.fontFamily,
            originX: 'center',
            originY: 'center',
            editable: true,
            selectable: true
        });

        text.textId = generateUniqueId();
        console.log('Created new text object with ID:', text.textId);

        // Update UI controls
        document.getElementById('fontSizeInput').value = DEFAULT_TEXT_SETTINGS.fontSize;
        document.getElementById('textColorInput').value = DEFAULT_TEXT_SETTINGS.fill;
        document.getElementById('fontSelect').value = DEFAULT_TEXT_SETTINGS.fontFamily;

        // Reset and save settings
        activeTextSettings = JSON.parse(JSON.stringify(DEFAULT_TEXT_SETTINGS));
        saveTextSettings(text);

        // Add to canvas and activate
        canvas.add(text);
        canvas.setActiveObject(text);
        canvas.requestRenderAll();
        addToHistory();

        activateTextCategory();
        updateTextControlsUI(text);
    });
});

// Remova eventos existentes de duplo clique
canvas.off('mouse:dblclick');
canvas.off('text:editing:exited');

// Adicione o novo evento de duplo clique
canvas.on('mouse:dblclick', function(options) {
    if (options.target && options.target.type.includes('text')) {
        const textObject = options.target;

        textObject.set({
            editable: true,
            selectable: true
        });

        canvas.setActiveObject(textObject);

        if(typeof textObject.enterEditing === 'function') {
            textObject.enterEditing();
            textObject.selectAll();
        }

        canvas.requestRenderAll();
    }
});

// Eventos para quando a edição de texto é iniciada e finalizada
canvas.on('text:editing:entered', function(e) {
    if (e.target) {
        e.target.set({
            editable: true,
            selectable: true,
            isEditing: true
        });
        isTextEditing = true;
        isSpacePressed = false;
        isPanning = false;
        updateCursor();

        if (e.target.hiddenTextarea) {
            e.target.hiddenTextarea.onkeydown = function(ke) {
                if (ke.code === 'Space') {
                    ke.stopPropagation();
                }
            };
        }
    }
});

canvas.on('text:editing:exited', function(e) {
    if (e.target) {
        e.target.set({
            isEditing: false
        });
        isTextEditing = false;
        saveTextSettings(e.target);
        canvas.requestRenderAll();
    }
});

function updateTextControlsUI(textObject) {
    if (!textObject) return;

    const settings = textSettingsMap.get(textObject.textId);
    if (!settings) return;

    // Update font settings
    document.getElementById('fontSizeInput').value = textObject.fontSize;
    document.getElementById('fontSelect').value = textObject.fontFamily;

    // Update color mode
    document.getElementById('gradientColorBtn').classList.toggle('active', settings.gradientMode);
    document.getElementById('solidColorBtn').classList.toggle('active', !settings.gradientMode);
    document.getElementById('gradientPicker').style.display = settings.gradientMode ? 'block' : 'none';
    document.getElementById('solidColorPicker').style.display = settings.gradientMode ? 'none' : 'block';

    if (!settings.gradientMode) {
        document.getElementById('textColorInput').value = textObject.fill;
    }

    // Update stroke settings
    document.getElementById('stroke1Enable').checked = settings.stroke1.enabled;
    document.getElementById('stroke1Width').value = settings.stroke1.width;
    document.getElementById('stroke1Color').value = settings.stroke1.color;
    document.getElementById('stroke1Width').disabled = !settings.stroke1.enabled;
    document.getElementById('stroke1Color').disabled = !settings.stroke1.enabled;

    if (settings.gradientMode) {
        activeTextSettings.gradientStops = [...settings.gradientStops];
        updateGradientStopsUI();
    }
}

// Eventos para atualizar o texto ativo quando as configurações mudarem
document.getElementById('fontSelect').addEventListener('input', updateActiveText);
document.getElementById('fontSizeInput').addEventListener('input', updateActiveText);
document.getElementById('textColorInput').addEventListener('input', updateActiveText);
document.getElementById('stroke1Color').addEventListener('input', updateActiveText);
document.getElementById('stroke1Width').addEventListener('input', updateActiveText);

// Eventos para alternar entre cor sólida e gradiente
document.getElementById('solidColorBtn').addEventListener('click', () => {
    activeTextSettings.gradientMode = false;
    document.getElementById('solidColorPicker').style.display = 'block';
    document.getElementById('gradientPicker').style.display = 'none';
    document.getElementById('solidColorBtn').classList.add('active');
    document.getElementById('gradientColorBtn').classList.remove('active');
    updateActiveText();
});

document.getElementById('gradientColorBtn').addEventListener('click', () => {
    activeTextSettings.gradientMode = true;
    document.getElementById('solidColorPicker').style.display = 'none';
    document.getElementById('gradientPicker').style.display = 'block';
    document.getElementById('gradientColorBtn').classList.add('active');
    document.getElementById('solidColorBtn').classList.remove('active');
    updateGradientStopsUI();
    updateActiveText();
});

// Evento para adicionar uma nova parada de gradiente
document.getElementById('addGradientStop').addEventListener('click', () => {
    const stop = { color: '#000000', position: 50 };
    activeTextSettings.gradientStops.push(stop);
    updateGradientStopsUI();
    updateActiveText();
});

// Eventos para atualizar o contorno do texto
document.getElementById('stroke1Enable').addEventListener('change', function () {
    activeTextSettings.stroke1.enabled = this.checked;
    document.getElementById('stroke1Width').disabled = !this.checked;
    document.getElementById('stroke1Color').disabled = !this.checked;
    updateActiveText();
});

document.getElementById('stroke1Width').addEventListener('input', function () {
    activeTextSettings.stroke1.width = parseInt(this.value);
    updateActiveText();
});

document.getElementById('stroke1Color').addEventListener('input', function () {
    activeTextSettings.stroke1.color = this.value;
    updateActiveText();
});

// Função para atualizar a interface do gradiente
function updateGradientStopsUI() {
    const container = document.querySelector('.gradient-stops');
    container.innerHTML = '';

    activeTextSettings.gradientStops.forEach((stop, index) => {
        const stopEl = document.createElement('div');
        stopEl.className = 'gradient-stop';
        stopEl.innerHTML = `
            <input type="color" class="gradient-color" value="${stop.color}">
            <input type="number" class="gradient-position" value="${stop.position}" min="0" max="100">
            <button class="remove-stop">&times;</button>
        `;

        // Update event listeners to trigger immediate updates
        stopEl.querySelector('.gradient-color').addEventListener('input', (e) => {
            stop.color = e.target.value;
            updateActiveText();
        });

        stopEl.querySelector('.gradient-position').addEventListener('input', (e) => {
            stop.position = parseInt(e.target.value);
            updateActiveText();
        });

        if (index >= 2) {
            stopEl.querySelector('.remove-stop').addEventListener('click', () => {
                activeTextSettings.gradientStops.splice(index, 1);
                updateGradientStopsUI();
                updateActiveText();
            });
        }

        container.appendChild(stopEl);
    });
}

// Eventos para seleção de texto
canvas.on('selection:created', function (e) {
    if (e.selected[0].type.includes('text')) {
        activateTextCategory();
        const textObject = e.selected[0];

        if (!textObject.textId) {
            textObject.textId = generateUniqueId();
            saveTextSettings(textObject);
        }

        const settings = textSettingsMap.get(textObject.textId);
        if (settings) {
            activeTextSettings = JSON.parse(JSON.stringify(settings));
        }

        updateTextControlsUI(textObject);
        updateGradientStopsUI();
        updateActiveText();
    } else if (e.selected[0].type === 'image') {
        categoryItems.forEach(i => i.classList.remove('active'));
        menuContents.forEach(m => m.classList.remove('active'));
        const editCategory = document.querySelector('.category-item[data-category="editar"]');
        editCategory.classList.add('active');
        document.getElementById('menu-editar').classList.add('active');
    }
});

canvas.on('selection:updated', function (e) {
    if (e.selected[0].type.includes('text')) {
        activateTextCategory();
        const textObject = e.selected[0];

        if (!textObject.textId) {
            textObject.textId = generateUniqueId();
            saveTextSettings(textObject);
        }

        const settings = textSettingsMap.get(textObject.textId);
        if (settings) {
            activeTextSettings = JSON.parse(JSON.stringify(settings));
        }

        updateTextControlsUI(textObject);
        updateGradientStopsUI();
        updateActiveText();
    } else if (e.selected[0].type === 'image') {
        categoryItems.forEach(i => i.classList.remove('active'));
        menuContents.forEach(m => m.classList.remove('active'));
        const editCategory = document.querySelector('.category-item[data-category="editar"]');
        editCategory.classList.add('active');
        document.getElementById('menu-editar').classList.add('active');
    }
});

canvas.on('object:modified', function(e) {
    if (e.target && e.target.type.includes('text')) {
        textObject = e.target;

        textObject.set({
            editable: true,
            selectable: true
        });

        if (textObject.scaleX !== 1 || textObject.scaleY !== 1) {
            const newFontSize = Math.round(textObject.fontSize * textObject.scaleX);
            textObject.set({
                fontSize: newFontSize,
                scaleX: 1,
                scaleY: 1
            });

            const settings = textSettingsMap.get(textObject.textId);
            if (settings) {
                settings.fontSize = newFontSize;
                textSettingsMap.set(textObject.textId, settings);
            }

            document.getElementById('fontSizeInput').value = newFontSize;
        }
        canvas.renderAll();
    }
});

canvas.on('selection:cleared', function () {
    // Do not hide text controls anymore
    // Just clear text input if it exists
    const textInput = document.getElementById('textInput');
    if (textInput) {
        textInput.value = '';
    }
});

// Evento para atualizar o tamanho da fonte do texto
document.getElementById('fontSizeInput').addEventListener('input', function () {
    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.type.includes('text')) {
        const newFontSize = parseInt(this.value);
        activeObject.set({
            fontSize: newFontSize,
            scaleX: 1,
            scaleY: 1
        });
        canvas.renderAll();
    }
});

// Add event handler for double click on IText objects
fabric.IText.prototype.dblClickHandler = function() {
    if (this.selectable && this.editable) {
        this.enterEditing();
        this.selectAll();
        return true;
    }
    return false;
};

function calculateGradientAngle(coords) {
    if (!coords) return 0;
    const dx = coords.x2 - coords.x1;
    const dy = coords.y2 - coords.y1;
    return Math.round(Math.atan2(dy, dx) * 180 / Math.PI);
}

// ---------- Final Seção Texto ----------

// ---------- Inicio Seção Eventos de Texto ----------
// Função para processar o texto mantendo espaços e quebras de linha
function processText(text) {
    return text
        .replace(/\r\n/g, '\n')  // Normaliza quebras de linha
        .replace(/\r/g, '\n');   // Converte retornos de carro em quebras de linha
}

// Atualizar o evento de input do textInput
const textInput = document.getElementById('textInput');
if (textInput) {
    textInput.addEventListener('input', function(e) {
        const activeObjects = canvas.getActiveObjects();
        if (activeObjects.length === 0) return;

        const newText = processText(this.value);

        activeObjects.forEach(obj => {
            if (obj.type.includes('text')) {
                obj.set({
                    text: newText,
                    splitByGrapheme: true
                });

                obj.dirty = true;
            }
        });

        canvas.requestRenderAll();
        addToHistory();
    });
}

// Atualizar os eventos de seleção para preservar formatação
canvas.on('selection:created', function(e) {
    if (e.selected[0] && e.selected[0].type.includes('text')) {
        const textObject = e.selected[0];
        const textInput = document.getElementById('textInput');
        if (textInput) {
            textInput.value = textObject.text || '';
            textInput.style.whiteSpace = 'pre-wrap';
        }
    }
});

canvas.on('selection:updated', function(e) {
    if (e.selected[0] && e.selected[0].type.includes('text')) {
        const textObject = e.selected[0];
        const textInput = document.getElementById('textInput');
        if (textInput) {
            textInput.value = textObject.text || '';
            textInput.style.whiteSpace = 'pre-wrap';
        }
    }
});

// Adicionar CSS para o textInput
const style = document.createElement('style');
style.textContent = `
#textInput {
    white-space: pre-wrap;
    min-height: 50px;
    resize: vertical;
    font-family: inherit;
}
`;
document.head.appendChild(style);

function debugTextOperation(operation, callback) {
    console.log(`Starting ${operation}`);
    try {
        const result = callback();
        console.log(`${operation} completed successfully`);
        return result;
    } catch (error) {
        console.error(`Error in ${operation}:`, error);
        return null;
    }
}

['fontSelect', 'fontSizeInput', 'textColorInput'].forEach(id => {
    const element = document.getElementById(id);
    if (element) {
        element.addEventListener('change', function(e) {
            debugTextOperation(`${id} change`, () => {
                console.log(`${id} changed to:`, e.target.value);
                updateActiveText();
            });
        });

        element.addEventListener('input', function(e) {
            debugTextOperation(`${id} input`, () => {
                console.log(`${id} input value:`, e.target.value);
                updateActiveText();
            });
        });
    }
});

document.addEventListener('DOMContentLoaded', () => {
    debugTextOperation('DOMContentLoaded', () => {
        const textControls = document.querySelector('.text-controls');
        if (textControls) {
            textControls.style.display = 'block';
            console.log('Text controls initialized and displayed');
        } else {
            console.warn('Text controls container not found');
        }
    });
});
// ---------- Final Seção Eventos de Texto ----------


</script>
</body>
</html>
